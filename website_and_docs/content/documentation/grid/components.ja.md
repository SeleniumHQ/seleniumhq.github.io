---
title: "Serenium Grid のコンポーネント"
linkTitle: "コンポーネント"
weight: 6
description: >
    Grid コンポーネントの使い方について
aliases: [
"/documentation/ja/grid/grid_4/components_of_a_grid/",
"/ja/documentation/grid/components_of_a_grid/"
]
---

Selenium Grid 4 は以前のバージョンから一新し、全面的に作り直されました。
全体的なパフォーマンスの改善と標準の準拠に加え、より現代的なコンピューティングとソフトウェア開発
に適応するために機能ごとに分割されました。
コンテナ化とクラウド上での分散スケーラビリティのために構築された、現代に適した全く新しいソリューションです。

![Selenium Grid 4 Components](/images/documentation/grid/components.png)

## ルーター

これは Grid のエントリポイントであり、すべての外部リクエストを受信し正しいコンポーネントへルーティングします。

**ルーター**が**新規セッションリクエスト**を受信すると、**新規セッションキュー**に転送します。

リクエストが既存のセッションのものである場合、**ルーター**は**セッションマップ**に、
セッションが実行されている **ノード** ID の取得を要求します。そして**ノード**にリクエストを直接転送します。

**ルーター**は、リクエストをより処理能力の高いコンポーネントに負荷を分散させます。
この負荷分散処理自体もコンポーネントに不必要に負荷をかけることはありません。

## ディストリビューター

**ディストリビューター**の主な責務は 2 つあります:

#### すべてのノードとその capabilities を登録し追跡します

**イベントバス**を通じて**ノード**登録イベントを贈ることで**ノード**を**ディストリビューター**に登録します。
**ディストリビューター**はそのイベントを受けて**ノード**の存在を HTTP リクエストで確認します。
リクエストが成功した場合、**ディストリビューター**は**ノード**を登録し、**Grid モデル**を通じて追跡を開始します。

#### 保留中の新規セッションリクエストを処理する

新規セッションリクエストが**ルーター**に送信されると、リクエストは**新規セッションキュー**に転送されます。
**ディストリビューター**は**新規セッションキュー**をポーリングし、保留中の新規セッションリクエストを見つけると、
セッションが作成可能な**ノード**を探します。 セッションが作成されると**ディストリビューター**は
セッション ID とセッションが実行される**ノード**の紐付けを**セッションマップ**に保存します。

## セッションマップ

**セッションマップ**はセッション ID とセッションが実行されている**ノード**の紐付けを保存します。
これにより**ルーター**がリクエストを**ノード**に転送できるようにします。
**ルーター**は**セッションマップ**にセッション ID に紐づく**ノード**を問い合わせます。

## 新規セッションキュー

**新規セッションキュー**はすべての新規セッションリクエストを FIFO 順で保持します。
リクエストのタイムアウトとリトライ間隔の設定が可能です。

**ルーター**は新規セッションリクエストを**新規セッションキュー**に追加し、レスポンスを待ちます。
**新規セッションキュー**は定期的にキュー内のリクエストがタイムアウトしていないかをチェックし、
タイムアウトしたリクエストがあればリクエストを拒否しキューから取り除きます。

**ディストリビューター**はスロットに空きがあるかを定期的にチェックします。
もし空きがあれば、**新規セッションキュー**から最初にマッチするリクエストを取り出し、
新規セッションの作成を試みます。

リクエストされた capabilities にマッチする空き**ノード**スロットがあれば、
**ディストリビューター**は空きスロットの確保を試みます。全てのスロットがビジーだった場合、
**ディストリビューター**はリクエストをキューに戻します。
リトライ中やキューに戻す最中にリクエストがタイムアウトした場合リクエストは拒否されます。

セッションの作成に成功すると、**ディストリビューター**はセッションの情報を**新規セッションキュー**に送信し、
これが**ルーター**へのレスポンスとして送信され、最終的にクライアントに返ります。

## ノード

Grid は複数の**ノード**を持つことができます。
**ノード**は、各**ノード**が実行されているマシン上の利用可能なブラウザのスロットを管理します。

**ノード**は、**イベントバス**を介して自身を**ディストリビューター**に登録します。
構成情報は登録メッセージの一部として送信されます。

デフォルトでは、**ノード**はマシンのパス上に存在する全てのブラウザドライバーを自動で登録します。
また FireFox と Chromium ベースブラウザの場合、CPU1 つにつき 1 スロットを作成します。
Safari の場合は 1 つのスロットのみ作成します。
[特定の設定によって]({{< ref "/configuration" >}})セッションを Docker コンテナで実行したり、コマンドを中継したりすることも可能です。

**ノード**は受信したコマンドを実行するだけで、コマンドの評価・判断や、フロー制御以外の制御は行いません。
**ノード**が実行されているマシンは、他のコンポーネントと同じ OS を持つ必要はありません。
たとえば、Windows **ノード**には IE Mode on Edge をブラウザーオプションとして提供する機能がありますが、
これは Linux または Mac では不可能です。
Grid は 複数の Windows, Mac, Linux **ノード**で構成することが可能です。

## イベントバス

**イベントバス**は**ノード**、**ディストリビューター**、セッションキュー、**セッションマップ**間の通信経路として機能します。
Grid は内部通信のほとんどをメッセージで行うことで、負荷の高い HTTP 呼び出しを避けています。
分散モードで Grid を起動する場合、**イベントバス**は最初に起動されるべきコンポーネントです。

{{% alert title="Gridを動かす" color="primary" %}}
これらのコンポーネントを使って Grid を実行してみたいですか？
["Grid を始める"]({{< ref "getting_started.md" >}}) でどのように設定するか見ることができます。
{{% /alert %}}
