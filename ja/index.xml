<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Selenium</title><link>https://www.selenium.dev/ja/</link><description>Recent content on Selenium</description><generator>Hugo</generator><language>ja</language><atom:link href="https://www.selenium.dev/ja/index.xml" rel="self" type="application/rss+xml"/><item><title>Browsing Context</title><link>https://www.selenium.dev/ja/documentation/webdriver/bidirectional/webdriver_bidi/browsing_context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/bidirectional/webdriver_bidi/browsing_context/</guid><description>Page being translated from English to Japanese. Do you speak Japanese? Help us to translate it by sending us pull requests! Commands This section contains the APIs related to browsing context commands.
Open a new window Creates a new browsing context in a new window.
Java Ruby JavaScript Kotlin Selenium v4.8
void testCreateAWindow() { BrowsingContext browsingContext = new BrowsingContext(driver, WindowType.WINDOW); Assertions.assertNotNull(browsingContext.getId()); } View full example on GitHub Add Example</description></item><item><title>Browsing Context</title><link>https://www.selenium.dev/ja/documentation/webdriver/bidirectional/webdriver_bidi/input/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/bidirectional/webdriver_bidi/input/</guid><description>Page being translated from English to Japanese. Do you speak Japanese? Help us to translate it by sending us pull requests! This section contains the APIs related to input commands.
Perform Actions Java Ruby JavaScript Kotlin Selenium v4.17
Actions selectThreeOptions = actions.click(options.get(1)).keyDown(Keys.SHIFT).click(options.get(3)).keyUp(Keys.SHIFT); input.perform(windowHandle, selectThreeOptions.getSequences()); View full example on GitHub Add Example
Selenium v4.17
const actions = driver.actions().click(options[1]).keyDown(Key.SHIFT).click(options[3]).keyUp(Key.SHIFT).getSequences() await input.perform(browsingContextId, actions) View full example on GitHub Add Example
Release Actions Java Ruby JavaScript Kotlin Selenium v4.</description></item><item><title>CAPTCHA（キャプチャ）</title><link>https://www.selenium.dev/ja/documentation/test_practices/discouraged/captchas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/test_practices/discouraged/captchas/</guid><description>CAPTCHA（キャプチャ）は、 Completely Automated Public Turing test to tell Computers and Humans Apart （コンピューターと人間を区別するための完全に自動化された公開チューリングテスト）の略で、自動化を防ぐように明示的に設計されているため、試さないでください！ CAPTCHAチェックを回避するための2つの主要な戦略があります。
テスト環境でCAPTCHAを無効にします テストがCAPTCHAをバイパスできるようにするフックを追加します</description></item><item><title>Waiting with Expected Conditions</title><link>https://www.selenium.dev/ja/documentation/webdriver/support_features/expected_conditions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/support_features/expected_conditions/</guid><description>Expected Conditions are used with Explicit Waits. Instead of defining the block of code to be executed with a lambda, an expected conditions method can be created to represent common things that get waited on. Some methods take locators as arguments, others take elements as arguments.
These methods can include conditions such as:
element exists element is stale element is visible text is visible title contains specified value Java Python CSharp Ruby JavaScript Kotlin Expected Conditions Documentation</description></item><item><title>File Upload</title><link>https://www.selenium.dev/ja/documentation/webdriver/elements/file_upload/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/elements/file_upload/</guid><description>Because Selenium cannot interact with the file upload dialog, it provides a way to upload files without opening the dialog. If the element is an input element with type file, you can use the send keys method to send the full path to the file that will be uploaded.
Java Python CSharp Ruby JavaScript Kotlin WebElement fileInput = driver.findElement(By.cssSelector(&amp;#34;input[type=file]&amp;#34;)); fileInput.sendKeys(uploadFile.getAbsolutePath()); driver.findElement(By.id(&amp;#34;file-submit&amp;#34;)).click(); View full example on GitHub file_input = driver.find_element(By.CSS_SELECTOR, &amp;#34;input[type=&amp;#39;file&amp;#39;]&amp;#34;) file_input.</description></item><item><title>Network</title><link>https://www.selenium.dev/ja/documentation/webdriver/bidirectional/webdriver_bidi/network/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/bidirectional/webdriver_bidi/network/</guid><description>Page being translated from English to Japanese. Do you speak Japanese? Help us to translate it by sending us pull requests! Commands This section contains the APIs related to network commands.
Add network intercept Java Ruby JavaScript Kotlin Selenium v4.18
try (Network network = new Network(driver)) { String intercept = network.addIntercept(new AddInterceptParameters(InterceptPhase.BEFORE_REQUEST_SENT)); View full example on GitHub Add Example
Selenium v4.18
const intercept = await network.addIntercept(new AddInterceptParameters(InterceptPhase.BEFORE_REQUEST_SENT)) View full example on GitHub Add Example</description></item><item><title>Script</title><link>https://www.selenium.dev/ja/documentation/webdriver/bidirectional/webdriver_bidi/script/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/bidirectional/webdriver_bidi/script/</guid><description>Page being translated from English to Japanese. Do you speak Japanese? Help us to translate it by sending us pull requests! Commands This section contains the APIs related to script commands.
Call function in a browsing context Java Ruby JavaScript Kotlin Selenium v4.15
try (Script script = new Script(id, driver)) { List&amp;lt;LocalValue&amp;gt; arguments = new ArrayList&amp;lt;&amp;gt;(); arguments.add(PrimitiveProtocolValue.numberValue(22)); Map&amp;lt;Object, LocalValue&amp;gt; value = new HashMap&amp;lt;&amp;gt;(); value.put(&amp;#34;some_property&amp;#34;, LocalValue.numberValue(42)); LocalValue thisParameter = LocalValue.objectValue(value); arguments.</description></item><item><title>コンポーネントを理解する</title><link>https://www.selenium.dev/ja/documentation/overview/components/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/overview/components/</guid><description>WebDriverを使ってテストスイートを構築するには、多くの異なるコンポーネントを理解し、効率的に使用する必要があります。 ソフトウェアのすべてがそうであるように、人によっては同じ概念に異なる用語を使用します。 以下は、本説明での用語の使用方法の内訳です。
用語 API: アプリケーション プログラミング インターフェイス。これはWebDriverを操作するために使用する&amp;quot;コマンド&amp;quot;をまとめたものです。 ライブラリ: APIとそれらを実装する必要なコードを含むコードモジュール。 ライブラリは各言語バインディング向けのものです。例 .jar files for Java, .dll files for .NET, など. ドライバー: 実際のブラウザを制御します。 ほとんどのドライバーはブラウザベンダー自身が作成します。ドライバーは一般的にブラウザ自体を備えたシステムで実行される実行可能モジュールであり、テストスイートを実行するシステムにはありません。（ただし、それらは同じシステムであっても構いません。）注: 一部の人々はドライバーをプロキシと呼んでいます。 フレームワーク: WebDriverスイートのサポートとして使用する追加ライブラリ。これらのフレームワークは、JUnitやNUnitなどのテストフレームワークです。また、CucumberまたはRobotiumといった自然言語機能をサポートするフレームワークでもあります。フレームワークは、テスト対象のシステムの操作や構成、データ作成、テストオラクルなどに記述、利用されます。 部品構成 最低限、WebDriverはドライバーを経由してブラウザーと通信します。 コミュニケーションは双方向です：WebDriverは、ドライバーを経由してブラウザーにコマンドを渡し、同じルートを経由して情報を受け取ります。
ドライバーは、ChromeDriver for GoogleのChrome/Chromium、MozillaのFirefox用GeckoDriverなどブラウザー固有のものです。 ドライバーはブラウザと同じシステムで動きます。これは、テスト自体を実行するところが同じシステムである場合とそうでない場合があります。
上記の簡単な例は 直接 通信です。ブラウザへのコミュニケーションは、Selenium ServerまたはRemoteWebDriverを経由した リモート 通信もできます。RemoteWebDriverは、ドライバーおよびブラウザと同じシステムで実行されます。
リモート通信は、ホストシステム上のドライバーと順に通信するSelenium ServerまたはSelenium Gridを使用して行うこともできます。
どのフレームワークに適しているか WebDriverには1つのジョブしかありません:　上記の任意のメソッドを経由してブラウザと通信します。WebDriverはテストに関することを知りません:　WebDriverは物事を比較する方法、成功または失敗を確認する方法を知りません、そして、レポートや Given/When/Then 文法に関しても確実に知りません。
ここで、さまざまなフレームワークが登場します。 最低限必要なのは言語バインディングに一致するテストフレームワーク、例えば NUnit for .NET, JUnitfor Java, RSpec for Ruby などです。
テストフレームワークは、WebDriverおよびテストの関連手順の実行を担当します。 それは下記図に似ていると考えることができます。
上図でCucumberなどの自然言語のフレームワーク/ツールがテストフレームワークボックスの一部として存在する場合があります、またはテストフレームワークを独自の実装で完全に密閉する場合があります。</description></item><item><title>デザインパターンと開発戦略</title><link>https://www.selenium.dev/ja/documentation/test_practices/design_strategies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/test_practices/design_strategies/</guid><description>(以前の場所: https://github.com/SeleniumHQ/selenium/wiki/Bot-Style-Tests)
概要 時間の経過とともに、プロジェクトは多数のテストが積み上がる傾向があります。 テストの総数が増えると、コードベースに変更を加えることが難しくなります。 アプリケーションが正常に機能していても、1回の&amp;quot;単純な&amp;quot;変更で多数のテストが失敗する可能性があります。 これらの問題が避けられない場合もありますが、問題が発生した場合は、できるだけ早く稼働を再開する必要があります。 次のデザインパターンと戦略は、テストの作成と保守を容易にするためにWebDriverで以前に使用されています。 それらもあなたにとって役に立つかもしれません。
DomainDrivenDesign：アプリのエンドユーザーの言語でテストを表現します。
PageObjects：WebアプリのUIの単純な抽象化
LoadableComponent：PageObjectsをコンポーネントとしてモデリングします。
BotStyleTests：PageObjectsが推奨するオブジェクトベースのアプローチではなく、コマンドベースのアプローチを使用してテストを自動化します。
ロード可能なコンポーネント それは何ですか？ LoadableComponentは、PageObjectsの作成の負担を軽減することを目的としたベースクラスです。 これは、ページがロードされることを保証する標準的な方法を提供し、ページのロードの失敗のデバッグを容易にするフックを提供することによってこれを行います。 これを使用して、テストの定型コードの量を減らすことができます。これにより、テストの保守が面倒になります。
現在、Selenium 2の一部として出荷されるJavaの実装がありますが、使用されるアプローチは、どの言語でも実装できるほど単純です。
簡単な使用方法 モデル化するUIの例として、新しいissueのページをご覧ください。 テスト作成者の観点から、これは新しい問題を提出できるサービスを提供します。 基本的なページオブジェクトは次のようになります。
package com.example.webdriver; import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; public class EditIssue { private final WebDriver driver; public EditIssue(WebDriver driver) { this.driver = driver; } public void setSummary(String summary) { WebElement field = driver.findElement(By.name(&amp;#34;summary&amp;#34;)); clearAndType(field, summary); } public void enterDescription(String description) { WebElement field = driver.findElement(By.name(&amp;#34;comment&amp;#34;)); clearAndType(field, description); } public IssueList submit() { driver.</description></item><item><title>テスト自動化について</title><link>https://www.selenium.dev/ja/documentation/test_practices/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/test_practices/overview/</guid><description>まず、本当にブラウザを使用する必要があるかどうかを自問することから始めます。 ある時点で複雑なWebアプリケーションで作業している場合、おそらくブラウザを開いて実際にテストする必要があるでしょう。
ただし、Seleniumテストなどの機能的なエンドユーザーテストの実行には費用がかかります。 さらに、それらは通常、効果的に実行するために適切なインフラストラクチャを配置する必要があります。 単体テストなどのより軽量なテストアプローチを使用して、または下位レベルのアプローチを使用して、テストすることを実行できるかどうかを常に自問するのは良いルールです。
Webブラウザーのテストビジネスに参加していることを確認し、Selenium環境でテストの記述を開始できるようになったら、通常は3つのステップを組み合わせて実行します。
データを設定する 個別の一連のアクションを実行する 結果を評価する これらの手順はできるだけ短くしてください。 ほとんどの場合、1つまたは2つの操作で十分です。 ブラウザの自動化は&amp;quot;不安定&amp;quot;であるという評判がありますが、実際には、ユーザーが頻繁に多くを求めることが多いためです。 後の章では、特にブラウザーとWebDriver間の競合状態を克服する方法に関する、テストでの断続的な問題を軽減するために使用できる手法に戻ります。
テストを短くして、代替手段がまったくない場合にのみWebブラウザーを使用することで、不安定さを最小限にして多くのテストを実行できます。
Seleniumテストの明確な利点は、ユーザーの観点から、バックエンドからフロントエンドまで、アプリケーションのすべてのコンポーネントをテストする固有の機能です。 つまり、機能テストは実行に費用がかかる可能性がありますが、同時にビジネスに不可欠な大規模な部分も含まれます。
テスト要件 前述のように、Seleniumテストの実行には費用がかかる場合があります。 どの程度までテストを実行しているブラウザーに依存しますが、歴史的にブラウザーの動作は非常に多様であるため、多くの場合、複数のブラウザーに対するクロステストの目標として述べられてきました。
Seleniumを使用すると、複数のオペレーティングシステム上の複数のブラウザーに対して同じ命令を実行できますが、すべての可能なブラウザー、それらの異なるバージョン、およびそれらが実行される多くのオペレーティングシステムの列挙はすぐに重要な作業になります。
例から始めましょう ラリーは、ユーザーがカスタムユニコーンを注文できるWebサイトを作成しました。
一般的なワークフロー（&amp;ldquo;ハッピーパス&amp;quot;と呼ぶ）は次のようなものです。
アカウントを作成する ユニコーンを設定する ショッピングカートにユニコーンを追加します チェックアウトしてお支払い ユニコーンについてフィードバックを送る これらのすべての操作を実行するために1つの壮大なSeleniumスクリプトを作成するのは魅力的です。 その誘惑に抵抗しましょう！ そうすると、
a）時間がかかる
b）ページレンダリングのタイミングの問題に関する一般的な問題が発生する
c）失敗した場合、簡潔で&amp;quot;一目瞭然&amp;quot;にならない、何がうまくいかなかったかを診断する方法がない
というテストになります。
このシナリオをテストするための好ましい戦略は、一連の独立した迅速なテストに分割することです。 各テストには、1つの&amp;quot;理由&amp;quot;が存在します。
2番目のステップであるユニコーンの構成をテストしたいと思います。 次のアクションを実行します。
アカウントを作成する ユニコーンを設定する これらの手順の残りをスキップしていることに注意してください。 この手順を完了した後、他の小さな個別のテストケースで残りのワークフローをテストします。
開始するには、アカウントを作成する必要があります。 ここには、いくつかの選択があります。
既存のアカウントを使用しますか？ 新しいアカウントを作成しますか？ 設定を開始する前に考慮する必要があるそのようなユーザーの特別なプロパティはありますか？ この質問への回答方法に関係なく、テストの&amp;quot;データのセットアップ&amp;quot;部分の一部にすると解決します。 ラリーが、ユーザー（またはだれでも）がユーザーアカウントを作成および更新できるAPIを公開している場合は、それを使用してこの質問に回答してください。 可能であれば、資格情報を使用してログインできるユーザーが&amp;quot;手元に&amp;quot;いる場合にのみブラウザを起動します。
各ワークフローの各テストがユーザーアカウントの作成から始まる場合、各テストの実行に何秒も追加されます。 APIの呼び出しとデータベースとの対話は、ブラウザを開いたり、適切なページに移動したり、フォームをクリックして送信されるのを待つなどの高価なプロセスを必要としない、迅速な&amp;quot;ヘッドレス&amp;quot;操作です。
理想的には、1行のコードでこのセットアップフェーズに対処できます。 これは、ブラウザーが起動する前に実行されます。
Java Python CSharp Ruby JavaScript Kotlin // Create a user who has read-only permissions--they can configure a unicorn, // but they do not have payment information set up, nor do they have // administrative privileges.</description></item><item><title>ブラウザー ナビゲーション</title><link>https://www.selenium.dev/ja/documentation/webdriver/interactions/navigation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/interactions/navigation/</guid><description>ナビゲート ブラウザーを起動した後に最初に行うことは、Webサイトを開くことです。これは1行で実現できます。
Java Python CSharp Ruby JavaScript Kotlin //Convenient driver.get(&amp;#34;https://selenium.dev&amp;#34;); //Longer way driver.navigate().to(&amp;#34;https://selenium.dev&amp;#34;); View full example on GitHub driver.get(&amp;#34;https://www.selenium.dev/selenium/web/index.html&amp;#34;) View full example on GitHub //Convenient driver.Url = &amp;#34;https://selenium.dev&amp;#34;; //Longer driver.Navigate().GoToUrl(&amp;#34;https://selenium.dev&amp;#34;); View full example on GitHub # Convenient way driver.get &amp;#39;https://selenium.dev&amp;#39; # Longer Way driver.navigate.to &amp;#39;https://selenium.dev&amp;#39; //Convenient await driver.get(&amp;#39;https://www.selenium.dev&amp;#39;); //Longer way await driver.navigate().to(&amp;#34;https://www.selenium.dev/selenium/web/index.html&amp;#34;); View full example on GitHub //Convenient driver.get(&amp;#34;https://selenium.dev&amp;#34;) //Longer way driver.navigate().to(&amp;#34;https://selenium.dev&amp;#34;) 戻る ブラウザーの戻るボタンを押す。 Java Python CSharp Ruby JavaScript Kotlin //Back driver.</description></item><item><title>可観測性</title><link>https://www.selenium.dev/ja/documentation/grid/advanced_features/observability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/grid/advanced_features/observability/</guid><description>目次 Selenium Grid 可観測性 分散トレーシング イベントロギング Grid の可観測性 トレースの可視化 イベントログの活用 参考 Selenium Grid Grid は、さまざまなブラウザとオペレーティングシステムの組み合わせでテストを実行することにより、テストのスケーリングと分散を支援します。
可観測性 可観測性(Observability) には、トレース、メトリクス、ログの 3 つの柱があります。 Selenium Grid 4 は完全分散型に設計されているため、可観測性を確保することで内部を理解し、デバッグすることが容易になります。
分散トレーシング 1 つのリクエストやトランザクションは、複数のサービスやコンポーネントにまたがります。 トレースは、各サービスがリクエストを実行する際に、リクエストのライフサイクルをトラックします。これは、エラーシナリオのデバッグに有用です。 トレースで使用される用語は次のとおりです:
トレース トレースでは、複数のサービスを通じてリクエストの出発点から最終地点までを追跡することができます。 このリクエストの旅は、デバッグ、エンドツーエンドフローの監視、障害の特定に役立ちます。 トレースは、エンドツーエンドのリクエストフローを描きます。 各トレースは識別子としてユニークな ID を持っています。
スパン
各トレースは、スパンと呼ばれる時間で区切られたオペレーションで構成されています。 スパンには開始時刻と終了時刻があり、サービスによって実行される操作を表します。 スパンの粒度は実装方法に依存します。各スパンは一意の識別子を持ちます。 トレース内のすべてのスパンは、同じトレース ID を持ちます。
スパン属性 スパン属性は各スパンの付加的な情報を提供するキーと値のペアです。
イベント イベントは、スパン内のタイムスタンプ付きログです。 既存のスパンに追加のコンテキストを提供します。 イベントには、イベント属性としてキーと値のペアも含まれます。
イベントロギング アプリケーションのデバッグには、ロギングが欠かせません。 ログの記録は多くの場合、人間が読める形式で行われます。 しかし、機械がログを検索・分析するためには、明確に定義されたフォーマットである必要があります。 構造化ロギングは、固定フォーマットで一貫してログを記録する一般的な方法です。 一般的には次のようなフィールドが含まれます。
タイムスタンプ ログレベル ロガークラス ログメッセージ (これはさらに、ログが記録された操作に関するフィールドに分解されます) ログとイベントは密接に関連しています。 イベントは、1 つの処理を行うための情報を全てカプセル化します。 ログは基本的にイベントのサブセットです。 重要なのは、どちらもデバッグを支援することです。 詳細については、以下のリソースを参照してください。
https://www.honeycomb.io/blog/how-are-structured-logs-different-from-events/ https://charity.wtf/2019/02/05/logs-vs-structured-events/ Grid の可観測性 Selenium サーバーは OpenTelemetry を使ってトレースできるようになっています。 サーバへのすべてのリクエストは、最初から最後までトレースされます。 各トレースは、リクエストがサーバ内で実行されるときの一連のスパンから構成されます。 Selenium サーバのスパンのほとんどは、2 つのイベントから構成されています。</description></item><item><title>構成ヘルプ</title><link>https://www.selenium.dev/ja/documentation/grid/configuration/help/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/grid/configuration/help/</guid><description>ヘルプコマンドは、現在のコード実装に基づいて情報を表示します。 したがって、ドキュメントが更新されない場合に備えて、正確な情報を提供します。 それは、新しいバージョンのグリッド 4 の構成について学習する最も簡単な方法です。
Info コマンド info コマンドは、次のトピックに関する詳細なドキュメントを提供します。
Selenium の構成 セキュリティ セッションマップの設定 トレース 構成ヘルプ クイック設定のヘルプと概要は、以下を実行することで提供されます。
java -jar selenium-server-&amp;lt;version&amp;gt;.jar info config セキュリティ 安全な通信とノード登録のためのグリッドサーバーの設定の詳細を取得するには、以下を実行します。
java -jar selenium-server-&amp;lt;version&amp;gt;.jar info security セッションマップの設定 デフォルトでは、グリッドはローカルセッションマップを使用してセッション情報を保存します。 グリッドは、Redis や JDBC-SQL がサポートするデータベースなどの追加のストレージオプションをサポートしています。 別のセッションストレージをセットアップするには、次のコマンドを使用してセットアップ手順を取得します。
java -jar selenium-server-&amp;lt;version&amp;gt;.jar info sessionmap OpenTelemetry と Jaeger を使用したトレースの設定 デフォルトでは、トレースは有効になっています。 トレースをエクスポートして Jaeger 経由で視覚化するには、次のコマンドを使用して手順を実行します。
java -jar selenium-server-&amp;lt;version&amp;gt;.jar info tracing SeleniumGrid コマンドを一覧表示する java -jar selenium-server-&amp;lt;version&amp;gt;.jar --config-help 使用可能なすべてのコマンドとそれぞれの説明が表示されます。
コンポーネントヘルプコマンド Selenium ロールの後に–help config オプションを渡して、コンポーネント固有の構成情報を取得します。
スタンドアロン java -jar selenium-server-&amp;lt;version&amp;gt;.jar standalone --help ハブ java -jar selenium-server-&amp;lt;version&amp;gt;.</description></item><item><title>著作権と帰属</title><link>https://www.selenium.dev/ja/documentation/about/copyright/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/about/copyright/</guid><description>Page being translated from English to Japanese. Do you speak Japanese? Help us to translate it by sending us pull requests! Seleniumのドキュメント このドキュメントをできるだけ完全かつ正確にするためにあらゆる努力が払われましたが、 保証または適合性は暗示されていません。 提供される情報は「現状のまま」です。 著者および出版社は、本書に含まれる情報から生じる損失または損害に関して、 いかなる個人または団体に対しても責任も責任も負わないものとします。 ここに含まれる情報の使用に関して、特許責任は一切負いません。
帰属 Thanks to: Selenium メイン Repository @shs96c 5307 commits @barancev 3352 commits @jimevans 2478 commits @titusfortner 1495 commits @jleyba 1464 commits @jarib 1299 commits @AutomatedTester 1222 commits @diemol 1219 commits @dfabulich 1175 commits @illicitonion 1162 commits @p0deje 647 commits @lukeis 599 commits @pujagani 477 commits @eranmes 473 commits @mdub 326 commits @andreastt 289 commits @bonigarcia 265 commits @krosenvold 225 commits @hugs 205 commits @symonk 203 commits @davehunt 200 commits @hbchai 191 commits @harsha509 189 commits @lmtierney 179 commits @joerg1985 151 commits @freynaud 138 commits @samitbadle 137 commits @nirvdrum 133 commits @sevaseva 115 commits @gigix 109 commits @juangj 108 commits @nvborisenko 101 commits @aslakhellesoy 94 commits @alex-savchuk 90 commits @dependabot[bot] 84 commits @selenium-ci 83 commits @andrashatvani 66 commits @ajayk 63 commits @twalpole 49 commits @asashour 48 commits @mikemelia 46 commits @tebeka 44 commits @luke-hill 42 commits @raju249 42 commits @santiycr 41 commits @valfirst 40 commits @sandeepsuryaprasad 37 commits @mach6 36 commits @ddavison 32 commits @joshbruning 30 commits @TamsilAmani 29 commits @mikebroberts 28 commits @JohnChen0 27 commits @renovate[bot] 27 commits @krmahadevan 25 commits @alb-i986 22 commits @bret 20 commits @cgoldberg 20 commits @corevo 20 commits @Stuk 19 commits @iampopovich 17 commits @rbri 16 commits @bwalderman 15 commits @asolntsev 14 commits @bayandin 12 commits @carlosgcampos 12 commits @jayakumarc 12 commits @manuelsblanco 12 commits @potapovDim 12 commits @VietND96 11 commits @43081j 11 commits @detro 10 commits @josephg 10 commits @sbabcoc 9 commits @RustyNail 9 commits @hoefling 9 commits @isaulv 9 commits @whimboo 9 commits @redsquirrel 9 commits @mmerrell 8 commits @mdmintz 8 commits @dratler 7 commits @User253489 7 commits @RevealOscar 7 commits @DrMarcII 7 commits @llaskin 7 commits @SinghHrmn 7 commits @glibas 7 commits @dima-groupon 6 commits @nikolas 6 commits @shucon 6 commits @adiohana 5 commits @oddui 5 commits @seanpoulter 5 commits @nschonni 5 commits @lauromoura 5 commits @JohanLorenzo 5 commits @jimvm 5 commits @Herst 5 commits @gpt14 5 commits Selenium IDE @corevo 2445 commits @toddtarsi 389 commits @baimao8437 88 commits @coinzdude 57 commits @Jongkeun 51 commits @petermouse 36 commits @zavelevsky 34 commits @dependabot[bot] 29 commits @LinYunWen 28 commits @xdennisx 15 commits @AutomatedTester 15 commits @smildlzj 12 commits @raju249 12 commits @diemol 7 commits @matewilk 6 commits @manoj9788 3 commits @Rowdster 3 commits @fernandozw 3 commits @mattonem 3 commits @zewa666 3 commits @shs96c 3 commits @toshiya 2 commits @mrgamedev07 2 commits @Meir017 2 commits @lukeis 2 commits @giuliohome 2 commits @cclauss 2 commits @Angus3280 2 commits @peter-kehl 1 commits @newgenrpa 1 commits @bolasblack 1 commits @vivrichards600 1 commits @swes1117 1 commits @harsha509 1 commits @samitbadle 1 commits @sotayamashita 1 commits @p2635 1 commits @marknoble 1 commits @furkanakkurt1335 1 commits @dvd900 1 commits @cliftonHPE 1 commits @atkulp 1 commits @aplorenzen 1 commits @amitzur 1 commits @AlexGarrity 1 commits Docker Selenium @diemol 538 commits @VietND96 174 commits @selenium-ci 147 commits @ddavison 134 commits @mtscout6 53 commits @kayabendroth 50 commits @dependabot[bot] 42 commits @renovate[bot] 30 commits @elgalu 24 commits @luisfcorreia 15 commits @jamesmortensen 12 commits @WillAbides 8 commits @amardeep2006 7 commits @jsa34 7 commits @MacCracken 5 commits @marten-cz 5 commits @garagepoort 4 commits @metajiji 4 commits @Doofus100500 4 commits @manoj9788 4 commits @ZainabSalameh 4 commits @niQo 4 commits @testphreak 4 commits @chenrui333 4 commits @jeff-jk 3 commits @pabloFuente 3 commits @alexgibson 3 commits @tnguyen14 3 commits @abaldwin-op 3 commits @mtcolman 3 commits @msvticket 3 commits @Remi-p 3 commits @mhnaeem 2 commits @naveensrinivasan 2 commits @phensley 2 commits @anthonybaldwin 2 commits @ryneeverett 2 commits @wheleph 2 commits @Opvolger 2 commits @budtmo 2 commits @SurelyMario 2 commits @schmunk42 2 commits @kmala 2 commits @evertones 2 commits @maxmanuylov 2 commits @mathieu-pousse 2 commits @joaoluizjoaquim 2 commits @glibas 2 commits @efranken 2 commits @ehbello 2 commits @Earlopain 2 commits @AutomationD 2 commits @chuckg 2 commits @den-is 2 commits @therealdjryan 2 commits @baflQA 2 commits @davehunt 2 commits @adriangonciarz 2 commits @ilpianista 2 commits @torstenwalter 1 commits @cvakiitho 1 commits @nefelim4ag 1 commits @tparikkaatmilliman 1 commits @ThomasMeschke 1 commits @trungprivate 1 commits @victor-catalyst 1 commits @VinodAnandan 1 commits @vv-p 1 commits @wesmcouch 1 commits @williamlac 1 commits @schmetzyannick 1 commits @wobal 1 commits @graingert 1 commits @gitter-badger 1 commits @Thab310 1 commits @tadashi0713 1 commits @sylbn 1 commits @subanithak 1 commits @stigkj 1 commits @srguglielmo 1 commits @serlank 1 commits @simonardejr 1 commits @smccarthy-godaddy 1 commits @smccarthy 1 commits @sethuster 1 commits @scottturley 1 commits @imtheish97 1 commits @kinjelom 1 commits @uluzox 1 commits @sehaas 1 commits @StevenBOULLE 1 commits @rklec 1 commits @qxo 1 commits @pujan14 1 commits @ptriller1und1 1 commits @other019 1 commits @oleg-filiutsich 1 commits @nom3ad 1 commits @neilnaveen 1 commits @neben 1 commits Selenium Website &amp;amp; Docs @diemol 742 commits @harsha509 717 commits @selenium-ci 323 commits @titusfortner 230 commits @alaahong 104 commits @pujagani 68 commits @renovate[bot] 59 commits @kzhirata 47 commits @bonigarcia 36 commits @boris779 32 commits @alenros 28 commits @AlexAndradeNet 25 commits @AutomatedTester 23 commits @pallavigitwork 22 commits @manoj9788 21 commits @dependabot[bot] 20 commits @jmartinezpoq 18 commits @ivanrodjr 17 commits @luisfcorreia 15 commits @aguspe 14 commits @shs96c 13 commits @sindhudiddi 12 commits @github-actions[bot] 10 commits @hiroksarker 10 commits @nwintop 8 commits @testbot206 7 commits @krmahadevan 7 commits @tetration 7 commits @connerT 6 commits @Greavox 6 commits @nvborisenko 6 commits @liushilive 6 commits @fufu930 6 commits @Catalin-Negru 5 commits @davieduardo94 5 commits @smilinrobin 5 commits @lvninety 5 commits @hyanx 5 commits @TamsilAmani 5 commits @nainappa 5 commits @Dor-bl 5 commits @deining 4 commits @nevinaydin 4 commits @ant9112 4 commits @peter-kinzelman 4 commits @kathyrollo 4 commits @kjayachandra2000 4 commits @wcmcgee 4 commits @barancev 4 commits @angelovstanton 4 commits @Tolerblanc 3 commits @BlazerYoo 3 commits @twinstae 3 commits @cambiph 3 commits @VietND96 3 commits @TestOpsCloudchen 3 commits @takeyaqa 3 commits @raju249 3 commits @rajeevbarde 3 commits @Madh93 3 commits @mmerrell 3 commits @j3soon 3 commits @jasonren0403 3 commits @jamesmortensen 3 commits @jags14385 3 commits @effeix 3 commits @gnatcatcher-bg 3 commits @ArCiGo 3 commits @Crank4098 3 commits @Arc-Jung 3 commits @coodjokergl 2 commits @ilhanoztozlu 2 commits @eaccmk 2 commits @digitalvoice-nz 2 commits @YoshikiIto 2 commits @sridhar-5 2 commits @urig 2 commits @SparshKesari 2 commits @beatfactor 2 commits @sangheon4353 2 commits @selectorshubsanjay 2 commits @SripriyaPKulkarni 2 commits @GavinHaydy 2 commits @imba-tjd 2 commits @k19810703 2 commits @0420syj 2 commits @TheTestLynx 2 commits @Afranioalves 2 commits @Arpan3323 2 commits @iambocai 2 commits @Bredda 2 commits @cjayswal 2 commits @bongosway 2 commits @SinghHrmn 2 commits @kapilyadav1204 2 commits @mookkiah 2 commits @palotas 2 commits @miekof 2 commits @MohabMohie 2 commits @mmonfared 2 commits Previous Selenium Website @lukeis 417 commits @shs96c 87 commits @pgrandje 79 commits @barancev 63 commits @lightbody 59 commits @ajayk 40 commits @tarun3kumar 40 commits @ddavison 36 commits @davehunt 26 commits @manoj9788 24 commits @peter-kehl 22 commits @lmtierney 21 commits @samitbadle 21 commits @santiycr 19 commits @illicitonion 17 commits @pnewhook 14 commits @AutomatedTester 12 commits @rasmusbergpalm 11 commits @juangj 11 commits @lukeis-sfdc 10 commits @andreastt 7 commits @hugs 6 commits @corevo 5 commits @titusfortner 5 commits @PaulKC 5 commits @llaskin 5 commits @jimevans 5 commits @jarib 5 commits @diemol 3 commits @abhijain2618 2 commits @labkey-tchad 2 commits @paul-hammant 2 commits @mikemelia 2 commits @julianharty 2 commits @hazmeister 2 commits @eranmes 2 commits @darrincherry 2 commits @javabrett 2 commits @alex-savchuk 2 commits @oleksandr-lobunets 2 commits @asashour 2 commits @tobecrazy 1 commits @yasinguzel 1 commits @Vimal-N 1 commits @SteveDesmond-ca 1 commits @harrissAvalon 1 commits @smatei 1 commits @QuinnWilton 1 commits @roydekleijn 1 commits @rbri 1 commits @oifland 1 commits @ohadschn 1 commits @agabrys 1 commits @Zearin 1 commits @beckendorff 1 commits @daveOrleans 1 commits @androiddriver 1 commits @mauk81 1 commits @pharry22 1 commits @prab2112 1 commits @refactoror 1 commits @rogerdc 1 commits @tibord 1 commits @ygmarchi 1 commits @azawawi 1 commits @alb-i986 1 commits @hollingsworthd 1 commits @dylans 1 commits @EmidioStani 1 commits @FagnerMartinsBrack 1 commits @Xaeroxe 1 commits @JamesZoft 1 commits @jleyba 1 commits @JustAGuyTryingToCodeSomething 1 commits @kdamball 1 commits @laurinkeithdavis 1 commits @klamping 1 commits @krmahadevan 1 commits @krosenvold 1 commits @mmerrell 1 commits @grawk 1 commits @mcavigelli 1 commits @michaelwowro 1 commits @muralidharand 1 commits @meeroslaph 1 commits @NickAb 1 commits Previous Documentation Rewrite Project @andreastt 197 commits @selenium-ci 105 commits @diemol 54 commits @hazmeister 30 commits @santiycr 27 commits @AlexAndradeNet 25 commits @lukeis 21 commits @harsha509 17 commits @ddavison 16 commits @djangofan 12 commits @orieken 12 commits @manoj9788 12 commits @davehunt 12 commits @liushilive 8 commits @User253489 7 commits @shs96c 6 commits @mmerrell 6 commits @imba-tjd 6 commits @jimholmes 6 commits @vijay44 5 commits @cambiph 5 commits @NickOppersdorff 4 commits @rivlinp 4 commits @sheg 4 commits @bizob2828 4 commits @detro 3 commits @Ardesco 3 commits @TheTestLynx 3 commits @paul-barton 2 commits @ilhanoztozlu 2 commits @hoanluu 2 commits @sri85 2 commits @miekof 2 commits @palotas 2 commits @systemboogie 2 commits @lmtierney 2 commits @Bredda 2 commits @boris779 2 commits @adithyab94 1 commits @rakib-amin 1 commits @NRezek 1 commits @nikai3d 1 commits @OndraM 1 commits @sourabhkt 1 commits @whhone 1 commits @yarix 1 commits @ZbigniewZabost 1 commits @agmen 1 commits @hking-shutterfly 1 commits @jimevans 1 commits @948462448 1 commits @marilyn 1 commits @riccione 1 commits @tungla 1 commits @zeljkofilipin 1 commits @alenros 1 commits @p0deje 1 commits @AJ-72 1 commits @abotalov 1 commits @bhardin 1 commits @chamiz 1 commits @dennybiasiolli 1 commits @donhuvy 1 commits @bongosway 1 commits @nicegraham 1 commits @austenjt 1 commits @kmcgon 1 commits @MartinDelille 1 commits @michael-coleman 1 commits @misiekofski 1 commits @MilanMasek 1 commits Seleniumドキュメントプロジェクトで使用されるサードパーティソフトウェア Software Version License Hugo v0.</description></item><item><title>要素を探す</title><link>https://www.selenium.dev/ja/documentation/webdriver/elements/locators/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/elements/locators/</guid><description>ロケーターは、ページ上の要素を識別する方法です。 これは、検索要素 メソッドに渡される引数です。
検出方法とは別にロケーターを宣言するタイミングと理由など、 ロケーターに関するヒントについては、 推奨されるテストプラクティス を確認してください。
要素選択の方法 WebDriverには標準のロケータが8種類あります。
ロケータ 詳細 class name class名に値を含む要素を探す (複合クラス名は使えない) css selector CSSセレクタが一致する要素を探す id id属性が一致する要素を探す name name属性が一致する要素を探す link text a要素のテキストが一致する要素を探す partial link text a要素のテキストが部分一致する要素を探す tag name タグ名が一致する要素を探す xpath XPathと一致する要素を探す Creating Locators To work on a web element using Selenium, we need to first locate it on the web page. Selenium provides us above mentioned ways, using which we can locate element on the page. To understand and create locator we will use the following HTML snippet.</description></item><item><title>Chrome DevTools Protocol Endpoint</title><link>https://www.selenium.dev/ja/documentation/webdriver/bidirectional/chrome_devtools/cdp_endpoint/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/bidirectional/chrome_devtools/cdp_endpoint/</guid><description>These methods will eventually be removed. It is recommended to use the WebDriver-BiDi or WebDriver Bidi APIs methods where possible to ensure future compatibility.
Usage Generally you should prefer the use of the CDP API over this approach, but sometimes the syntax is cleaner or significantly more simple.
Limitations include:
It only works for use cases that are limited to setting or getting information; any actual asynchronous interactions require another implementation You have to know the exactly correct &amp;ldquo;magic strings&amp;rdquo; for domains and keys It is possible that an update to Chrome will change the required parameters Examples Set Cookie An alternate implementation can be found at CDP API Set Cookie</description></item><item><title>Selenium GridのCLI オプション</title><link>https://www.selenium.dev/ja/documentation/grid/configuration/cli_options/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/grid/configuration/cli_options/</guid><description>Grid の設定には、さまざまなセクションが用意されています。 各セクションには、コマンドライン引数で設定可能なオプションがあります。コマンドライン引数で設定できます。
コンポーネントとセクションの対応は以下の通りです。
オプションが変更、または追加されたが文書化されていない場合、 このドキュメントは古くなる可能性があることに注意してください。 もしそのような状況を見つけたら、&amp;ldquo;構成ヘルプ&amp;rdquo;を確認し、 ドキュメントを更新するプルリクエストを気軽に送ってください。
セクション スタンドアロン ハブ ノード ディストリビューター ルーター セッション 新規セッションキュー Distributor Docker Events Logging Network Node Router Relay Server SessionQueue Sessions Distributor オプション 型 値/例 概要 --healthcheck-interval int 120 全てのノードに対してヘルスチェックを実行する頻度（秒）を指定します。これにより、サーバーは全てのノードに対して正常に ping を送信できるようになります。 --distributor uri http://localhost:5553 ディストリビューターの URL。 --distributor-host string localhost ディストリビューターがリッスンするホスト名。 --distributor-implementation string org.openqa.selenium.grid.distributor.local.LocalDistributor デフォルトでないディストリビューター実装の完全なクラス名。 --distributor-port int 5553 ディストリビューターがリッスンするポート番号。 --reject-unsupported-caps boolean false Grid がサポートしていない capabilities をリクエストされた時、ディストリビューターがリクエストを即座に今日できるようにします。これはオンデマンドでノードを立ち上げをしない Grid の設定に適しています。 --slot-matcher string org.openqa.selenium.grid.data.DefaultSlotMatcher デフォルト以外で使用するスロットマッチャーの完全なクラス名。これはノードが特定のセッションをサポートできるかを判断するために使用されます。 --slot-selector string org.</description></item><item><title>GraphQLクエリのサポート</title><link>https://www.selenium.dev/ja/documentation/grid/advanced_features/graphql_support/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/grid/advanced_features/graphql_support/</guid><description>GraphQLは、APIのクエリ言語であり、既存のデータでこれらのクエリを実行するためのランタイムです。 これにより、ユーザーは必要なものだけを正確に要求することができます。
列挙型(Enum) 列挙型は、フィールドの可能な値のセットを表します。
たとえば、 Node オブジェクトには status というフィールドがあります。 UP 、 DRAINING 、または UNAVAILABLE の可能性があるため、状態は、 列挙型（具体的には、Status タイプ）です。
スカラー スカラーはプリミティブ値です： Int 、 Float 、 String 、 Boolean 、または ID 。
GraphQL APIを呼び出すときは、スカラーのみを返すまでネストされたサブフィールドを指定する必要があります。
スキーマの構造 グリッドスキーマの構造は次のとおりです。
{ session(id: &amp;#34;&amp;lt;session-id&amp;gt;&amp;#34;) : { id, capabilities, startTime, uri, nodeId, nodeUri, sessionDurationMillis slot : { id, stereotype, lastStarted } } grid: { uri, totalSlots, nodeCount, maxSession, sessionCount, version, sessionQueueSize } sessionsInfo: { sessionQueueRequests, sessions: [ { id, capabilities, startTime, uri, nodeId, nodeUri, sessionDurationMillis slot : { id, stereotype, lastStarted } } ] } nodesInfo: { nodes : [ { id, uri, status, maxSession, slotCount, sessions: [ { id, capabilities, startTime, uri, nodeId, nodeUri, sessionDurationMillis slot : { id, stereotype, lastStarted } } ], sessionCount, stereotypes, version, osInfo: { arch, name, version } } ] } } GraphQLで照会する GraphQLをクエリする最良の方法は、 curl リクエストを使用することです。 GraphQLを使用すると、必要なデータのみをフェッチできます。それ以上でもそれ以下でもありません。</description></item><item><title>Grid 3</title><link>https://www.selenium.dev/ja/documentation/legacy/selenium_3/grid_3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/legacy/selenium_3/grid_3/</guid><description>Grid 4
Selenium Grid は、SeleniumテストがコマンドをリモートWebブラウザーインスタンスにルーティングできるようにする賢いプロキシサーバーです。 その目的は、複数のマシンで並行してテストを実行する簡単な方法を提供することです。
Selenium Gridでは、1つのサーバーが、JSON形式のテストコマンドを1つ以上の登録済みのグリッドノードにルーティングするハブとして機能します。 テストはハブに接続して、リモートブラウザーインスタンスへのアクセスを取得します。 ハブには、アクセスを提供する登録済みサーバーのリストがあり、これらのインスタンスを制御できます。
Selenium Gridを使用すると、複数のマシンで並行してテストを実行し、さまざまなブラウザーバージョンとブラウザー構成を（個々のテストではなく）一元的に管理できます。
Selenium Gridは特効薬ではありません。 一般的な委譲および配布の問題のサブセットを解決しますが、たとえばインフラストラクチャを管理せず、特定のニーズに適さない場合があります。</description></item><item><title>Gridを始める</title><link>https://www.selenium.dev/ja/documentation/grid/getting_started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/grid/getting_started/</guid><description>クイックスタート 事前条件
Java 11 もしくはそれ以上がインストールされていること ブラウザーがインストールされていること ブラウザードライバー Selenium Manager will configure the drivers automatically if you add --selenium-manager true. PATH が通っているインストール済みのもの 最新の Selenium Server jar ファイルをダウンロードしていること Grid の起動
java -jar selenium-server-&amp;lt;version&amp;gt;.jar standalone あなたの WebDriver テストの対象を http://localhost:4444 に向ける
(必要があれば) ブラウザでhttp://localhost:4444を開いて実行中のテストや利用可能な capabilities を確認する。
さらにオプションを知りたい場合は以降のセクションに進んでください。
Grid コンポーネントロール Grid は 6 つの異なるコンポーネントで構成され、様々な方法でデプロイすることができます。
必要に応じて、それぞれ個別に起動する（分散）か、ハブ&amp;amp;ノードのグループに分けるか、 全てを一つのマシンで起動する（スタンドアロン）かを選べます。
スタンドアロン スタンドアロンは全ての Gridコンポーネントを 1 つに連結します。 スタンドアロンモードはシングルプロセスで動き、Grid の全機能を利用することができます。 スタンドアロンは単一のマシン上でのみ動かすことができます。
スタンドアロンは Selenium Grid を起動する最も簡単な方法でもあります。 デフォルトではサーバーはhttp://localhost:4444 で RemoteWebDriver リクエストをリッスンします。 サーバーはデフォルトでシステムパス上の利用可能なドライバーを検出します。
java -jar selenium-server-&amp;lt;version&amp;gt;.jar standalone スタンドアロンで Grid のを起動したら、WebDriver テストの対象をhttp://localhost:4444に向けてください。</description></item><item><title>HTMLランナー</title><link>https://www.selenium.dev/ja/documentation/legacy/selenium_ide/html_runner/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/legacy/selenium_ide/html_runner/</guid><description>Selenium HTMLランナー を使用すると、コマンドラインからテストスイートを実行できます。 テストスイートは、Selenium IDEまたは互換性ツールからのHTMLエクスポートです。
共通情報 geckodriver / firefox / selenium-html-runnerのリリースの組み合わせが重要です。 どこかにソフトウェア互換性マトリックスがあるかもしれません。 selenium-html-runnerはテストスイートのみを実行します（テストケースではなく、Monitis Transaction Monitorからのエクスポートなど）。 必ずこれを順守してください。 DISPLAYのないLinuxユーザーの場合-仮想ディスプレイでhtml-runnerを起動する必要があります（xvfbを検索）。 Linux環境の例 次のソフトウェアパッケージをインストール/ダウンロードします。
[user@localhost ~]$ cat /etc/redhat-release CentOS Linux release 7.4.1708 (Core) [user@localhost ~]$ rpm -qa | egrep -i &amp;#34;xvfb|java-1.8|firefox&amp;#34; xorg-x11-server-Xvfb-1.19.3-11.el7.x86_64 firefox-52.4.0-1.el7.centos.x86_64 java-1.8.0-openjdk-1.8.0.151-1.b12.el7_4.x86_64 java-1.8.0-openjdk-headless-1.8.0.151-1.b12.el7_4.x86_64 テストスイートの例
[user@localhost ~]$ cat testsuite.html &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;!DOCTYPE html PUBLIC &amp;#34;-//W3C//DTD XHTML 1.0 Strict//EN&amp;#34; &amp;#34;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&amp;#34;&amp;gt; &amp;lt;html xmlns=&amp;#34;http://www.w3.org/1999/xhtml&amp;#34; xml:lang=&amp;#34;en&amp;#34; lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta content=&amp;#34;text/html; charset=UTF-8&amp;#34; http-equiv=&amp;#34;content-type&amp;#34; /&amp;gt; &amp;lt;title&amp;gt;Test Suite&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;table id=&amp;#34;suiteTable&amp;#34; cellpadding=&amp;#34;1&amp;#34; cellspacing=&amp;#34;1&amp;#34; border=&amp;#34;1&amp;#34; class=&amp;#34;selenium&amp;#34;&amp;gt;&amp;lt;tbody&amp;gt; &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&amp;lt;b&amp;gt;Test Suite&amp;lt;/b&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&amp;lt;a href=&amp;#34;YOUR-TEST-SCENARIO.</description></item><item><title>Interacting with web elements</title><link>https://www.selenium.dev/ja/documentation/webdriver/elements/interactions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/elements/interactions/</guid><description>There are only 5 basic commands that can be executed on an element:
click (applies to any element) send keys (only applies to text fields and content editable elements) clear (only applies to text fields and content editable elements) submit (only applies to form elements) select (see Select List Elements) Additional validations These methods are designed to closely emulate a user&amp;rsquo;s experience, so, unlike the Actions API, it attempts to perform two things before attempting the specified action.</description></item><item><title>Internet Explorer Driver Internals</title><link>https://www.selenium.dev/ja/documentation/ie_driver_server/internals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/ie_driver_server/internals/</guid><description>Client Code Into the Driver We use the W3C WebDriver protocol to communicate with a local instance of an HTTP server. This greatly simplifies the implementation of the language-specific code, and minimzes the number of entry points into the C++ DLL that must be called using a native-code interop technology such as JNA, ctypes, pinvoke or DL.
Memory Management The IE driver utilizes the Active Template Library (ATL) to take advantage of its implementation of smart pointers to COM objects.</description></item><item><title>JavaScript アラート、プロンプトおよび確認</title><link>https://www.selenium.dev/ja/documentation/webdriver/interactions/alerts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/interactions/alerts/</guid><description>WebDriverは、JavaScriptが提供する3種類のネイティブポップアップメッセージを操作するためのAPIを提供します。 これらのポップアップはブラウザーによってスタイルが設定され、カスタマイズが制限されています。
アラート これらの最も単純なものはアラートと呼ばれ、カスタムメッセージと、ほとんどのブラウザーでOKのラベルが付いたアラートを非表示にする単一のボタンを表示します。 ほとんどのブラウザーでは閉じるボタンを押すことで閉じることもできますが、これは常にOKボタンと同じことを行います。 アラートの例を参照してください。
WebDriverはポップアップからテキストを取得し、これらのアラートを受け入れるか、または閉じることができます。
Java Python CSharp Ruby JavaScript Kotlin //Click the link to activate the alert driver.findElement(By.linkText(&amp;#34;See an example alert&amp;#34;)).click(); //Wait for the alert to be displayed and store it in a variable Alert alert = wait.until(ExpectedConditions.alertIsPresent()); //Store the alert text in a variable String text = alert.getText(); //Press the OK button alert.accept(); element = driver.find_element(By.LINK_TEXT, &amp;#34;See an example alert&amp;#34;) element.click() wait = WebDriverWait(driver, timeout=2) alert = wait.</description></item><item><title>Keyboard actions</title><link>https://www.selenium.dev/ja/documentation/webdriver/actions_api/keyboard/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/actions_api/keyboard/</guid><description>There are only 2 actions that can be accomplished with a keyboard: pressing down on a key, and releasing a pressed key. In addition to supporting ASCII characters, each keyboard key has a representation that can be pressed or released in designated sequences.
Keys In addition to the keys represented by regular unicode, unicode values have been assigned to other keyboard keys for use with Selenium. Each language has its own way to reference these keys; the full list can be found here.</description></item><item><title>Command Listeners</title><link>https://www.selenium.dev/ja/documentation/webdriver/support_features/listeners/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/support_features/listeners/</guid><description>These allow you to execute custom actions in every time specific Selenium commands are sent
Java Python CSharp Ruby JavaScript Kotlin Add Example
Add Example
Add Example
Add Example
Add Example
Add Example</description></item><item><title>RCからWebDriverへの移行</title><link>https://www.selenium.dev/ja/documentation/legacy/selenium_2/upgrading/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/legacy/selenium_2/upgrading/</guid><description>Selenium WebDriverに移行する方法 Selenium 2を採用する際によくある質問は、「既存のテストセットに新しいテストを追加するときに正しいことは何ですか？」ということです。 フレームワークを初めて使用するユーザーは、新しいWebDriver APIを使用してテストを作成することから始めることができます。 しかし、既存のテストスイートを既に持っているユーザーはどうでしょうか？ このガイドは、既存のテストを新しいAPIに移行し、WebDriverが提供する新機能を使用してすべての新しいテストを作成する方法を示すことを目的としています。
ここで紹介する方法は、1回の大規模なプッシュですべてをやり直す必要のない、WebDriver APIへの断片的な移行について説明しています。 これは、既存のテストの移行により多くの時間を割り当てることができることを意味します。 これにより、どこに労力を費やすかを決定しやすくなります。
このガイドは、移行を行うための最良のサポートがあるため、Javaを使用して書かれています。 他の言語用のより優れたツールを提供するため、このガイドはそれらの言語を含むように拡張されます。
WebDriverに移行する理由 一連のテストをあるAPIから別のAPIに移動するには、多大な労力が必要です。 なぜあなたとあなたのチームはこの動きを検討するのですか？ WebDriverを使用するためにSeleniumテストを移行することを検討する必要があるいくつかの理由を以下に示します。
小さくコンパクトなAPI。 WebDriverのAPIは、元のSelenium RC APIよりもオブジェクト指向です。 これにより、作業が容易になります。 ユーザー操作のより良いエミュレーション。 可能な場合、WebDriverはWebページと対話するためにネイティブイベントを使用します。 これは、ユーザーがサイトやアプリを操作する方法をより厳密に模倣しています。 さらに、WebDriverは、サイトとの複雑な相互作用をモデル化できる高度なユーザーインタラクションAPIを提供します。 ブラウザーベンダーによるサポート。 Opera、Mozilla、GoogleはすべてWebDriverの開発に積極的に参加しており、それぞれにフレームワークの改善に取り組んでいるエンジニアがいます。 多くの場合、これはWebDriverのサポートがブラウザー自体に組み込まれていることを意味します。 テストは可能な限り高速で安定して実行されます。 はじめる前に 移行プロセスを可能な限り簡単にするために、すべてのテストが最新のSeleniumリリースで正しく実行されることを確認してください。 これは当たり前のように聞こえるかもしれませんが、言ってもらうのが最善です！
はじめに 移行を開始する最初の手順は、Seleniumのインスタンスの取得方法を変更することです。 Selenium RCを使用する場合、これは次のように行われます。
Selenium selenium = new DefaultSelenium(&amp;#34;localhost&amp;#34;, 4444, &amp;#34;*firefox&amp;#34;, &amp;#34;http://www.yoursite.com&amp;#34;); selenium.start(); これは次のように置き換える必要があります。
WebDriver driver = new FirefoxDriver(); Selenium selenium = new WebDriverBackedSelenium(driver, &amp;#34;http://www.yoursite.com&amp;#34;); 次のステップ テストがエラーなしで実行されたら、次の段階は実際のテストコードを移行してWebDriver APIを使用することです。 コードがどれだけ適切に抽象化されているかによって、これは短いプロセスまたは長いプロセスになります。 どちらの場合でも、アプローチは同じであり、簡単に要約できます。 編集するときに新しいAPIを使用するようにコードを変更します。
基になるWebDriver実装をSeleniumインスタンスから抽出する必要がある場合は、WrapsDriverにキャストするだけです。
WebDriver driver = ((WrapsDriver) selenium).</description></item><item><title>Selenium RC (Selenium 1)</title><link>https://www.selenium.dev/ja/documentation/legacy/selenium_1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/legacy/selenium_1/</guid><description>紹介 Selenium RCは長い間メインのSeleniumプロジェクトでしたが、WebDriver/Seleniumを併合したより強力なツールであるSelenium 2が登場しました。 Selenium 1はもうサポートされていないことを強調する価値があります。
Selenium RCの仕組み はじめに、Selenium RCのコンポーネントがどのように動作するか、およびテストスクリプトの実行でそれぞれが果たす役割について説明します。
RCコンポーネント SeleniumRCコンポーネントは、以下のとおりです。
ブラウザを起動および終了し、テストプログラムから渡されたSeleneseコマンドを解釈および実行し、ブラウザとAUTの間で渡されるHTTPメッセージをインターセプトおよび検証するSeleniumサーバー 各プログラミング言語とSelenium RC Server間のインターフェイスを提供するクライアントライブラリ これは簡略化されたアーキテクチャ図です。
この図は、クライアントライブラリが実行される各Seleniumコマンドを渡すサーバーと通信することを示しています。 次に、サーバーはSelenium-Core JavaScriptコマンドを使用してSeleniumコマンドをブラウザーに渡します。 ブラウザは、JavaScriptインタープリターを使用して、Seleniumコマンドを実行します。 これにより、テストスクリプトで指定したSeleneseアクションまたは検証が実行されます。
Seleniumサーバー Seleniumサーバーは、テストプログラムからSeleniumコマンドを受信して解釈し、それらのテストの実行結果をプログラムに報告します。
RCサーバーはSelenium Coreをバンドルし、ブラウザーに自動的に挿入します。 これは、テストプログラムがブラウザを開いたときに発生します（クライアントライブラリのAPI関数を使用）。 Selenium-CoreはJavaScriptプログラムです。 実際には、ブラウザの組み込みJavaScriptインタープリターを使用してSeleneseコマンドを解釈および実行するJavaScript関数のセットです。
サーバーは、単純なHTTP GET/POSTリクエストを使用して、テストプログラムからSeleneseコマンドを受け取ります。 これは、HTTPリクエストを送信できるプログラミング言語を使用して、ブラウザーでのSeleniumテストを自動化できることを意味します。
クライアントライブラリ クライアントライブラリは、独自の設計のプログラムからSeleniumコマンドを実行できるプログラミングサポートを提供します。 サポートされる言語ごとに異なるクライアントライブラリがあります。 Seleniumクライアントライブラリは、プログラミングインターフェイス（API）、つまり、独自のプログラムからSeleniumコマンドを実行する一連の関数を提供します。 各インターフェイス内には、各Seleneseコマンドをサポートするプログラミング関数があります。
クライアントライブラリは、Seleneseコマンドを受け取り、それをSeleniumサーバーに渡して、特定のアクションまたはテスト対象アプリケーション（AUT）に対するテストを処理します。 クライアントライブラリは、そのコマンドの結果も受け取り、プログラムに返します。 プログラムは結果を受け取ってプログラム変数に保存し、成功または失敗として報告するか、予期しないエラーの場合は修正アクションを実行できます。
したがって、テストプログラムを作成するには、クライアントライブラリAPIを使用して一連のSeleniumコマンドを実行するプログラムを作成するだけです。 また、オプションで、Selenium-IDEでSeleneseテストスクリプトを既に作成している場合は、Selenium RCコードを生成できます。 Selenium-IDEは、（エクスポートメニュー項目を使用して）SeleniumコマンドをクライアントドライバーのAPI関数呼び出しに変換できます。 Selenium-IDEからRCコードをエクスポートする詳細については、Selenium-IDEの章を参照してください。
インストール インストールというのは、Seleniumの誤った呼び名です。 Seleniumには、選択したプログラミング言語で利用可能な一連のライブラリがあります。 ダウンロードページからダウンロードできます。
使用する言語を選択したら、次のことを行う必要があります。
Selenium RCサーバーをインストールします。 言語固有のクライアントドライバーを使用してプログラミングプロジェクトをセットアップします。 Seleniumサーバーのインストール Selenium RCサーバーは単なるJava jarファイル（selenium-server-standalone-&amp;lt;version-number&amp;gt;.jar）であり、特別なインストールは不要です。 zipファイルをダウンロードして、目的のディレクトリにサーバーを展開するだけで十分です。
Seleniumサーバーを実行する テストを開始する前に、サーバーを起動する必要があります。 Selenium RCのサーバーがあるディレクトリに移動し、コマンドラインコンソールから次を実行します。
java -jar selenium-server-standalone-&amp;lt;version-number&amp;gt;.jar これは、上記のコマンドを含むバッチまたはシェル実行可能ファイル（Windowsでは.bat、Linuxでは.sh）を作成することで簡素化できます。 次に、デスクトップ上でその実行可能ファイルへのショートカットを作成し、アイコンをダブルクリックしてサーバーを起動します。
サーバーを実行するには、Javaをインストールし、PATH環境変数をコンソールから実行するように正しく構成する必要があります。 コンソールで次を実行すると、Javaが正しくインストールされていることを確認できます。
java -version バージョン番号（1.</description></item><item><title>Seleniumのサイトとドキュメントに貢献する</title><link>https://www.selenium.dev/ja/documentation/about/contributing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/about/contributing/</guid><description>Page being translated from English to Japanese. Do you speak Japanese? Help us to translate it by sending us pull requests! Seleniumは大きなソフトウェアプロジェクトであり、そのサイトとドキュメントは、物事の仕組みを理解し、その可能性を活用する効果的な方法を学ぶための鍵となります。
このプロジェクトには、Seleniumのサイトとドキュメントの両方が含まれています。これは、Seleniumを効果的に使用する方法、Seleniumに参加する方法、およびSeleniumに貢献する方法に関する最新情報を提供するための継続的な取り組みです（特定のリリースを対象としていません）。
サイトおよびドキュメントへの貢献は、以下のセクションで説明されているプロセスに従います。
Seleniumプロジェクトは、皆様からのコントリビューションを歓迎します。 お手伝いをいただくには、いくつかの方法があります:
イシュー報告 新しい問題を報告したり、既存の問題についてコメントしたりするときは、議論がSeleniumソフトウェア、そのサイトおよび/またはドキュメントに関する具体的な技術問題に関連していることを確認してください。
Seleniumのすべてのコンポーネントは、時間の経過とともに非常に速く変化するため、ドキュメントが古くなる可能性があります。 このようなケースを見つけた場合には、遠慮なくイシューを作成してください。 また、ドキュメントを最新の状態に更新する方法をご存知でしたら、関連する変更を含むプルリクエストを送ってしてください。
見つかったものが問題であるかどうかわからない場合、https://selenium.dev/supportに記載されているコミュニケーション手段にて質問してください。
What to Help With Creating Examples Examples that need to be moved are marked with:
Add Example
We want to be able to run all of our code examples in the CI to ensure that people can copy and paste and execute everything on the site.</description></item><item><title>ブラウザーオプション</title><link>https://www.selenium.dev/ja/documentation/webdriver/drivers/options/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/drivers/options/</guid><description>Selenium 3 では、Capabilitiesは Desired Capabilities クラスを使用してセッションで定義していました。 Selenium 4 以降、ブラウザ オプション クラスを使用する必要があります。 リモート ドライバー セッションの場合、使用するブラウザーを決めるため、ブラウザーオプションインスタンスが必要です。
これらのオプションは、Capabilities の w3c仕様で説明しています。
各ブラウザには、w3c仕様で定義しているものに加えて定義可能な カスタム オプション があります。
browserName Browser name is set by default when using an Options class instance.
Java Python CSharp Ruby JavaScript Kotlin Add Example
Add Example
Add Example
options = Selenium::WebDriver::Options.chrome View full example on GitHub Add Example
Add Example
browserVersion This capability is optional, this is used to set the available browser version at remote end.</description></item><item><title>テストの種類</title><link>https://www.selenium.dev/ja/documentation/test_practices/testing_types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/test_practices/testing_types/</guid><description>受け入れテスト このタイプのテストは、機能またはシステムが顧客の期待と要件を満たしているかどうかを判断するために行われます。 このタイプのテストには通常、顧客の協力またはフィードバックが関与します。 下記質問に答えることで確認することができます。
正しい 製品を作っていますか？
Webアプリケーションの場合、ユーザーの予想される動作をシミュレートすることで、 このテストの自動化をSeleniumで直接実行できます。 このシミュレーションは、このドキュメントで説明されているように、記録/再生によって、 またはサポートされているさまざまな言語によって実行できます。 注：受け入れテストは 機能テスト のサブタイプであり、一部の人はこれにも言及する場合があります。
機能テスト このタイプのテストは、機能またはシステムが問題なく正常に機能するかどうかを判断するために行われます。 システムをさまざまなレベルでチェックして、すべてのシナリオがカバーされていること、 およびシステムが実行すべきことを実行していることを確認します。 下記質問に答えることで確認することができます。
製品を 正しく 作っていますか？
これは通常以下を含みます。 テストがエラーなし（404、例外&amp;hellip;）、使用可能な方法（正しいリダイレクト）で機能する、 利用しやすく、仕様に一致します（上記の 受け入れテスト を参照）。
Webアプリケーションの場合、期待されるリターンをシミュレートすることにより、このテストの自動化をSeleniumで直接実行できます。 このシミュレーションは、このドキュメントで説明されているように、記録/再生またはサポートされているさまざまな言語で実行できます。
パフォーマンステスト その名前が示すように、パフォーマンステストは、アプリケーションのパフォーマンスを測定するために行われます。
パフォーマンステストには2つの主なサブタイプがあります。
ロードテスト ロードテストは、定義されたさまざまな負荷（通常、特定の数のユーザーが同時に接続されている場合）でアプリケーションがどの程度機能するかを確認するために行われます。
ストレステスト ストレステストは、ストレス下（またはサポートされている最大負荷以上）でアプリケーションがどの程度機能するかを確認するために行われます。
一般に、パフォーマンステストは、Seleniumで書かれたテストを実行して、さまざまなユーザーがWebアプリの特定の機能を押して、意味のある測定値を取得することをシミュレートして実行されます。
これは通常、メトリックを取得する他のツールによって行われます。 そのようなツールの1つが JMeter です。
Webアプリケーションの場合、測定する詳細には、スループット、待ち時間、データ損失、個々のコンポーネントの読み込み時間などが含まれます…
注1：すべてのブラウザには、開発者のツールセクションにパフォーマンスタブがあります（F12キーを押すとアクセス可能）
注2：これは一般に機能/機能ごとではなくシステムごとに測定されるため、 非機能テスト のサブタイプです。
回帰テスト このテストは通常、変更、修正、または機能の追加後に行われます。
変更によって既存の機能が破壊されないようにするために、すでに実行されたいくつかのテストが再度実行されます。
再実行されるテストのセットは、完全または部分的なものにすることができ、アプリケーションおよび開発チームに応じて、いくつかの異なるタイプを含めることができます。
テスト駆動開発 (TDD) テストタイプそのものではなく、TDDはテストが機能の設計を推進する反復的な開発方法論です。
各サイクルは、機能がパスする単体テストのセットを作成することから始まります（最初に実行すると失敗します）。
この後、テストに合格するための開発が行われます。 別のサイクルを開始してテストが再度実行され、すべてのテストに合格するまでこのプロセスが続行されます。
これは、欠陥が発見されるほどコストが安くなるという事実に基づいて、アプリケーションの開発をスピードアップすることを目的としています。
ビヘイビア駆動開発 (BDD) BDDは、上記に基づいた反復開発方法論（TDD）でもあり、その目的は、アプリケーションの開発にすべての関係者を関与させることです。
各サイクルは、いくつかの仕様を作成することから始まります（これは失敗するはずです）。 次に、失敗する単体テスト（これも失敗するはずです）を作成し、開発を作成します。
このサイクルは、すべてのタイプのテストに合格するまで繰り返されます。
そのためには、仕様言語が使用されます。 すべての関係者が理解でき、単純で、標準的かつ明示的でなければなりません。 ほとんどのツールは、この言語として Gherkin を使用します。
目標は、潜在的な受入エラーも対象とすることでTDDよりも多くのエラーを検出し、当事者間のコミュニケーションを円滑にすることです。
現在、仕様を記述し、 Cucumber や SpecFlow などのコード関数と一致させるための一連のツールが利用可能です。</description></item><item><title>ファイルダウンロード</title><link>https://www.selenium.dev/ja/documentation/test_practices/discouraged/file_downloads/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/test_practices/discouraged/file_downloads/</guid><description>Seleniumの管理下にあるブラウザーでリンクをクリックしてダウンロードを開始することは可能ですが、APIはダウンロードの進行状況を公開しないため、ダウンロードしたファイルのテストには理想的ではありません。 これは、ファイルのダウンロードは、Webプラットフォームとのユーザーインタラクションをエミュレートする重要な側面とは見なされないためです。 代わりに、Selenium（および必要なCookie）を使用してリンクを見つけ、 libcurl などのHTTPリクエストライブラリに渡します。
HtmlUnitドライバーは、 AttachmentHandler インターフェイスを実装することで、 入力ストリームとして添付ファイルにアクセスすることによって、添付ファイルをダウンロードできます。 AttachmentHandlerは、HtmlUnit に追加できます。</description></item><item><title>Seleniumライブラリのインストール</title><link>https://www.selenium.dev/ja/documentation/webdriver/getting_started/install_library/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/getting_started/install_library/</guid><description>最初にあなたの自動化プロジェクトにSeleniumのバインディングをインストールする必要があります。 インストールの方法は選択した言語によって異なります。
Requirements by language Java Python CSharp Ruby JavaScript Kotlin View the minimum supported Java version here.
Installation of Selenium libraries for Java is accomplished using a build tool.
Maven Specify the dependencies in the project&amp;rsquo;s pom.xml file:
&amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.seleniumhq.selenium&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;selenium-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${selenium.version}&amp;lt;/version&amp;gt; View full example on GitHub Gradle Specify the dependency in the project build.gradle file as testImplementation:
testImplementation &amp;#39;org.seleniumhq.selenium:selenium-java:4.20.0&amp;#39; testImplementation &amp;#39;org.junit.jupiter:junit-jupiter-engine:5.10.2&amp;#39; View full example on GitHub The minimum supported Python version for each Selenium version can be found in Supported Python Versions on PyPi</description></item><item><title>Web要素の検索</title><link>https://www.selenium.dev/ja/documentation/webdriver/elements/finders/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/elements/finders/</guid><description>Seleniumを使用する最も基本的な側面の1つは、操作する要素の参照を取得することです。 Seleniumは、要素を一意に識別するための多数の組み込みロケーター戦略を提供します。 非常に高度なシナリオでロケーターを使用する方法はたくさんあります。 このドキュメントの目的のために、このHTMLスニペットについて考えてみましょう。
&amp;lt;ol id=&amp;#34;vegetables&amp;#34;&amp;gt; &amp;lt;li class=&amp;#34;potatoes&amp;#34;&amp;gt;… &amp;lt;li class=&amp;#34;onions&amp;#34;&amp;gt;… &amp;lt;li class=&amp;#34;tomatoes&amp;#34;&amp;gt;&amp;lt;span&amp;gt;Tomato is a Vegetable&amp;lt;/span&amp;gt;… &amp;lt;/ol&amp;gt; &amp;lt;ul id=&amp;#34;fruits&amp;#34;&amp;gt; &amp;lt;li class=&amp;#34;bananas&amp;#34;&amp;gt;… &amp;lt;li class=&amp;#34;apples&amp;#34;&amp;gt;… &amp;lt;li class=&amp;#34;tomatoes&amp;#34;&amp;gt;&amp;lt;span&amp;gt;Tomato is a Fruit&amp;lt;/span&amp;gt;… &amp;lt;/ul&amp;gt; 最初に一致する要素 多くのロケーターは、ページ上の複数の要素と一致します。 単数の find elementメソッドは、指定されたコンテキスト内で最初に見つかった要素への参照を返します。
DOM全体の評価 ドライバーインスタンスで要素の検索メソッドが呼び出されると、提供されたロケーターと一致するDOMの最初の要素への参照が返されます。 この値は保存して、将来の要素アクションに使用できます。 上記のHTMLの例では、クラス名が &amp;ldquo;tomatoes&amp;rdquo; の要素が2つあるため、このメソッドは &amp;ldquo;vegetables&amp;rdquo; リストの要素を返します。
Java Python CSharp Ruby JavaScript Kotlin WebElement vegetable = driver.findElement(By.className(&amp;#34;tomatoes&amp;#34;)); vegetable = driver.find_element(By.CLASS_NAME, &amp;#34;tomatoes&amp;#34;) var vegetable = driver.FindElement(By.ClassName(&amp;#34;tomatoes&amp;#34;)); vegetable = driver.find_element(class: &amp;#39;tomatoes&amp;#39;) const vegetable = await driver.findElement(By.className(&amp;#39;tomatoes&amp;#39;)); val vegetable: WebElement = driver.</description></item><item><title>Selenium 詳細</title><link>https://www.selenium.dev/ja/documentation/overview/details/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/overview/details/</guid><description>Selenium 詳細 Selenium にはさまざまな機能がありますが、その核となるのは、 ブラウザーのインスタンスをリモートで制御し、 ユーザーとブラウザーのやりとりをエミュレートするために利用できる最高の技術を使用する、 Webブラウザー自動化のためのツールセットです。
Seleniumを使用すると、ユーザーはエンド ユーザーが実行する一般的なアクティビティをシミュレートできます。 フィールドにテキストを入力し、ドロップダウン値とチェック ボックスを選択し、ドキュメント内のリンクをクリックします。 また、マウスの移動、任意の JavaScript の実行など、他の多くのコントロールも提供します。
主にWebサイトのフロントエンドのテストに使用されますが、その中核として、Seleniumは、 ユーザーがブラウザーを代理で操作する ライブラリ です。 インターフェースはアプリケーションに遍在しており、目的に合わせて他のライブラリとの構成を促進します。
すべてを支配する 1 つのインターフェース プロジェクトの指針となる原則の1つは、すべての (主要な) ブラウザー テクノロジに共通のインターフェイスをサポートすることです。 Webブラウザーは非常に複雑で、高度に設計されたアプリケーションであり、 まったく異なる方法で操作を実行しますが、実行中は同じように見えることがよくあります。 テキストは同じフォントで表示されますが、画像は同じ場所に表示され、リンク先は同じです。 水面下で起こっていることは、昼と夜と同じくらい異なります。 Selenium はこれらの違いを &amp;ldquo;抽象化&amp;rdquo; し、コードを書いている人からその詳細や複雑さを隠蔽します。 これにより、数行のコードを記述して複雑なワークフローを実行できますが、 これらの同じ行は、Firefox、Internet Explorer、Chrome、およびその他のサポートされているすべてのブラウザーで実行されます。
ツールとサポート Seleniumの必要最小限な設計アプローチは、より大きなアプリケーションのコンポーネントとして含まれる汎用性を提供します。 Seleniumの包括的なプロジェクトの下で提供される周辺インフラストラクチャは、 ブラウザーのgridをまとめるためのツールを提供し、 さまざまなブラウザーやさまざまなマシンの複数のオペレーティングシステムでテストを実行できるようにします。
サーバールームやデータセンター内の一連のコンピューターがすべて同時にブラウザーを起動して、 サイトのリンク、フォーム、テーブルにアクセスし、1日24時間アプリケーションをテストしていると想像してください。 最も一般的な言語用に提供されているシンプルなプログラミングインターフェイスを介して、 これらのテストは並行して休むことなく実行され、エラーが発生するとレポートが返されます。
ブラウザーを制御するだけでなく、そのようなgridを簡単に拡張および展開できるようにするための ツールとドキュメントをユーザーに提供することで、これを実現するお手伝いをするのが目的です。
誰がSeleniumを利用するのか 世界で最も重要な企業の多くは、ブラウザベースのテストに Seleniumを採用しており、 多くの場合、他の独自ツールを使用した長年にわたる取り組みに取って代わりました。 人気が高まるにつれて、その要件と課題も倍増しています。
ウェブがより複雑になり、新しいテクノロジーがウェブサイトに追加されるにつれて、 可能な限りそれらに遅れずについていくことがこのプロジェクトの使命です。 オープンソースプロジェクトであるため、このサポートは多くのボランティアからの惜しみない時間の寄付によって提供されます。
このプロジェクトのもう1つの使命は、より多くのボランティアがこの取り組みに参加することを奨励し、 強力なコミュニティを構築して、プロジェクトが新しいテクノロジに対応し続け、 機能テスト自動化の主要なプラットフォームであり続けることができるようにすることです。</description></item><item><title>Grid エンドポイント</title><link>https://www.selenium.dev/ja/documentation/grid/advanced_features/endpoints/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/grid/advanced_features/endpoints/</guid><description>Grid Grid ステータス Grid ステータスは Grid の現在の状態を提供します。 登録されている全てのノードの詳細で構成されます。 各ノードのステータスには、ノードの稼働状況、セッション、およびスロットに関する情報が含まれます。
cURL GET &amp;#39;http://localhost:4444/status&amp;#39; セッションの削除 セッションを削除すると、WebDriver セッションが終了し、ドライバがアクティブなセッションマップから削除されます。 削除されたセッション ID を使用するリクエストや、ドライバのインスタンスを再利用しようとすると、エラーとなります。
cURL --request DELETE &amp;#39;http://localhost:4444/session/&amp;lt;session-id&amp;gt;&amp;#39; Which URL should I use? スタンドアロンモードでは、Grid URL は スタンドアロンサーバーのアドレスになります。
ハブ&amp;amp;ノードモードでは、Grid URL は ハブのアドレスになります。
完全分散モードでは、Grid URL は ルーターのアドレスになります。
上記すべてのモードのデフォルトの URL は http://localhost:4444 です。
ディストリビューター ノード削除 ノードを Grid から削除するには、以下の cURL コマンドを使用します。 このコマンドは、そのノード上で実行中のセッションを停止させるものではありません。 ノードは明示的に強制終了されない限り、そのまま動作し続けます。 ディストリビューターはそのノードを認識しなくなるため、マッチする新しいセッションのリクエストは はその Node に転送されません。
スタンドアロンモードでは、ディストリビューターの URL はスタンドアロンサーバーのアドレスとなります。
ハブ&amp;amp;ノードモードでは、ディストリビューターの URL は ハブのアドレスになります。
cURL --request DELETE &amp;#39;http://localhost:4444/se/grid/distributor/node/&amp;lt;node-id&amp;gt;&amp;#39; --header &amp;#39;X-REGISTRATION-SECRET: &amp;lt;secret&amp;gt; &amp;#39; 完全分散モードでは、ディストリビューター URL は ディストリビューターのアドレスになります。</description></item><item><title>HTTP Client Configuration</title><link>https://www.selenium.dev/ja/documentation/webdriver/drivers/http_client/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/drivers/http_client/</guid><description>These allow you to set various parameters for the HTTP library
Java Python CSharp Ruby JavaScript Kotlin Add Example
Add Example
Add Example
client = Selenium::WebDriver::Remote::Http::Default.new(open_timeout: 30, read_timeout: 30) expect(client.open_timeout).to eq 30 View full example on GitHub Add Example
Add Example</description></item><item><title>HTTPレスポンスコード</title><link>https://www.selenium.dev/ja/documentation/test_practices/discouraged/http_response_codes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/test_practices/discouraged/http_response_codes/</guid><description>Selenium RCの一部のブラウザー構成では、Seleniumはブラウザーと自動化されているサイトの間のプロキシとして機能しました。 これは、Seleniumを通過したすべてのブラウザートラフィックをキャプチャまたは操作できることを意味していました。 captureNetworkTraffic() メソッドは、HTTPレスポンスコードを含むブラウザーと自動化されているサイト間のすべてのネットワークトラフィックをキャプチャすることを目的としています。
Selenium WebDriverは、ブラウザーの自動化に対するまったく異なるアプローチであり、ユーザーのように振る舞うことを好むため、WebDriverを使用してテストを記述する方法で表現します。 自動化された機能テストでは、ステータスコードの確認はテストの失敗の特に重要な詳細ではありません。 それに先行する手順がより重要です。
ブラウザーは常にHTTPステータスコードを表します。たとえば、404または500エラーページを想像してください。 これらのエラーページの1つに遭遇したときに&amp;quot;早く失敗&amp;quot;する簡単な方法は、ページが読み込まれるたびにページタイトルまたは信頼できるポイント（たとえば &amp;lt;h1&amp;gt; タグ）のコンテンツをチェックすることです。 ページオブジェクトモデルを使用している場合、このチェックをクラスコンストラクターまたはページの読み込みが予想される同様のポイントに含めることができます。 場合によっては、HTTPコードがブラウザーのエラーページに表示されることもあります。 WebDriverを使用してこれを読み取り、デバッグ出力を改善できます。
Webページ自体を確認することは、WebDriverの理想的なプラクティスに沿っており、WebDriverのユーザーのWebサイトの見え方を表現し、主張します。
HTTPステータスコードをキャプチャするための高度なソリューションは、プロキシを使用してSelenium RCの動作を複製することです。 WebDriver APIは、ブラウザーのプロキシを設定する機能を提供します。 Webサーバーとの間で送受信されるリクエストのコンテンツをプログラムで操作できるプロキシがいくつかあります。 プロキシを使用すると、リダイレクトレスポンスコードへの応答方法を決めることができます。 さらに、すべてのブラウザーがWebDriverでレスポンスコードを利用できるようにするわけではないため、プロキシを使用することを選択すると、すべてのブラウザーで機能するソリューションが得られます。</description></item><item><title>Selenium Manager (Beta)</title><link>https://www.selenium.dev/ja/documentation/selenium_manager/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/selenium_manager/</guid><description>Motivation TL;DR: Selenium Manager is the official driver manager of the Selenium project, and it is shipped out of the box with every Selenium release.
Selenium uses the native support implemented by each browser to carry out the automation process. For this reason, Selenium users need to place a component called driver (chromedriver, geckodriver, msedgedriver, etc.) between the script using the Selenium API and the browser. For many years, managing these drivers was a manual process for Selenium users.</description></item><item><title>Driver Service Class</title><link>https://www.selenium.dev/ja/documentation/webdriver/drivers/service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/drivers/service/</guid><description>The Service classes are for managing the starting and stopping of drivers. They can not be used with a Remote WebDriver session.
Service classes allow you to specify information about the driver, like location and which port to use. They also let you specify what arguments get passed to the command line. Most of the useful arguments are related to logging.
Default Service instance To start a driver with a default service instance:</description></item><item><title>Toml オプション</title><link>https://www.selenium.dev/ja/documentation/grid/configuration/toml_options/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/grid/configuration/toml_options/</guid><description>CLI オプション に記載されている全てのオプションは TOML ファイルでも設定ができます。 このページでは異なる Grid コンポーネントの設定例を紹介します。
オプションが変更、または追加されたが文書化されていない場合、 このドキュメントは古くなる可能性があることに注意してください。 もしそのような状況を見つけたら、&amp;ldquo;構成ヘルプ&amp;rdquo;を確認し、 ドキュメントを更新するプルリクエストを気軽に送ってください。
概要 Selenium Grid はTOMLフォーマットの設定ファイルを使用します。 設定ファイルはセクションで構成され、各セクションはオプションとその値が設定されています。
詳しい使い方はTOML ドキュメントを参照してください。 パースエラーに遭遇した場合、TOML リンターを使って検証してください。
一般的な設定の構成は以下のパターンです:
[section1] option1=&amp;#34;value&amp;#34; [section2] option2=[&amp;#34;value1&amp;#34;,&amp;#34;value2&amp;#34;] option3=true TOML ファイルで設定された Grid コンポーネントを起動するには以下のように起動できます:
java -jar selenium-server-&amp;lt;version&amp;gt;.jar &amp;lt;component&amp;gt; --config /path/to/file/&amp;lt;file-name&amp;gt;.toml スタンドアロン ポート 4449 で動作し、新規セッションリクエストのタイムアウトが 500 秒のスタンドアロンサーバー。
[server] port = 4449 [sessionqueue] session-request-timeout = 500 特定のブラウザとセッションの上限 Firefox と Chrome のみがデフォルトで有効になっているスタンドアロンサーバー、またはノード
[node] drivers = [&amp;#34;chrome&amp;#34;, &amp;#34;firefox&amp;#34;] max-sessions = 3 ドライバーのカスタマイズと設定 Firefox Beta や Nightly のような、異なるブラウザのバージョンを持つことができるカスタマイズされた ドライバを用いた、スタンドアロン、またはノード。</description></item><item><title>ページオブジェクトモデル</title><link>https://www.selenium.dev/ja/documentation/test_practices/encouraged/page_object_models/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/test_practices/encouraged/page_object_models/</guid><description>Note: this page has merged contents from multiple sources, including the Selenium wiki
Overview Within your web app&amp;rsquo;s UI, there are areas where your tests interact with. A Page Object only models these as objects within the test code. This reduces the amount of duplicated code and means that if the UI changes, the fix needs only to be applied in one place.
Page Object is a Design Pattern that has become popular in test automation for enhancing test maintenance and reducing code duplication.</description></item><item><title>色を扱う</title><link>https://www.selenium.dev/ja/documentation/webdriver/support_features/colors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/support_features/colors/</guid><description>テストの一部として何かの色を検証したい場合があります。 問題は、ウェブ上の色の定義が一定ではないことです。 色のHEX表現を色のRGB表現と比較する簡単な方法、または色のRGBA表現を色のHSLA表現と比較する簡単な方法があったらいいのではないでしょうか？
心配しないでください。解決策があります。: Color クラスです！
まず、クラスをインポートする必要があります。
Java Python CSharp Ruby JavaScript Kotlin import org.openqa.selenium.support.Color; from selenium.webdriver.support.color import Color // This feature is not implemented - Help us by sending a pr to implement this feature include Selenium::WebDriver::Support // This feature is not implemented - Help us by sending a pr to implement this feature import org.openqa.selenium.support.Color これで、カラーオブジェクトの作成を開始できます。 すべての色オブジェクトは、色の文字列表現から作成する必要があります。 サポートされている色表現は、以下のとおりです。
Java Python CSharp Ruby JavaScript Kotlin private final Color HEX_COLOUR = Color.</description></item><item><title>Chrome DevTools Protocol API</title><link>https://www.selenium.dev/ja/documentation/webdriver/bidirectional/chrome_devtools/cdp_api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/bidirectional/chrome_devtools/cdp_api/</guid><description>While Selenium 4 provides direct access to the Chrome DevTools Protocol (CDP), these methods will eventually be removed. It is recommended to use the WebDriver Bidi APIs methods where possible to ensure future compatibility.
Usage If your use case has been implemented by WebDriver Bidi or the BiDi API, you should use those implementations instead of this one. Generally you should prefer this approach over executing with the CDP Endpoint, especially in Ruby.</description></item><item><title>Chrome固有の機能</title><link>https://www.selenium.dev/ja/documentation/webdriver/browsers/chrome/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/browsers/chrome/</guid><description>デフォルトでは、Selenium 4 は Chrome v75 以降と互換性があります。 Chromeブラウザのバージョンと chromedriverのバージョンは、メジャーバージョンと一致する必要があることに注意してください。
Options 全てのブラウザに共通のCapabilityについては、オプション ページで説明しています。
Chrome に固有のCapabilityは、Google のCapabilities &amp;amp; ChromeOptionsページにあります。
基本的な定義済みオプションを使用してChromeセッションを開始すると、次のようになります。
Java Python CSharp Ruby JavaScript Kotlin ChromeOptions options = new ChromeOptions(); driver = new ChromeDriver(options); View full example on GitHub options = webdriver.ChromeOptions() driver = webdriver.Chrome(options=options) View full example on GitHub var options = new ChromeOptions(); driver = new ChromeDriver(options); View full example on GitHub options = Selenium::WebDriver::Options.chrome @driver = Selenium::WebDriver.for :chrome, options: options View full example on GitHub const Options = new Chrome.</description></item><item><title>Customizing a Node</title><link>https://www.selenium.dev/ja/documentation/grid/advanced_features/customize_node/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/grid/advanced_features/customize_node/</guid><description>Page being translated from English to Japanese. Do you speak Japanese? Help us to translate it by sending us pull requests! How to customize a Node There are times when we would like a Node to be customized to our needs.
For e.g., we may like to do some additional setup before a session begins execution and some clean-up after a session runs to completion.
Following steps can be followed for this:</description></item><item><title>Unable to Locate Driver Error</title><link>https://www.selenium.dev/ja/documentation/webdriver/troubleshooting/errors/driver_location/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/troubleshooting/errors/driver_location/</guid><description>Historically, this is the most common error beginning Selenium users get when trying to run code for the first time:
Java Python CSharp Ruby The path to the driver executable must be set by the webdriver.chrome.driver system property; for more information, see https://chromedriver.chromium.org/. The latest version can be downloaded from https://chromedriver.chromium.org/downloads The executable chromedriver needs to be available in the path. The file geckodriver does not exist. The driver can be downloaded at https://github.</description></item><item><title>Gmail、Eメール、Facebookログイン</title><link>https://www.selenium.dev/ja/documentation/test_practices/discouraged/gmail_email_and_facebook_logins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/test_practices/discouraged/gmail_email_and_facebook_logins/</guid><description>複数の理由から、WebDriverを使用してGmailやFacebookなどのサイトにログインすることはお勧めしません。 これらのサイトの使用条件（アカウントがシャットダウンされるリスクがある）に違反することは別として、それは遅く、信頼性がありません。
理想的なプラクティスは、メールプロバイダーが提供するAPIを使用すること、またはFacebookの場合、テストアカウントや友人などを作成するためのAPIを公開する開発者ツールサービスを使用することです。 APIの使用は少し大変な作業のように思えるかもしれませんが、速度、信頼性、および安定性に見返りがあります。 また、APIが変更されることはほとんどありませんが、WebページとHTMLロケーターは頻繁に変更され、テストフレームワークを更新する必要があります。
テストの任意の時点でWebDriverを使用してサードパーティのサイトにログインすると、テストが長くなるため、テストが失敗するリスクが高くなります。 一般的な経験則として、テストが長くなるほど脆弱で信頼性が低くなります。
W3C準拠 のWebDriver実装は、サービス拒否攻撃を軽減できるように、navigatorオブジェクトにWebDriverプロパティで注釈を付けます。</description></item><item><title>Logging Selenium commands</title><link>https://www.selenium.dev/ja/documentation/webdriver/troubleshooting/logging/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/troubleshooting/logging/</guid><description>Turning on logging is a valuable way to get extra information that might help you determine why you might be having a problem.
Getting a logger Java Python CSharp Ruby JavaScript Kotlin Java logs are typically created per class. You can work with the default logger to work with all loggers. To filter out specific classes, see Filtering
Get the root logger:
Logger logger = Logger.getLogger(&amp;#34;&amp;#34;); View full example on GitHub Java Logging is not exactly straightforward, and if you are just looking for an easy way to look at the important Selenium logs, take a look at the Selenium Logger project</description></item><item><title>Mouse actions</title><link>https://www.selenium.dev/ja/documentation/webdriver/actions_api/mouse/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/actions_api/mouse/</guid><description>There are only 3 actions that can be accomplished with a mouse: pressing down on a button, releasing a pressed button, and moving the mouse. Selenium provides convenience methods that combine these actions in the most common ways.
Click and hold This method combines moving the mouse to the center of an element with pressing the left mouse button. This is useful for focusing a specific element:
Java Python CSharp Ruby JavaScript Kotlin WebElement clickable = driver.</description></item><item><title>いつGridを使用すべきか</title><link>https://www.selenium.dev/ja/documentation/grid/applicability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/grid/applicability/</guid><description>Grid をいつ使うべきでしょうか？
複数のブラウザー、異なるタイプまたは異なるバージョンのブラウザー、あるいは異なる OS 上でで実行されているブラウザーに対して並列でテストを実行したい場合 テストスイートの実行時間を減らしたい場合 Selenium Grid はノードと呼ばれる複数のマシンを使用して並列でテストスイートを実行します。 大規模な長時間実行されるテストでは数分から数時間、あるいは数日単位での短縮が可能です。 つまり、あなたのテスト対象のアプリケーションのテスト結果を得るまでの時間を短縮します。
Grid は複数の異なるブラウザーに対してテストを実行でき、また同じブラウザーインスタンスに対して複数のテストを実行することも可能です。 たとえば 6 つのノードで構成された Grid があるとします。 最初のマシンは FireFox の最新バージョン、2 つめは FireFox の最新から一つ前のバージョン、 3 つめは 最新の Chrome、そして残りは Mac Mini で最新の Safari を使って 3 つのテストを並行して実行することができます。
実行時間は簡単な式で表すことができます:
テストの数 * 平均テスト時間 / ノード数 = 合計実行時間
15 * 45s / 1 = 11m 15s // Grid なし 15 * 45s / 5 = 2m 15s // 5 ノードの Grid 15 * 45s / 15 = 45s // 15 ノードの Grid 100 * 120s / 15 = 13m 20s // Grid なしの場合3時間以上かかります テストスイートが実行されると Grid はテストで設定されたブラウザに対して実行するテストを割り当てます。</description></item><item><title>クッキーの使用</title><link>https://www.selenium.dev/ja/documentation/webdriver/interactions/cookies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/interactions/cookies/</guid><description>Cookieは、Webサイトから送信され、コンピューターに保存される小さなデータです。 Cookieは、主にユーザーを認識し、保存されている情報を読み込むために使用されます。
WebDriver APIは、組み込みメソッドでCookieと対話するメソッドを提供します。
クッキーの追加 現在のブラウジングコンテキストにCookieを追加するために使用されます。 Cookieの追加では、一連の定義済みのシリアル化可能なJSONオブジェクトのみを受け入れます。 受け入れられたJSONキー値のリストへのリンクはこちらにあります。
まず、Cookieが有効になるドメインにいる必要があります。 サイトとの対話を開始する前にCookieを事前設定しようとしていて、ホームページが大きい場合/代替の読み込みに時間がかかる場合は、サイトで小さいページを見つけることです。（通常、たとえば http://example.com/some404page のような、404ページは小さいです。）
Java Python CSharp Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class addCookie { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(&amp;#34;http://www.example.com&amp;#34;); // Adds the cookie into current browser context driver.manage().addCookie(new Cookie(&amp;#34;key&amp;#34;, &amp;#34;value&amp;#34;)); } finally { driver.quit(); } } } from selenium import webdriver driver = webdriver.Chrome() driver.get(&amp;#34;http://www.example.com&amp;#34;) # Adds the cookie into current browser context driver.</description></item><item><title>ドメイン固有言語（DSL）</title><link>https://www.selenium.dev/ja/documentation/test_practices/encouraged/domain_specific_language/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/test_practices/encouraged/domain_specific_language/</guid><description>ドメイン固有言語（DSL）は、問題を解決するための表現手段をユーザーに提供するシステムです。 それによって、ユーザーは、プログラマーの言葉でなく、自分の言葉でシステムとやりとりすることができます。
通常、ユーザーはサイトの外観を気にしません。 装飾、アニメーション、グラフィックスは気にしません。 彼らはあなたのシステムを使用して、新しい従業員を最小限の難しさでプロセスに押し込みたいと考えています。 彼らはアラスカへの旅行を予約したい。 ユニコーンを設定して割引価格で購入したいのです。 テスターとしてのあなたの仕事は、この考え方を&amp;quot;とらえる&amp;quot;ことにできるだけ近づくことです。 それを念頭に置いて、テストスクリプト（ユーザーの唯一のプレリリースの代理人）がユーザーを&amp;quot;代弁し&amp;quot;、表現するように、作業中のアプリケーションの&amp;quot;モデリング&amp;quot;に取り掛かります。
Seleniumでは、DSLは通常、APIをシンプルで読みやすいように記述したメソッドで表されます。 開発者と利害関係者（ユーザー、製品所有者、ビジネスインテリジェンススペシャリストなど）との伝達が可能になります。
利点 Readable: ビジネス関係者はそれを理解できます。 Writable: 書きやすく、不要な重複を避けます。 Extensible: 機能は（合理的に）契約と既存の機能を壊すことなく追加できます。 Maintainable: 実装の詳細をテストケースから除外することにより、AUT* の変更に対して十分に隔離されます。 Java Javaの妥当なDSLメソッドの例を次に示します。 簡潔にするために、driverオブジェクトが事前に定義されており、メソッドで使用可能であることを前提としています。
/** * Takes a username and password, fills out the fields, and clicks &amp;#34;login&amp;#34;. * @return An instance of the AccountPage */ public AccountPage loginAsUser(String username, String password) { WebElement loginField = driver.findElement(By.id(&amp;#34;loginField&amp;#34;)); loginField.clear(); loginField.sendKeys(username); // Fill out the password field. The locator we&amp;#39;re using is &amp;#34;By.</description></item><item><title>Web要素に関する情報</title><link>https://www.selenium.dev/ja/documentation/webdriver/elements/information/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/elements/information/</guid><description>特定の要素についてクエリできる詳細情報がいくつかあります。
表示されているかどうか This method is used to check if the connected Element is displayed on a webpage. Returns a Boolean value, True if the connected element is displayed in the current browsing context else returns false.
This functionality is mentioned in, but not defined by the w3c specification due to the impossibility of covering all potential conditions. As such, Selenium cannot expect drivers to implement this functionality directly, and now relies on executing a large JavaScript function directly.</description></item><item><title>独自のグリッドを設定する</title><link>https://www.selenium.dev/ja/documentation/legacy/selenium_3/grid_setup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/legacy/selenium_3/grid_setup/</guid><description>Selenium Gridを使用するには、ノード用の独自のインフラストラクチャを維持する必要があります。 これは面倒で時間のかかる作業になる可能性があるため、多くの組織はこのインフラストラクチャを提供するためにAmazon EC2やGoogle ComputeなどのIaaSプロバイダーを使用しています。
他の選択肢として、クラウドのサービスとしてSelenium Gridを提供するSauce LabsやTesting Botなどのプロバイダーの使うこともできます。 独自のハードウェアでノードを実行することも確かに可能です。 この章では、独自のノードインフラストラクチャを備えた独自のグリッドを実行するオプションについて詳しく説明します。
クイックスタート この例では、Selenium 2グリッドハブを起動し、WebDriverノードとSelenium 1 RCレガシーノードの両方を登録する方法を示します。 また、Javaからグリッドを呼び出す方法も示します。 ここでは、ハブとノードが同じマシンで実行されていますが、もちろん、selenium-server-standaloneを複数のマシンにコピーできます。
selenium-server-standaloneパッケージには、グリッドの実行に必要なハブ、WebDriver、およびレガシーRCが含まれています。 ant はもう必要ありません。 selenium-server-standalone.jarは https://selenium.dev/downloads/ からダウンロードできます。
ステップ1：ハブを開始する ハブは、テストリクエストを受信し、それらを適切なノードに配布する中心点です。 配布は機能ベースで行われます。 つまり、一連の機能を必要とするテストは、その機能セットまたは機能のサブセットを提供するノードにのみ配布されます。
テストのDesiredCapabilitiesは、 任意の を意味するため、ハブはDesiredCapabilitiesの設定に完全に一致するノードを見つけることを保証できません。
コマンドプロンプトを開き、selenium-server-standalone.jarファイルをコピーしたディレクトリに移動します。 ハブを起動するには、-role hubフラグをスタンドアロンサーバーに渡します。
java -jar selenium-server-standalone.jar -role hub ハブはデフォルトでポート4444をリッスンします。 ブラウザーウィンドウを開いて http://localhost:4444/grid/console に移動すると、ハブのステータスを表示できます。
デフォルトのポートを変更するには、コマンドを実行するときにリッスンするポートを表す整数を持つオプションの -port フラグを追加できます。 また、JSON構成ファイル（以下を参照）に表示される他のすべてのオプションは、可能なコマンドラインフラグです。
確かに上記の簡単なコマンドだけでうまくいくことができますが、より高度な構成が必要な場合は、JSON形式の構成ファイルを指定して、開始時にハブを構成することもできます。 JSON形式の構成ファイルを指定して開始時にハブを構成する方法は以下のとおりです。
java -jar selenium-server-standalone.jar -role hub -hubConfig hubConfig.json -debug 以下に、 hubConfig.json ファイルの例を示します。 ステップ2でノード構成ファイルを提供する方法について詳しく説明します。
{ &amp;#34;_comment&amp;#34; : &amp;#34;Configuration for Hub - hubConfig.json&amp;#34;, &amp;#34;host&amp;#34;: ip, &amp;#34;maxSession&amp;#34;: 5, &amp;#34;port&amp;#34;: 4444, &amp;#34;cleanupCycle&amp;#34;: 5000, &amp;#34;timeout&amp;#34;: 300000, &amp;#34;newSessionWaitTimeout&amp;#34;: -1, &amp;#34;servlets&amp;#34;: [], &amp;#34;prioritizer&amp;#34;: null, &amp;#34;capabilityMatcher&amp;#34;: &amp;#34;org.</description></item><item><title>Edge固有の機能</title><link>https://www.selenium.dev/ja/documentation/webdriver/browsers/edge/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/browsers/edge/</guid><description>Microsoft EdgeはChromiumで実装されており、サポートされている最も古いバージョンはv79です。 Chromeと同様に、edgedriverのメジャー バージョン番号は、Edgeブラウザのメジャーバージョンと一致する必要があります。
Chromeページ にあるすべての機能とオプションは、Edgeでも機能します。
オプション Capabilities common to all browsers are described on the Options page.
Capabilities unique to Chromium are documented at Google&amp;rsquo;s page for Capabilities &amp;amp; ChromeOptions
基本的な定義済みオプションを使用して Edgeセッションを開始すると、次のようになります。
Java Python CSharp Ruby JavaScript Kotlin EdgeOptions options = new EdgeOptions(); driver = new EdgeDriver(options); View full example on GitHub options = webdriver.EdgeOptions() driver = webdriver.Edge(options=options) View full example on GitHub var options = new EdgeOptions(); driver = new EdgeDriver(options); View full example on GitHub options = Selenium::WebDriver::Options.</description></item><item><title>External datastore</title><link>https://www.selenium.dev/ja/documentation/grid/advanced_features/external_datastore/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/grid/advanced_features/external_datastore/</guid><description>Page being translated from English to Japanese. Do you speak Japanese? Help us to translate it by sending us pull requests! Table of Contents Introduction Setup Database backed Session Map Steps Redis backed Session Map Steps Introduction Selenium Grid allows you to persist information related to currently running sessions into an external data store. The external data store could be backed by your favourite database (or) Redis Cache system.</description></item><item><title>Pen actions</title><link>https://www.selenium.dev/ja/documentation/webdriver/actions_api/pen/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/actions_api/pen/</guid><description>Chromium Only
A Pen is a type of pointer input that has most of the same behavior as a mouse, but can also have event properties unique to a stylus. Additionally, while a mouse has 5 buttons, a pen has 3 equivalent button states:
0 — Touch Contact (the default; equivalent to a left click) 2 — Barrel Button (equivalent to a right click) 5 — Eraser Button (currently unsupported by drivers) Using a Pen Java Python CSharp Ruby JavaScript Kotlin Selenium v4.</description></item><item><title>アプリケーション状態の生成</title><link>https://www.selenium.dev/ja/documentation/test_practices/encouraged/generating_application_state/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/test_practices/encouraged/generating_application_state/</guid><description>Seleniumはテストケースの準備に使用しないでください。 テストケースのすべての反復アクションと準備は、他の方法で行う必要があります。 たとえば、ほとんどのWeb UIには認証があります（ログインフォームなど）。 すべてのテストの前にWebブラウザーからのログインをなくすことで、テストの速度と安定性の両方が向上します。 AUT* にアクセスするためのメソッドを作成する必要があります（APIを使用してログインし、Cookieを設定するなど）。 また、テスト用にデータをプリロードするメソッドの作成は、Seleniumを使用して実行しないほうがいいです。 前述のように、AUT* のデータを作成するには、既存のAPIを活用する必要があります。
*AUT: Application under test（テスト対象アプリケーション）</description></item><item><title>テストの依存関係</title><link>https://www.selenium.dev/ja/documentation/test_practices/discouraged/test_dependency/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/test_practices/discouraged/test_dependency/</guid><description>自動テストに関する一般的な考え方と誤解は、特定のテスト順序に関するものです。 テストは 任意 の順序で実行でき、成功するために完了するために他のテストに依存してはなりません。</description></item><item><title>選択要素の操作</title><link>https://www.selenium.dev/ja/documentation/webdriver/support_features/select_lists/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/support_features/select_lists/</guid><description>The Select object will now give you a series of commands that allow you to interact with a &amp;lt;select&amp;gt; element.
If you are using Java or .NET make sure that you&amp;rsquo;ve properly required the support package in your code. See the full code from GitHub in any of the examples below.
Note that this class only works for HTML elements select and option. It is possible to design drop-downs with JavaScript overlays using div or li, and this class will not work for those.</description></item><item><title>Chrome Devtools Protocol with BiDi API</title><link>https://www.selenium.dev/ja/documentation/webdriver/bidirectional/chrome_devtools/bidi_api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/bidirectional/chrome_devtools/bidi_api/</guid><description>Usage The following list of APIs will be growing as the Selenium project works through supporting real world use cases. If there is additional functionality you&amp;rsquo;d like to see, please raise a feature request.
As these examples are re-implemented with the WebDriver-Bidi protocol, they will be moved to the WebDriver Bidi pages.
Examples Basic authentication Some applications make use of browser authentication to secure pages. It used to be common to handle them in the URL, but browser stopped supporting this.</description></item><item><title>Firefox 固有のCapability</title><link>https://www.selenium.dev/ja/documentation/webdriver/browsers/firefox/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/browsers/firefox/</guid><description>Selenium 4 には Firefox 78 以降が必要です。 常に最新バージョンの geckodriver を使用することをお勧めします。
オプション 全ブラウザに共通のCapabilityについては、オプションページで説明しています。
Firefox に固有のCapabilityは、Mozilla のページの firefoxOptions にあります。
基本的な定義済みのオプションを使用して Firefox セッションを開始すると、以下のようになります。
Java Python CSharp Ruby JavaScript Kotlin FirefoxOptions options = new FirefoxOptions(); driver = new FirefoxDriver(options); View full example on GitHub options = webdriver.FirefoxOptions() driver = webdriver.Firefox(options=options) View full example on GitHub var options = new FirefoxOptions(); driver = new FirefoxDriver(options); View full example on GitHub options = Selenium::WebDriver::Options.firefox @driver = Selenium::WebDriver.for :firefox, options: options View full example on GitHub let options = new firefox.</description></item><item><title>Style guide for Selenium documentation</title><link>https://www.selenium.dev/ja/documentation/about/style/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/about/style/</guid><description>Read our contributing documentation for complete instructions on how to add content to this documentation.
Alerts Alerts have been added to direct potential contributors to where specific content is missing.
{{&amp;lt; alert-content /&amp;gt;}} or
{{&amp;lt; alert-content &amp;gt;}} Additional information about what specific content is needed {{&amp;lt; /alert-content &amp;gt;}} Which gets displayed like this: Content Help Note: This section needs additional and/or updated content Additional information about what specific content is needed Check our contribution guidelines if you&amp;rsquo;d like to help.</description></item><item><title>ThreadGuard</title><link>https://www.selenium.dev/ja/documentation/webdriver/support_features/thread_guard/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/support_features/thread_guard/</guid><description>このクラスは、Javaバインディングでのみ使用可能です。 ThreadGuardは、ドライバーが、それを作成した同じスレッドからのみ呼び出されることを確認します。 特に並行してテストを実行する場合のスレッドの問題は、不可解でエラーの診断が難しい場合があります。 このラッパーを使用すると、このカテゴリのエラーが防止され、発生時に例外が発生します。
次の例は、スレッドの衝突をシミュレートします。
public class DriverClash { //thread main (id 1) created this driver private WebDriver protectedDriver = ThreadGuard.protect(new ChromeDriver()); static { System.setProperty(&amp;#34;webdriver.chrome.driver&amp;#34;, &amp;#34;&amp;lt;Set path to your Chromedriver&amp;gt;&amp;#34;); } //Thread-1 (id 24) is calling the same driver causing the clash to happen Runnable r1 = () -&amp;gt; {protectedDriver.get(&amp;#34;https://selenium.dev&amp;#34;);}; Thread thr1 = new Thread(r1); void runThreads(){ thr1.start(); } public static void main(String[] args) { new DriverClash().runThreads(); } } 結果は以下のとおりです。</description></item><item><title>Scroll wheel actions</title><link>https://www.selenium.dev/ja/documentation/webdriver/actions_api/wheel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/actions_api/wheel/</guid><description>Selenium v4.2
Chromium Only
There are 5 scenarios for scrolling on a page.
Scroll to element This is the most common scenario. Unlike traditional click and send keys methods, the actions class does not automatically scroll the target element into view, so this method will need to be used if elements are not already inside the viewport.
This method takes a web element as the sole argument.
Regardless of whether the element is above or below the current viewscreen, the viewport will be scrolled so the bottom of the element is at the bottom of the screen.</description></item><item><title>グリッドのコンポーネント</title><link>https://www.selenium.dev/ja/documentation/legacy/selenium_3/grid_components/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/legacy/selenium_3/grid_components/</guid><description>ハブ 仲介者およびマネージャー テストを実行する要求を受け入れます クライアントから命令を受け取り、ノード上でリモートで実行します スレッドを管理します ハブ は、すべてのテストが送信される中心点です。 各Selenium Gridは、ちょうど1つのハブで構成されます。 ハブは、それぞれのクライアント（CIサーバー、開発者マシンなど）から到達可能である必要があります。 ハブは、テストが委任される1つ以上のノードを接続します。
ノード ブラウザが存在する場所 ハブに自分自身を登録し、その機能を伝えます ハブからリクエストを受信して実行します ノード は、個々のコンピューターシステムでテストを実行するさまざまなSeleniumインスタンスです。 グリッドには多くのノードが存在する場合があります。 ノードであるマシンは、ハブまたは他のノードと同じプラットフォームであったり、同じブラウザーを選定する必要はありません。 Windows上のノードは、Internet Explorerをブラウザーオプションとして提供する機能を備えている場合がありますが、これはLinuxまたはMacでは不可能です。</description></item><item><title>Serenium Grid のコンポーネント</title><link>https://www.selenium.dev/ja/documentation/grid/components/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/grid/components/</guid><description>Selenium Grid 4 は以前のバージョンから一新し、全面的に作り直されました。 全体的なパフォーマンスの改善と標準の準拠に加え、より現代的なコンピューティングとソフトウェア開発 に適応するために機能ごとに分割されました。 コンテナ化とクラウド上での分散スケーラビリティのために構築された、現代に適した全く新しいソリューションです。
ルーター これは Grid のエントリポイントであり、すべての外部リクエストを受信し正しいコンポーネントへルーティングします。
ルーターが新規セッションリクエストを受信すると、新規セッションキューに転送します。
リクエストが既存のセッションのものである場合、ルーターはセッションマップに、 セッションが実行されている ノード ID の取得を要求します。そしてノードにリクエストを直接転送します。
ルーターは、リクエストをより処理能力の高いコンポーネントに負荷を分散させます。 この負荷分散処理自体もコンポーネントに不必要に負荷をかけることはありません。
ディストリビューター ディストリビューターの主な責務は 2 つあります:
すべてのノードとその capabilities を登録し追跡します イベントバスを通じてノード登録イベントを贈ることでノードをディストリビューターに登録します。 ディストリビューターはそのイベントを受けてノードの存在を HTTP リクエストで確認します。 リクエストが成功した場合、ディストリビューターはノードを登録し、Grid モデルを通じて追跡を開始します。
保留中の新規セッションリクエストを処理する 新規セッションリクエストがルーターに送信されると、リクエストは新規セッションキューに転送されます。 ディストリビューターは新規セッションキューをポーリングし、保留中の新規セッションリクエストを見つけると、 セッションが作成可能なノードを探します。 セッションが作成されるとディストリビューターは セッション ID とセッションが実行されるノードの紐付けをセッションマップに保存します。
セッションマップ セッションマップはセッション ID とセッションが実行されているノードの紐付けを保存します。 これによりルーターがリクエストをノードに転送できるようにします。 ルーターはセッションマップにセッション ID に紐づくノードを問い合わせます。
新規セッションキュー 新規セッションキューはすべての新規セッションリクエストを FIFO 順で保持します。 リクエストのタイムアウトとリトライ間隔の設定が可能です。
ルーターは新規セッションリクエストを新規セッションキューに追加し、レスポンスを待ちます。 新規セッションキューは定期的にキュー内のリクエストがタイムアウトしていないかをチェックし、 タイムアウトしたリクエストがあればリクエストを拒否しキューから取り除きます。
ディストリビューターはスロットに空きがあるかを定期的にチェックします。 もし空きがあれば、新規セッションキューから最初にマッチするリクエストを取り出し、 新規セッションの作成を試みます。
リクエストされた capabilities にマッチする空きノードスロットがあれば、 ディストリビューターは空きスロットの確保を試みます。全てのスロットがビジーだった場合、 ディストリビューターはリクエストをキューに戻します。 リトライ中やキューに戻す最中にリクエストがタイムアウトした場合リクエストは拒否されます。
セッションの作成に成功すると、ディストリビューターはセッションの情報を新規セッションキューに送信し、 これがルーターへのレスポンスとして送信され、最終的にクライアントに返ります。
ノード Grid は複数のノードを持つことができます。 ノードは、各ノードが実行されているマシン上の利用可能なブラウザのスロットを管理します。</description></item><item><title>パフォーマンステスト</title><link>https://www.selenium.dev/ja/documentation/test_practices/discouraged/performance_testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/test_practices/discouraged/performance_testing/</guid><description>通常、SeleniumとWebDriverを使用したパフォーマンステストはお勧めしません。 それができないからではなく、ジョブに最適化されておらず、良い結果が得られないからです。
ユーザーのコンテキストでパフォーマンステストを行うのが理想的なように思えるかもしれませんが、WebDriverテストスイートは、外部および内部の脆弱性の多くのポイントにさらされます。 たとえば、ブラウザの起動速度、HTTPサーバーの速度、JavaScriptまたはCSSをホストするサードパーティサーバーの応答、およびWebDriver実装自体の計測ペナルティ。 これらのポイントが変わることで、結果が変わります。 Webサイトのパフォーマンスと外部リソースのパフォーマンスの違いを区別することは困難です。また、ブラウザでWebDriverを使用すること、特にスクリプトを挿入する場合のパフォーマンスの低下を把握することも困難です。
他の潜在的な魅力は &amp;ldquo;時間の節約&amp;rdquo; です。 機能テストとパフォーマンステストを同時に実行します。 ただし、機能テストとパフォーマンステストには反対の目的があります。 機能をテストするために、テスターは忍耐強くロードを待つ必要があるかもしれませんが、これはパフォーマンステスト結果を曖昧にし、その逆もまた同様です。
Webサイトのパフォーマンスを改善するには、改善すべき点を知るために、環境の違いに関係なく全体的なパフォーマンスを分析し、貧弱なコードプラクティス、個々のリソース（例えば、CSSまたはJavaScript）のパフォーマンスの内訳を特定できる必要があります。 このジョブを実行できるパフォーマンステストツールが既にあり、それらは改善を提案できるレポートと分析を提供します。
使用する（オープンソース）パッケージの例は次のとおりです。: JMeter</description></item><item><title>IFrame と Frame の操作</title><link>https://www.selenium.dev/ja/documentation/webdriver/interactions/frames/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/interactions/frames/</guid><description>Frameは、同じドメイン上の複数のドキュメントからサイトレイアウトを構築する非推奨の手段となりました。 HTML5以前のWebアプリを使用している場合を除き、frameを使用することはほとんどありません。 iFrameは、まったく異なるドメインからのドキュメントの挿入を許可し、今でも一般的に使用されています。
FrameまたはiFrameを使用する必要がある場合、Webdriverを使用して同じ方法で作業できます。 iFrame内のボタンがある場合を考えてみましょう。ブラウザー開発ツールを使用して要素を検査すると、次のように表示される場合があります。
&amp;lt;div id=&amp;#34;modal&amp;#34;&amp;gt; &amp;lt;iframe id=&amp;#34;buttonframe&amp;#34; name=&amp;#34;myframe&amp;#34; src=&amp;#34;https://seleniumhq.github.io&amp;#34;&amp;gt; &amp;lt;button&amp;gt;Click here&amp;lt;/button&amp;gt; &amp;lt;/iframe&amp;gt; &amp;lt;/div&amp;gt; iFrameがなければ、次のようなボタンを使用してボタンをクリックします。
Java Python CSharp Ruby JavaScript Kotlin //This won&amp;#39;t work driver.findElement(By.tagName(&amp;#34;button&amp;#34;)).click(); # This Wont work driver.find_element(By.TAG_NAME, &amp;#39;button&amp;#39;).click() //This won&amp;#39;t work driver.FindElement(By.TagName(&amp;#34;button&amp;#34;)).Click(); # This won&amp;#39;t work driver.find_element(:tag_name,&amp;#39;button&amp;#39;).click // This won&amp;#39;t work await driver.findElement(By.css(&amp;#39;button&amp;#39;)).click(); //This won&amp;#39;t work driver.findElement(By.tagName(&amp;#34;button&amp;#34;)).click() ただし、iFrameの外側にボタンがない場合は、代わりにno such elementエラーが発生する可能性があります。 これは、Seleniumがトップレベルのドキュメントの要素のみを認識するために発生します。 ボタンを操作するには、ウィンドウを切り替える方法と同様に、最初にFrameに切り替える必要があります。 WebDriverは、Frameに切り替える3つの方法を提供します。
WebElementを使う WebElementを使用した切り替えは、最も柔軟なオプションです。好みのセレクタを使用してFrameを見つけ、それに切り替えることができます。
Java Python CSharp Ruby JavaScript Kotlin //Store the web element WebElement iframe = driver.</description></item><item><title>モック外部サービス</title><link>https://www.selenium.dev/ja/documentation/test_practices/encouraged/mock_external_services/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/test_practices/encouraged/mock_external_services/</guid><description>外部サービスへの依存を排除すると、テストの速度と安定性が大幅に向上します。</description></item><item><title>リモートWebDriverサーバー</title><link>https://www.selenium.dev/ja/documentation/legacy/selenium_2/remote_server/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/legacy/selenium_2/remote_server/</guid><description>サーバーは、テストするブラウザーがインストールされたマシンで常に実行されます。 サーバーは、コマンドラインから、またはコード設定を通じて使用できます。
コマンドラインからサーバーを起動する 一旦、selenium-server-standalone-{VERSION}.jarをダウンロードしたら、テストしたいブラウザーのあるコンピューターに配置します。 次に、jarを含むディレクトリから、次のコマンドを実行します。
java -jar selenium-server-standalone-{VERSION}.jar サーバーを実行するにあたって考慮すること 呼び出し元は、Selenium#stop()またはWebDriver#quitを呼び出して、各セッションを適切に終了すべきです。
selenium-serverは、進行中の各セッションのメモリ内ログを保持します。 これらのログは、Selenium#stop()またはWebDriver#quitが呼び出されるとクリアされます。 これらのセッションの終了を忘れると、サーバーでメモリリークが発生する可能性があります。 非常に長時間実行されるセッションを維持する場合は、時々停止または終了する必要があります（または-Xmx jvmオプションでメモリを増やします）。
タイムアウト (version 2.21以降) サーバーには2つの異なるタイムアウトがあり、次のように設定できます。
java -jar selenium-server-standalone-{VERSION}.jar -timeout=20 -browserTimeout=60 browserTimeout ブラウザーのハングを許可する時間を制御します（値は秒単位）。 timeout セッションが回収されるまでにクライアントがいなくなる時間を制御します（値は秒単位）。 システムプロパティselenium.server.session.timeoutは、2.21からサポートされなくなりました。
browserTimeoutは、通常のタイムアウトメカニズムが失敗した場合の予備のタイムアウトメカニズムであることに注意してください。これは主にグリッド/サーバー環境で使用され、クラッシュ/失われたプロセスが長く滞留、ランタイム環境を汚染しないようにします。
プログラムでサーバーを構成する 理論的には、プロセスはDriverServletをURLにマッピングするのと同じくらい簡単ですが、ページを全体的にコードで構成されたJettyなどの軽量コンテナでホストすることもできます。これを行う手順は次のとおりです。
selenium-server.zipをダウンロードして解凍します。 JARをCLASSPATHに配置します。 AppServerという新しいクラスを作成します。 ここでは、Jettyを使用しているので、それもダウンロードする必要があります。
import org.mortbay.jetty.Connector; import org.mortbay.jetty.Server; import org.mortbay.jetty.nio.SelectChannelConnector; import org.mortbay.jetty.security.SslSocketConnector; import org.mortbay.jetty.webapp.WebAppContext; import javax.servlet.Servlet; import java.io.File; import org.openqa.selenium.remote.server.DriverServlet; public class AppServer { private Server server = new Server(); public AppServer() throws Exception { WebAppContext context = new WebAppContext(); context.</description></item><item><title>待機</title><link>https://www.selenium.dev/ja/documentation/webdriver/waits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/waits/</guid><description>Perhaps the most common challenge for browser automation is ensuring that the web application is in a state to execute a particular Selenium command as desired. The processes often end up in a race condition where sometimes the browser gets into the right state first (things work as intended) and sometimes the Selenium code executes first (things do not work as intended). This is one of the primary causes of flaky tests.</description></item><item><title>リンクスパイダー</title><link>https://www.selenium.dev/ja/documentation/test_practices/discouraged/link_spidering/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/test_practices/discouraged/link_spidering/</guid><description>WebDriverを使用してリンクをスパイダーすることは、実行できないためではなく、最も理想的なツールではないため明らかに推奨される方法ではありません。 WebDriverの起動には時間が必要であり、テストの記述方法によっては、ページに到達してDOMを通過するために数秒から1分かかる場合があります。
このためにWebDriverを使用する代わりに、curl コマンドを実行するか、BeautifulSoupなどのライブラリを使用することにより、これらの方法はブラウザーの作成やページへの移動に依存しないため、時間を大幅に節約できます。 このタスクにWebDriverを使用しないことで、時間を大幅に節約できます。</description></item><item><title>改善されたレポート</title><link>https://www.selenium.dev/ja/documentation/test_practices/encouraged/improved_reporting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/test_practices/encouraged/improved_reporting/</guid><description>Seleniumは、実行されたテストケースのステータスをレポートするようには設計されていません。 単体テストフレームワークの組み込みのレポート機能を利用することは、良いスタートです。 ほとんどの単体テストフレームワークには、xUnitまたはHTML形式のレポートを生成できるレポートがあります。 xUnitレポートは、Jenkins、Travis、Bambooなどの継続的インテグレーション（CI）サーバーに結果をインポートするのに人気があります。 いくつかの言語のレポート出力に関する詳細情報へのリンクがあります。
NUnit 3 Console Runner
NUnit 3 Console Command Line
xUnit getting test results in TeamCity
xUnit getting test results in CruiseControl.NET
xUnit getting test results in Azure DevOps</description></item><item><title>IE specific functionality</title><link>https://www.selenium.dev/ja/documentation/webdriver/browsers/internet_explorer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/browsers/internet_explorer/</guid><description>As of June 2022, Selenium officially no longer supports standalone Internet Explorer. The Internet Explorer driver still supports running Microsoft Edge in &amp;ldquo;IE Compatibility Mode.&amp;rdquo;
Special considerations The IE Driver is the only driver maintained by the Selenium Project directly. While binaries for both the 32-bit and 64-bit versions of Internet Explorer are available, there are some known limitations with the 64-bit driver. As such it is recommended to use the 32-bit driver.</description></item><item><title>ロケータをうまく扱うTips</title><link>https://www.selenium.dev/ja/documentation/test_practices/encouraged/locators/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/test_practices/encouraged/locators/</guid><description>サポートしているロケータについては 要素を探すを参照してください。
一般に、HTMLのid属性が利用可能でユニークかつ一貫している場合、ページで要素を探す方法として適しています。 idは動作がとても速い傾向があり、複雑なDOMトラバースに伴う処理を省略できます。
ユニークなidが使えない場合、きれいに書かれたCSSセレクタが要素を探す方法として適しています。 XPathはCSSセレクタと同様に動作しますが、シンタックスは複雑で大抵の場合デバッグが困難です。 XPathはとても柔軟ですが、ブラウザベンダは性能テストを通常行っておらず、非常に動作が遅い傾向があります。
link textセレクタとpartial linkText セレクタはa要素でしか動作しないという欠点があります。 加えて、これらはWebDriverの内部でquerySelectorAllの呼び出しに置き換えられます。
タグ名によるロケータは危険な方法になり得ます。 大抵の場合ページ上には同じタグ名の要素が複数あります。タグ名は要素のコレクションを返す findElements(By) メソッドを使う時にもっとも役に立ちます。
ロケータは可能な限り簡潔に、読みやすい状態を保つことを推奨します。 WebDriverでDOM構造のトラバースを行うのは重い処理となります。 検索の範囲を狭めた方がより良い結果を得られます。</description></item><item><title>ウィンドウとタブの操作</title><link>https://www.selenium.dev/ja/documentation/webdriver/interactions/windows/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/interactions/windows/</guid><description>ウィンドウとタブ ウィンドウハンドルの取得 WebDriverは、ウィンドウとタブを区別しません。 サイトが新しいタブまたはウィンドウを開く場合、Seleniumはウィンドウハンドルを使って連動します。 各ウィンドウには一意の識別子があり、これは単一のセッションで持続します。 次のコードを使用して、現在のウィンドウのウィンドウハンドルを取得できます。
Java Python CSharp Ruby JavaScript Kotlin driver.getWindowHandle(); driver.current_window_handle driver.CurrentWindowHandle; driver.window_handle await driver.getWindowHandle(); driver.windowHandle ウィンドウまたはタブの切り替え 新しいウィンドウで開くリンクをクリックすると、新しいウィンドウまたはタブが画面にフォーカスされますが、WebDriverはオペレーティングシステムがアクティブと見なすウィンドウを認識しません。 新しいウィンドウで作業するには、それに切り替える必要があります。 開いているタブまたはウィンドウが2つしかなく、どちらのウィンドウから開始するかがわかっている場合、削除のプロセスによって、WebDriverが表示できる両方のウィンドウまたはタブをループし、元のウィンドウまたはタブに切り替えることができます。
ただし、Selenium 4には、新しいタブ（または）新しいウィンドウを作成して自動的に切り替える新しいAPI NewWindow が用意されています。
Java Python CSharp Ruby JavaScript Kotlin //Store the ID of the original window String originalWindow = driver.getWindowHandle(); //Check we don&amp;#39;t have other windows open already assert driver.getWindowHandles().size() == 1; //Click the link which opens in a new window driver.findElement(By.linkText(&amp;#34;new window&amp;#34;)).click(); //Wait for the new window or tab wait.</description></item><item><title>最初のSeleniumスクリプトを書く</title><link>https://www.selenium.dev/ja/documentation/webdriver/getting_started/first_script/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/getting_started/first_script/</guid><description>Seleniumをインストールし、 すると、Seleniumコードを書く準備が整います。
Eight Basic Components Seleniumが行うことはすべて、ブラウザコマンドを送信して、何かを実行したり、情報の要求を送信したりすることです。 Seleniumで行うことのほとんどは、次の基本的なコマンドの組み合わせです。
Click on the link to &amp;ldquo;View full example on GitHub&amp;rdquo; to see the code in context.
1. ドライバーインスタンスでセッションを開始します For more details on starting a session read our documentation on driver sessions
Java Python CSharp Ruby JavaScript Kotlin WebDriver driver = new ChromeDriver(); View full example on GitHub driver = webdriver.Chrome() View full example on GitHub IWebDriver driver = new ChromeDriver(); View full example on GitHub driver = Selenium::WebDriver.</description></item><item><title>状態を共有しない</title><link>https://www.selenium.dev/ja/documentation/test_practices/encouraged/avoid_sharing_state/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/test_practices/encouraged/avoid_sharing_state/</guid><description>いくつかの場所で言及されていますが、再度言及する価値があります。 テストが互いに分離されていることを確認してください。
テストデータを共有しないでください。 アクションを実行する1つを選択する前に、それぞれが有効な注文をデータベースに照会するいくつかのテストを想像してください。 2つのテストで同じ順序を選択すると、予期しない動作が発生する可能性があります。
別のテストで取得される可能性のあるアプリケーション内の古いデータを削除します。 例: 無効な注文レコード
テストごとに新しいWebDriverインスタンスを作成します。 これにより、テストの分離が保証され、並列化がより簡単になります。</description></item><item><title>二要素認証</title><link>https://www.selenium.dev/ja/documentation/test_practices/discouraged/two_factor_authentication/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/test_practices/discouraged/two_factor_authentication/</guid><description>2FA として知られている2要素認証は、&amp;ldquo;Google Authenticator&amp;rdquo; 、 &amp;ldquo;Microsoft Authenticator&amp;rdquo; などの&amp;quot;Authenticator&amp;quot; モバイルアプリを使用して、 またはSMS、電子メールで認証することにより、 ワンタイムパスワード（OTP）を生成する認証メカニズムです。 これをシームレスかつ一貫して自動化することは、Seleniumの大きな課題です。 このプロセスを自動化する方法はいくつかあります。 しかし、これはSeleniumテストの上にある別のレイヤーであり、また安全でもありません。 したがって、2FAの自動化を回避したほうがいいです。
2FAチェックを回避するいくつかの選択肢があります。
テスト環境で特定のユーザーの2FAを無効にして、 それらのユーザー資格情報を自動化で使用できるようにします。 テスト環境で2FAを無効にします。 特定のIPからログインする場合は、2FAを無効にします。 そうすれば、テストマシンのIPを設定してこれを回避できます。</description></item><item><title>テストの独立性</title><link>https://www.selenium.dev/ja/documentation/test_practices/encouraged/test_independency/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/test_practices/encouraged/test_independency/</guid><description>各テストを独自のユニットとして記述します。 他のテストに依存しない方法でテストを記述してください。
公開後にモジュールとしてWebサイトに表示されるカスタムコンテンツを作成できるコンテンツ管理システム（CMS）があり、CMSとアプリケーション間の同期に時間がかかる場合があるとします。
モジュールをテストする間違った方法は、1つのテストでコンテンツが作成および公開され、別のテストでモジュールをチェックすることです。 コンテンツは公開後、他のテストですぐに利用できない可能性があるため、この方法はふさわしくありません。
代わりに、影響を受けるテスト内でオン/オフできるスタブコンテンツを作成し、それをモジュールの検証に使用できます。 ただし、コンテンツの作成については、別のテストを行うことができます。</description></item><item><title>Fluent APIの使用を検討する</title><link>https://www.selenium.dev/ja/documentation/test_practices/encouraged/consider_using_a_fluent_api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/test_practices/encouraged/consider_using_a_fluent_api/</guid><description>マーチン・ファウラーは&amp;ldquo;Fluent API&amp;rdquo;という用語を作り出しました。 Seleniumは既に、FluentWaitクラスでこのようなものを実装しています。 これは、標準のWaitクラスの代替としてのものです。 ページオブジェクトでFluent APIデザインパターンを有効にしてから、次のようなコードスニペットを使用してGoogle検索ページを照会できます。
driver.get( &amp;#34;http://www.google.com/webhp?hl=en&amp;amp;amp;tab=ww&amp;#34; ); GoogleSearchPage gsp = new GoogleSearchPage(driver); gsp.setSearchString().clickSearchButton(); この流暢な動作を持つGoogleページオブジェクトクラスは次のようになります。
public abstract class BasePage { protected WebDriver driver; public BasePage(WebDriver driver) { this.driver = driver; } } public class GoogleSearchPage extends BasePage { public GoogleSearchPage(WebDriver driver) { super(driver); // Generally do not assert within pages or components. // Effectively throws an exception if the lambda condition is not met. new WebDriverWait(driver, Duration.ofSeconds(3)).until(d -&amp;gt; d.findElement(By.id(&amp;#34;logo&amp;#34;))); } public GoogleSearchPage setSearchString(String sstr) { driver.</description></item><item><title>Selenium IDE</title><link>https://www.selenium.dev/ja/documentation/ide/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/ide/</guid><description>Seleniumの統合開発環境（Selenium IDE）は、 各要素のコンテキストによって定義されたパラメーターを使用して、 既存のSeleniumコマンドを使用してブラウザーでのユーザーのアクションを記録する、使いやすいブラウザー拡張機能です。 これは、Seleniumの構文を学習するための優れた方法を提供します。 Google Chrome、Mozilla Firefox、およびMicrosoftEdgeで利用できます。
詳細については、充実しているSelenium IDE ドキュメントをご覧ください。</description></item><item><title>Remote WebDriver</title><link>https://www.selenium.dev/ja/documentation/webdriver/drivers/remote_webdriver/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/drivers/remote_webdriver/</guid><description>Selenium lets you automate browsers on remote computers if there is a Selenium Grid running on them. The computer that executes the code is referred to as the client computer, and the computer with the browser and driver is referred to as the remote computer or sometimes as an end-node. To direct Selenium tests to the remote computer, you need to use a Remote WebDriver class and pass the URL including the port of the grid on that machine.</description></item><item><title>Safari specific functionality</title><link>https://www.selenium.dev/ja/documentation/webdriver/browsers/safari/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/browsers/safari/</guid><description>Unlike Chromium and Firefox drivers, the safaridriver is installed with the Operating System. To enable automation on Safari, run the following command from the terminal:
safaridriver --enable Options Capabilities common to all browsers are described on the Options page.
Capabilities unique to Safari can be found at Apple&amp;rsquo;s page About WebDriver for Safari
Starting a Safari session with basic defined options looks like this:
Java Python CSharp Ruby JavaScript Kotlin SafariOptions options = new SafariOptions(); driver = new SafariDriver(options); View full example on GitHub options = webdriver.</description></item><item><title>Selenium4にアップグレードする方法</title><link>https://www.selenium.dev/ja/documentation/webdriver/troubleshooting/upgrade_to_selenium_4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/troubleshooting/upgrade_to_selenium_4/</guid><description>公式にサポートされている言語（Ruby、JavaScript、C＃、Python、およびJava）のいずれかを使用している場合、 Selenium4へのアップグレードは簡単なプロセスです。 いくつかの問題が発生する可能性がある場合があるかもしれません。このガイドは、それらを整理するのに役立ちます。 プロジェクトの依存関係をアップグレードする手順を実行し、バージョンのアップグレードによってもたらされる主な非推奨と変更を理解します。
これが、Selenium4にアップグレードするために実行する手順です。
テストコードの準備 依存関係のアップグレード 潜在的なエラーと非推奨メッセージ 注：Selenium 3.xバージョンの開発中に、W3CWebDriver標準のサポートが実装されました。 この新しいプロトコルと従来のJSONワイヤープロトコルの両方がサポートされました。 バージョン3.11の前後で、SeleniumコードはレベルW3C1仕様に準拠するようになりました。 Selenium 3の最新バージョンのW3C準拠のコードは、Selenium4で期待どおりに機能します。
テストコードの準備 Selenium 4は、レガシープロトコルのサポートを削除し、内部でデフォルトでW3CWebDriver標準を使用します。 ほとんどの場合、この実装はエンドユーザーに影響を与えません。 主な例外は、Capabilitiesと アクション クラスです。
Capabilities テスト機能がW3Cに準拠するように構成されていない場合、セッションが開始されない可能性があります。 W3CWebDriverの標準機能のリストは次のとおりです。
browserName browserVersion (version に変更) platformName (platform に変更) acceptInsecureCerts pageLoadStrategy proxy timeouts unhandledPromptBehavior 標準Capabilitiesの最新リストは、 W3C WebDriver にあります。
上記のリストに含まれていないCapabilitiesには、ベンダープレフィックスを含める必要があります。 これは、ブラウザ固有のCapabilitiesとクラウドベンダー固有のCapabilitiesに適用されます。 たとえば、クラウドベンダーがテストに build Capabilities と name Capabilitiesを使用している場合は、 それらを cloud:options ブロックでラップする必要があります（適切なプレフィックスについては、クラウドベンダーに確認してください）。
Before Move Code
Java JavaScript CSharp Ruby Python DesiredCapabilities caps = DesiredCapabilities.firefox(); caps.setCapability(&amp;#34;platform&amp;#34;, &amp;#34;Windows 10&amp;#34;); caps.setCapability(&amp;#34;version&amp;#34;, &amp;#34;92&amp;#34;); caps.setCapability(&amp;#34;build&amp;#34;, myTestBuild); caps.</description></item><item><title>Organizing and Executing Selenium Code</title><link>https://www.selenium.dev/ja/documentation/webdriver/getting_started/using_selenium/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/getting_started/using_selenium/</guid><description>If you want to run more than a handful of one-off scripts, you need to be able to organize and work with your code. This page should give you ideas for how to actually do productive things with your Selenium code.
Common Uses Most people use Selenium to execute automated tests for web applications, but Selenium support any use case of browser automation.
Repetitive Tasks Perhaps you need to log into a website and download something, or submit a form.</description></item><item><title>Grid アーキテクチャ</title><link>https://www.selenium.dev/ja/documentation/grid/architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/grid/architecture/</guid><description>Grid は、Grid を運用するためのコンポーネントの集合体として設計されています。 非常に複雑に見えるかもしれませんが、 このドキュメントが混乱を解消する手助けとなることを期待します。
キーとなるコンポーネント 主要な Grid のコンポーネント:
イベントバス 他のコンポーネント間で非同期で受信される可能性のあるメッセージを送信します。 新規セッションキュー まだディストリビューターによってノードに割り当てられていない 受信セッションの一覧を管理します。 ディストリビューター Grid内でWebDriverセッション を実行する場所（"スロット"と呼ぶ）を管理し、 新しいセッションリクエストを受け取りスロットに割り当てる役割を担います。 ノード WebDriverセッション を実行します。各セッションはスロットに割り当てられ、 各ノードは1つ以上のスロットを持っています。 セッションマップ セッションID とセッションが実行されているノードのアドレスのマップを管理します。 ルーター Gridのフロントエンドとして動作します。 Gridの中で唯一ウェブに公開してもよい部分です（ただし、公開しないことを強く推奨します）。 受け取ったリクエストを新規セッションキューかセッションが実行されているノードどちらかに振り分けます。 グリッドについて説明する際に、覚えておくと便利な概念がいくつかあります:
スロット はセッションが実行されるところです。 各スロットは ステレオタイプ を持っています。これは ディストリビューターがスロットを所有するノードに 新規セッション リクエストを送信する前に、 リクエストがマッチしなければならない最小限の capabilities のセットです。 Grid モデル はディストリビューターが Grid の状態を追跡する方法です。 その名が示すように、これは時々実際と一致しないことがあります （ディストリビューターが開始したばかりだからかもしれません）。 ディストリビューターが新規セッションのリクエストを素早くスロットに割り当てることができるように、 各ノードに問い合わせるより優先して利用されます。 同期呼び出しと非同期呼び出し Grid 内では主に 2 つの通信メカニズムが使われています。
同期で &amp;ldquo;REST 風&amp;rdquo; な、JSON を用いた HTTP リクエスト イベントバスによって送信される非同期なイベント どちらの仕組みを使うべきかどのように決めればよいでしょうか？ 結局のところ、Grid 全体をイベントベースにモデリングしたとしても、 うまくいくでしょう。
答えは、もし実行されるアクションが同期である場合(例えばほとんどの WebDriver の呼び出しなど)、 あるいはレスポンスを受け取れなかったときに問題になるような場合、 Grid は同期呼び出しを利用します。かわりにもし、関心のあるコンポーネントに情報を ブロードキャストしたい場合、あるいはレスポンスを受け取れなくても問題にならない場合は イベントバスを使用することが望ましいです。</description></item><item><title>テストごとに新しいブラウザを起動する</title><link>https://www.selenium.dev/ja/documentation/test_practices/encouraged/fresh_browser_per_test/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/test_practices/encouraged/fresh_browser_per_test/</guid><description>クリーンな既知の状態から各テストを開始します。 理想的には、テストごとに新しい仮想マシンを起動します。 新しい仮想マシンの起動が実用的でない場合は、少なくともテストごとに新しいWebDriverを起動してください。 Firefoxの場合、既知のプロファイルでWebDriverを起動します。 Most browser drivers like GeckoDriver and ChromeDriver will start with a clean known state with a new user profile, by default.
WebDriver driver = new FirefoxDriver();</description></item><item><title>BiDirectional API (W3C compliant)</title><link>https://www.selenium.dev/ja/documentation/webdriver/bidirectional/webdriver_bidi/log/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/bidirectional/webdriver_bidi/log/</guid><description>Page being translated from English to Japanese. Do you speak Japanese? Help us to translate it by sending us pull requests! This section contains the APIs related to logging.
Console logs Listen to the console.log events and register callbacks to process the event.
Java Ruby JavaScript Kotlin Selenium v4.8
public void jsErrors() { CopyOnWriteArrayList&amp;lt;ConsoleLogEntry&amp;gt; logs = new CopyOnWriteArrayList&amp;lt;&amp;gt;(); try (LogInspector logInspector = new LogInspector(driver)) { logInspector.onConsoleEntry(logs::add); } driver.get(&amp;#34;https://www.selenium.dev/selenium/web/bidi/logEntryAdded.html&amp;#34;); View full example on GitHub Add Example</description></item><item><title>Virtual Authenticator</title><link>https://www.selenium.dev/ja/documentation/webdriver/interactions/virtual_authenticator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/ja/documentation/webdriver/interactions/virtual_authenticator/</guid><description>Page being translated from English to Japanese. Do you speak Japanese? Help us to translate it by sending us pull requests! Web applications can enable a public key-based authentication mechanism known as Web Authentication to authenticate users in a passwordless manner. Web Authentication defines APIs that allows a user to create a public-key credential and register it with an authenticator. An authenticator can be a hardware device or a software entity that stores user&amp;rsquo;s public-key credentials and retrieves them on request.</description></item></channel></rss>