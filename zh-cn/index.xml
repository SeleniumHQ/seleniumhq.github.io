<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Selenium</title><link>https://www.selenium.dev/zh-cn/</link><description>Recent content on Selenium</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://www.selenium.dev/zh-cn/index.xml" rel="self" type="application/rss+xml"/><item><title>Browsing Context</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/bidi/w3c/browsing_context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/bidi/w3c/browsing_context/</guid><description>Page being translated from English to Chinese. Do you speak Chinese? Help us to translate it by sending us pull requests! Commands This section contains the APIs related to browsing context commands.
Open a new window Creates a new browsing context in a new window.
Java Ruby JavaScript Kotlin Selenium v4.8
void testCreateAWindow() { BrowsingContext browsingContext = new BrowsingContext(driver, WindowType.WINDOW); Assertions.assertNotNull(browsingContext.getId()); } View full example on GitHub Add Example</description></item><item><title>Browsing Context</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/bidi/w3c/input/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/bidi/w3c/input/</guid><description>Page being translated from English to Chinese. Do you speak Chinese? Help us to translate it by sending us pull requests! This section contains the APIs related to input commands.
Perform Actions Java Ruby JavaScript Kotlin Selenium v4.17
Actions selectThreeOptions = actions.click(options.get(1)).keyDown(Keys.SHIFT).click(options.get(3)).keyUp(Keys.SHIFT); input.perform(windowHandle, selectThreeOptions.getSequences()); View full example on GitHub Add Example
Selenium v4.17
const actions = driver.actions().click(options[1]).keyDown(Key.SHIFT).click(options[3]).keyUp(Key.SHIFT).getSequences() await input.perform(browsingContextId, actions) View full example on GitHub Add Example
Release Actions Java Ruby JavaScript Kotlin Selenium v4.</description></item><item><title>WebDriver BiDi Logging Features</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/bidi/logging/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/bidi/logging/</guid><description>Remember that to use WebDriver BiDi, you must enable it in Options. For more details, see Enabling BiDi
Console Message Handlers Record or take actions on console.log events.
Add Handler Java Python CSharp Ruby JavaScript Kotlin Implementation Missing
driver.script.add_console_message_handler(log_entries.append) View full example on GitHub Implementation Missing
driver.script.add_console_message_handler { |log| log_entries &amp;lt;&amp;lt; log } View full example on GitHub Implementation Missing
Implementation Missing
Remove Handler You need to store the ID returned when adding the handler to delete it.</description></item><item><title>WebDriver BiDi Network Features</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/bidi/network/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/bidi/network/</guid><description>The implementation of these features is being tracked here: #13993
Remember that to use WebDriver BiDi, you must enable it in Options. For more details, see Enabling BiDi
Authentication Handlers Request Handlers Response Handlers</description></item><item><title>Network</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/bidi/w3c/network/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/bidi/w3c/network/</guid><description>Page being translated from English to Chinese. Do you speak Chinese? Help us to translate it by sending us pull requests! Commands This section contains the APIs related to network commands.
Add network intercept Java Ruby JavaScript Kotlin Selenium v4.18
try (Network network = new Network(driver)) { String intercept = network.addIntercept(new AddInterceptParameters(InterceptPhase.BEFORE_REQUEST_SENT)); View full example on GitHub Add Example
Selenium v4.18
const intercept = await network.addIntercept(new AddInterceptParameters(InterceptPhase.BEFORE_REQUEST_SENT)) View full example on GitHub Add Example</description></item><item><title>WebDriver BiDi Script Features</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/bidi/script/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/bidi/script/</guid><description>The implementation of these features is being tracked here: #13992
Remember that to use WebDriver BiDi, you must enable it in Options. For more details, see Enabling BiDi
Script Pinning Execute Script DOM Mutation Handlers</description></item><item><title>Script</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/bidi/w3c/script/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/bidi/w3c/script/</guid><description>Page being translated from English to Chinese. Do you speak Chinese? Help us to translate it by sending us pull requests! Commands This section contains the APIs related to script commands.
Call function in a browsing context Java Ruby JavaScript Kotlin Selenium v4.15
try (Script script = new Script(id, driver)) { List&amp;lt;LocalValue&amp;gt; arguments = new ArrayList&amp;lt;&amp;gt;(); arguments.add(PrimitiveProtocolValue.numberValue(22)); Map&amp;lt;Object, LocalValue&amp;gt; value = new HashMap&amp;lt;&amp;gt;(); value.put(&amp;#34;some_property&amp;#34;, LocalValue.numberValue(42)); LocalValue thisParameter = LocalValue.objectValue(value); arguments.</description></item><item><title>版权和归属</title><link>https://www.selenium.dev/zh-cn/documentation/about/copyright/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/about/copyright/</guid><description>Selenium文档 我们已尽一切努力使本文档尽可能完整和准确, 但难以保证一定适用. 信息提供是基于“as-is”的. 若本文档所含信息引起的任何损失或损害, 作者和出版者对所有个人或实体均不承担任何责任. 不承担任何与使用本文信息相关的专利责任.
归属 感谢: Selenium Main Repository @shs96c 5327 commits @barancev 3352 commits @jimevans 2478 commits @titusfortner 1592 commits @jleyba 1464 commits @jarib 1299 commits @diemol 1270 commits @AutomatedTester 1223 commits @dfabulich 1175 commits @illicitonion 1162 commits @p0deje 652 commits @lukeis 599 commits @pujagani 521 commits @eranmes 473 commits @mdub 326 commits @bonigarcia 305 commits @andreastt 289 commits @krosenvold 225 commits @hugs 205 commits @symonk 203 commits @davehunt 200 commits @harsha509 194 commits @hbchai 191 commits @lmtierney 179 commits @joerg1985 166 commits @nvborisenko 138 commits @freynaud 138 commits @samitbadle 137 commits @nirvdrum 133 commits @sevaseva 115 commits @gigix 109 commits @juangj 108 commits @selenium-ci 107 commits @aslakhellesoy 94 commits @alex-savchuk 90 commits @dependabot[bot] 84 commits @andrashatvani 66 commits @ajayk 63 commits @twalpole 49 commits @asashour 48 commits @mikemelia 46 commits @tebeka 44 commits @raju249 42 commits @luke-hill 42 commits @santiycr 41 commits @valfirst 40 commits @sandeepsuryaprasad 39 commits @renovate[bot] 39 commits @mach6 36 commits @ddavison 32 commits @joshbruning 30 commits @TamsilAmani 29 commits @mikebroberts 28 commits @JohnChen0 27 commits @iampopovich 26 commits @VietND96 26 commits @krmahadevan 25 commits @alb-i986 22 commits @corevo 20 commits @cgoldberg 20 commits @bret 20 commits @Stuk 19 commits @aguspe 17 commits @rbri 16 commits @bwalderman 15 commits @asolntsev 14 commits @manuelsblanco 13 commits @bayandin 12 commits @carlosgcampos 12 commits @jayakumarc 12 commits @potapovDim 12 commits @Delta456 12 commits @43081j 11 commits @josephg 10 commits @sbabcoc 10 commits @navin772 10 commits @detro 10 commits @redsquirrel 9 commits @whimboo 9 commits @isaulv 9 commits @mdmintz 9 commits @hoefling 9 commits @RustyNail 9 commits @mmerrell 8 commits @dratler 7 commits @User253489 7 commits @LogicOscar 7 commits @DrMarcII 7 commits @llaskin 7 commits @SinghHrmn 7 commits @dima-groupon 6 commits @lauromoura 6 commits @nikolas 6 commits @shucon 6 commits @mk868 6 commits @adiohana 5 commits @oddui 5 commits @seanpoulter 5 commits @nschonni 5 commits @JohanLorenzo 5 commits Selenium IDE @corevo 2445 commits @toddtarsi 396 commits @baimao8437 88 commits @coinzdude 57 commits @Jongkeun 51 commits @petermouse 36 commits @zavelevsky 34 commits @dependabot[bot] 29 commits @LinYunWen 28 commits @xdennisx 15 commits @AutomatedTester 15 commits @smildlzj 12 commits @raju249 12 commits @diemol 7 commits @matewilk 6 commits @manoj9788 3 commits @Rowdster 3 commits @fernandozw 3 commits @mattonem 3 commits @zewa666 3 commits @shs96c 3 commits @toshiya 2 commits @mrgamedev07 2 commits @Meir017 2 commits @lukeis 2 commits @giuliohome 2 commits @cclauss 2 commits @Angus3280 2 commits @peter-lyons-kehl 1 commits @newgenrpa 1 commits @bolasblack 1 commits @vivrichards600 1 commits @swes1117 1 commits @Delta456 1 commits @harsha509 1 commits @samitbadle 1 commits @sotayamashita 1 commits @p2635 1 commits @marknoble 1 commits @furkanakkurt1335 1 commits @dvd900 1 commits @cliftonHPE 1 commits @atkulp 1 commits @aplorenzen 1 commits @amitzur 1 commits @AlexGarrity 1 commits Docker Selenium @diemol 538 commits @VietND96 272 commits @selenium-ci 166 commits @ddavison 134 commits @renovate[bot] 60 commits @mtscout6 53 commits @kayabendroth 50 commits @dependabot[bot] 42 commits @elgalu 24 commits @luisfcorreia 15 commits @jamesmortensen 12 commits @WillAbides 8 commits @amardeep2006 7 commits @jsa34 7 commits @MacCracken 5 commits @marten-cz 5 commits @garagepoort 4 commits @metajiji 4 commits @Doofus100500 4 commits @manoj9788 4 commits @ZainabSalameh 4 commits @niQo 4 commits @testphreak 4 commits @chenrui333 4 commits @jeff-jk 3 commits @pabloFuente 3 commits @alexgibson 3 commits @tnguyen14 3 commits @abaldwin-op 3 commits @mtcolman 3 commits @Remi-p 3 commits @msvticket 3 commits @davehunt 2 commits @mhnaeem 2 commits @naveensrinivasan 2 commits @phensley 2 commits @anthonybaldwin 2 commits @ryneeverett 2 commits @wheleph 2 commits @Opvolger 2 commits @budtmo 2 commits @SurelyMario 2 commits @schmunk42 2 commits @evertones 2 commits @kmala 2 commits @den-is 2 commits @ilpianista 2 commits @adriangonciarz 2 commits @chuckg 2 commits @baflQA 2 commits @brunobritorj 2 commits @therealdjryan 2 commits @AutomationD 2 commits @Earlopain 2 commits @ehbello 2 commits @efranken 2 commits @DrFaust92 2 commits @joaoluizjoaquim 2 commits @mathieu-pousse 2 commits @maxmanuylov 2 commits @mcgriddle 1 commits @tparikkaatmilliman 1 commits @nefelim4ag 1 commits @cvakiitho 1 commits @torstenwalter 1 commits @Trigtrig 1 commits @trungprivate 1 commits @victor-catalyst 1 commits @VinodAnandan 1 commits @slhck 1 commits @wesmcouch 1 commits @williamlac 1 commits @schmetzyannick 1 commits @scottturley 1 commits @StegSchreck 1 commits @sethuster 1 commits @smccarthy 1 commits @smccarthy-godaddy 1 commits @simonardejr 1 commits @serlank 1 commits @srguglielmo 1 commits @stigkj 1 commits @subanithak 1 commits @sylbn 1 commits @tadashi0713 1 commits @Thab310 1 commits @gitter-badger 1 commits @graingert 1 commits @ThomasMeschke 1 commits @mirkotschaeni 1 commits @mkrei 1 commits @neben 1 commits @neilnaveen 1 commits @nom3ad 1 commits @oleg-filiutsich 1 commits @other019 1 commits @ptriller1und1 1 commits @pujan14 1 commits @qxo 1 commits @rklec 1 commits Selenium Website &amp;amp; Docs @harsha509 771 commits @diemol 768 commits @selenium-ci 323 commits @titusfortner 232 commits @renovate[bot] 154 commits @alaahong 115 commits @pujagani 74 commits @kzhirata 47 commits @bonigarcia 37 commits @pallavigitwork 34 commits @boris779 32 commits @shbenzer 30 commits @AutomatedTester 30 commits @alenros 28 commits @aguspe 26 commits @AlexAndradeNet 25 commits @dependabot[bot] 22 commits @manoj9788 21 commits @jmartinezpoq 18 commits @ivanrodjr 17 commits @github-actions[bot] 16 commits @luisfcorreia 15 commits @shs96c 13 commits @sindhudiddi 12 commits @nvborisenko 11 commits @hiroksarker 10 commits @nwintop 8 commits @testbot206 7 commits @krmahadevan 7 commits @tetration 7 commits @connerT 6 commits @Greavox 6 commits @VietND96 6 commits @liushilive 6 commits @fufu930 6 commits @Catalin-Negru 5 commits @davieduardo94 5 commits @smilinrobin 5 commits @lvninety 5 commits @hyanx 5 commits @TamsilAmani 5 commits @nainappa 5 commits @Dor-bl 5 commits @deining 4 commits @nevinaydin 4 commits @ant9112 4 commits @peter-kinzelman 4 commits @kathyrollo 4 commits @kjayachandra2000 4 commits @harshitBhardwaj97 4 commits @wcmcgee 4 commits @barancev 4 commits @angelovstanton 4 commits @Tolerblanc 3 commits @BlazerYoo 3 commits @twinstae 3 commits @cambiph 3 commits @TestOpsCloudchen 3 commits @takeyaqa 3 commits @raju249 3 commits @rajeevbarde 3 commits @Madh93 3 commits @mmerrell 3 commits @j3soon 3 commits @jasonren0403 3 commits @jamesmortensen 3 commits @jags14385 3 commits @effeix 3 commits @gnatcatcher-bg 3 commits @ArCiGo 3 commits @Crank4098 3 commits @Arc-Jung 3 commits @ilhanoztozlu 2 commits @eaccmk 2 commits @digitalvoice-nz 2 commits @YoshikiIto 2 commits @sridhar-5 2 commits @urig 2 commits @SparshKesari 2 commits @sbabcoc 2 commits @sangcnguyen 2 commits @zipperer 2 commits @coodjokergl 2 commits @sangheon4353 2 commits @selectorshubsanjay 2 commits @SripriyaPKulkarni 2 commits @GavinHaydy 2 commits @imba-tjd 2 commits @k19810703 2 commits @0420syj 2 commits @TheTestLynx 2 commits @beatfactor 2 commits @Afranioalves 2 commits @Arpan3323 2 commits @iambocai 2 commits @Bredda 2 commits @cjayswal 2 commits @bongosway 2 commits @SinghHrmn 2 commits @rahuljhakant 2 commits Previous Selenium Website @lukeis 417 commits @shs96c 87 commits @pgrandje 79 commits @barancev 63 commits @lightbody 59 commits @ajayk 40 commits @tarun3kumar 40 commits @ddavison 36 commits @davehunt 26 commits @manoj9788 24 commits @peter-lyons-kehl 22 commits @lmtierney 21 commits @samitbadle 21 commits @santiycr 19 commits @illicitonion 17 commits @pnewhook 14 commits @AutomatedTester 12 commits @rasmusbergpalm 11 commits @juangj 11 commits @lukeis-sfdc 10 commits @andreastt 7 commits @hugs 6 commits @corevo 5 commits @titusfortner 5 commits @PaulKC 5 commits @llaskin 5 commits @jimevans 5 commits @jarib 5 commits @diemol 3 commits @abhijain2618 2 commits @labkey-tchad 2 commits @paul-hammant 2 commits @mikemelia 2 commits @julianharty 2 commits @hazmeister 2 commits @eranmes 2 commits @darrincherry 2 commits @javabrett 2 commits @alex-savchuk 2 commits @oleksandr-lobunets 2 commits @asashour 2 commits @yasinguzel 1 commits @Vimal-N 1 commits @SteveDesmond-ca 1 commits @harrissAvalon 1 commits @smatei 1 commits @QuinnWilton 1 commits @roydekleijn 1 commits @rbri 1 commits @oifland 1 commits @ohadschn 1 commits @NickAb 1 commits @tobecrazy 1 commits @Zearin 1 commits @beckendorff 1 commits @daveOrleans 1 commits @androiddriver 1 commits @mauk81 1 commits @prab2112 1 commits @refactoror 1 commits @rogerdc 1 commits @tibord 1 commits @ygmarchi 1 commits @agabrys 1 commits @azawawi 1 commits @alb-i986 1 commits @hollingsworthd 1 commits @dylans 1 commits @EmidioStani 1 commits @FagnerMartinsBrack 1 commits @Xaeroxe 1 commits @JamesZoft 1 commits @jleyba 1 commits @JustAGuyTryingToCodeSomething 1 commits @kdamball 1 commits @laurinkeithdavis 1 commits @klamping 1 commits @krmahadevan 1 commits @krosenvold 1 commits @mmerrell 1 commits @grawk 1 commits @mcavigelli 1 commits @michaelwowro 1 commits @muralidharand 1 commits @meeroslaph 1 commits Previous Documentation Rewrite Project @andreastt 197 commits @selenium-ci 105 commits @diemol 54 commits @hazmeister 30 commits @santiycr 27 commits @AlexAndradeNet 25 commits @lukeis 21 commits @harsha509 17 commits @ddavison 16 commits @djangofan 12 commits @orieken 12 commits @manoj9788 12 commits @davehunt 12 commits @liushilive 8 commits @User253489 7 commits @shs96c 6 commits @mmerrell 6 commits @imba-tjd 6 commits @jimholmes 6 commits @vijay44 5 commits @cambiph 5 commits @NickOppersdorff 4 commits @rivlinp 4 commits @sheg 4 commits @bizob2828 4 commits @detro 3 commits @Ardesco 3 commits @TheTestLynx 3 commits @paul-barton 2 commits @ilhanoztozlu 2 commits @hoanluu 2 commits @sri85 2 commits @miekof 2 commits @palotas 2 commits @lmtierney 2 commits @Bredda 2 commits @boris779 2 commits @rakib-amin 1 commits @NRezek 1 commits @nikai3d 1 commits @OndraM 1 commits @sourabhkt 1 commits @whhone 1 commits @yarix 1 commits @ZbigniewZabost 1 commits @agmen 1 commits @hking-shutterfly 1 commits @jimevans 1 commits @948462448 1 commits @marilyn 1 commits @riccione 1 commits @tungla 1 commits @zeljkofilipin 1 commits @MilanMasek 1 commits @misiekofski 1 commits @michael-coleman 1 commits @MartinDelille 1 commits @austenjt 1 commits @nicegraham 1 commits @bongosway 1 commits @donhuvy 1 commits @dennybiasiolli 1 commits @chamiz 1 commits @bhardin 1 commits @abotalov 1 commits @AJ-72 1 commits @p0deje 1 commits @alenros 1 commits @adithyab94 1 commits Selenium文档项目使用的第三方软件: 软件 版本 许可 Hugo v0.</description></item><item><title>配置帮助</title><link>https://www.selenium.dev/zh-cn/documentation/grid/configuration/help/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/grid/configuration/help/</guid><description>Help命令显示基于当前代码实现的信息. 因此, 如果文档没有更新, 它将提供准确的信息. 这是了解任何新版本Grid4配置的最便捷方法.
信息命令 Info命令提供以下主题的详细文档:
配置Selenium 安全 会话表配置 追踪 配置帮助 通过运行以下命令快速获取配置帮助:
java -jar selenium-server-&amp;lt;version&amp;gt;.jar info config 安全 获取构建网格服务器的详细信息, 用于安全通信和节点注册.
java -jar selenium-server-&amp;lt;version&amp;gt;.jar info security 会话表配置 默认情况下, 网格使用本地会话表来存储会话信息. 网格支持额外的存储选项, 比如Redis和JDBC-SQL支持的数据库. 要设置不同的会话存储, 请使用以下命令获取设置步骤:
java -jar selenium-server-&amp;lt;version&amp;gt;.jar info sessionmap 基于OpenTelemetry和Jaeger的追踪配置 默认情况下, 追踪是启用的. 要通过Jaeger导出追踪并将其可视化, 请使用以下命令进行说明:
java -jar selenium-server-&amp;lt;version&amp;gt;.jar info tracing 列出Selenium网格的命令 java -jar selenium-server-&amp;lt;version&amp;gt;.jar --config-help 上述命令将显示所有可用的命令及其描述.
组件帮助命令 在Selenium后面键入&amp;ndash;help的配置选项, 以获取特定组件的配置信息.
Standalone java -jar selenium-server-&amp;lt;version&amp;gt;.jar standalone --help Hub java -jar selenium-server-&amp;lt;version&amp;gt;.jar hub --help Sessions java -jar selenium-server-&amp;lt;version&amp;gt;.</description></item><item><title>浏览器导航</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/interactions/navigation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/interactions/navigation/</guid><description>打开网站 启动浏览器后你要做的第一件事就是打开你的网站。这可以通过一行代码实现:
Java Python CSharp Ruby JavaScript Kotlin //Convenient driver.get(&amp;#34;https://selenium.dev&amp;#34;); //Longer way driver.navigate().to(&amp;#34;https://selenium.dev&amp;#34;); View full example on GitHub driver.get(&amp;#34;https://www.selenium.dev/selenium/web/index.html&amp;#34;) View full example on GitHub //Convenient driver.Url = &amp;#34;https://selenium.dev&amp;#34;; //Longer driver.Navigate().GoToUrl(&amp;#34;https://selenium.dev&amp;#34;); View full example on GitHub driver.navigate.to &amp;#39;https://www.selenium.dev/&amp;#39; driver.get &amp;#39;https://www.selenium.dev/&amp;#39; expect(driver.current_url).to eq &amp;#39;https://www.selenium.dev/&amp;#39; View full example on GitHub //Convenient await driver.get(&amp;#39;https://www.selenium.dev&amp;#39;); //Longer way await driver.navigate().to(&amp;#34;https://www.selenium.dev/selenium/web/index.html&amp;#34;); View full example on GitHub // 简便的方法 driver.get(&amp;#34;https://selenium.dev&amp;#34;) // 更长的方法 driver.navigate().to(&amp;#34;https://selenium.dev&amp;#34;) 后退 按下浏览器的后退按钮: Java Python CSharp Ruby JavaScript Kotlin //Back driver.</description></item><item><title>测试自动化概述</title><link>https://www.selenium.dev/zh-cn/documentation/test_practices/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/test_practices/overview/</guid><description>首先，问问自己是否真的需要使用浏览器。 在某些情况下，如果您正在开发一个复杂的 web 应用程序， 您需要打开一个浏览器并进行实际测试，这种可能性是很大的。
然而，诸如 Selenium 之类的功能性最终用户测试运行起来很昂贵。 此外，它们通常需要大量的基础设施才能有效运行。 经常问问自己，您想要测试的东西是否可以使用更轻量级的测试方法（如单元测试）完成， 还是使用较低级的方法完成，这是一个很好的规则。
一旦确定您正在进行Web浏览器测试业务， 并且您的 Selenium 环境已经准备好开始编写测试， 您通常会执行以下三个步骤的组合：
设置数据 执行一组离散的操作 评估结果 您需要尽可能缩短这些步骤; 一到两个操作在大多数时间内应该足够了。 浏览器自动化具有“脆弱”的美誉， 但实际上那是因为用户经常对它要求过高。 在后面的章节中，我们将回到您可以使用的技术， 为了缓解测试中明显的间歇性问题， 特别是如何克服 浏览器 和 WebDriver 之间的竞争条件。
通过保持测试简短并仅在您完全没有替代方案时使用Web浏览器，您可以用最小的代码片段来完成很多测试。
Selenium测试的一个显著优势是，它能够从用户的角度测试应用程序的所有组件（从后端到前端）。 因此，换句话说，虽然功能测试运行起来可能很昂贵，但它们同时也包含了大量关键业务部分。
测试要求 如前所述，Selenium 测试运行起来可能很昂贵。 在多大程度上取决于您正在运行测试的浏览器， 但历史上浏览器的行为变化太大，以至于通常是针对多个浏览器进行交叉测试的既定目标。
Selenium 允许您在多个操作系统上的多个浏览器上运行相同的指令， 但是对所有可能的浏览器、它们的不同版本以及它们所运行的许多操作系统的枚举将很快成为一项繁重的工作。
让我们从一个例子开始 Larry 写了一个网站，允许用户订购他们自己定制的独角兽。
一般的工作流程(我们称之为“幸福之路”)是这样的:
创建一个账户 配置他们的独角兽 添加到购物车 检验并付款 给出关于他们独角兽的反馈 编写一个宏大的 Selenium 脚本来执行所有这些操作是很诱人的 — 很多人都会尝试这样做。 抵制诱惑！ 这样做会导致测试: a) 需要很长时间; b) 会受到一些与页面呈现时间问题有关的常见问题的影响; c) 如果失败，它不会给出一个简洁的、“可检查”的方法来诊断出了什么问题。
测试此场景的首选策略是将其分解为一系列独立的、快速的测试，每个测试都有一个存在的“理由”。
假设您想测试第二步： 配置您的独角兽。 它将执行以下操作:
创建一个帐户 配置一个独角兽 请注意，我们跳过了这些步骤的其余部分， 在完成这一步之后，我们将在其他小的、离散的测试用例中测试工作流的其余部分。</description></item><item><title>可观测性</title><link>https://www.selenium.dev/zh-cn/documentation/grid/advanced_features/observability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/grid/advanced_features/observability/</guid><description>Page being translated from English to Chinese. Do you speak Chinese? Help us to translate it by sending us pull requests! Table of Contents Selenium Grid Observability Distributed tracing Event logging Grid Observability Visualizing Traces Leveraging event logs References Selenium Grid Grid aids in scaling and distributing tests by executing tests on various browser and operating system combinations.
Observability Observability has three pillars: traces, metrics and logs. Since Selenium Grid 4 is designed to be fully distributed, observability will make it easier to understand and debug the internals.</description></item><item><title>了解组件</title><link>https://www.selenium.dev/zh-cn/documentation/overview/components/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/overview/components/</guid><description>使用 WebDriver 构建测试套件需要您理解并有效地使用许多不同的组件。就像软件中的一切一样， 不同的人对同一个想法使用不同的术语。下面是在这个描述中如何使用术语的细分。
专业术语 API: 应用程序编程接口。这是一组用来操作 WebDriver 的 “命令”。 库: 一个代码模块，它包含 api 和实现这些 api 所需的代码。库是对应于具体的语言的，例如 Java 的 .jar 文件，.NET 的 .dll 文件，等等。 驱动程序: 负责控制实际的浏览器。大多数驱动程序是由浏览器厂商自己创建的。 驱动程序通常是与浏览器一起在系统上运行的可执行模块，而不是在执行测试套件的系统上。 (尽管它们可能是同一个系统。) 注意: 有些人把驱动称为代理。 框架: 用于支持 WebDriver 套件的附加库。这些框架可能是测试框架，如 JUnit 或 NUnit。 它们也可能是支持自然语言特性的框架，如 Cucumber 或 Robotium。还可以编写和使用框架来操作或配置被测试的系统、 数据创建、测试预言等等。 组成部分 至少，WebDriver 通过一个驱动程序与浏览器对话。通信有两种方式: WebDriver 通过驱动程序向浏览器传递命令， 然后通过相同的路径接收信息。
驱动程序是特定于浏览器的，例如 ChromeDriver 对应于谷歌的 Chrome/Chromium， GeckoDriver 对应于 Mozilla 的 Firefox 的，等等。驱动程序在与浏览器相同的系统上运行。 这可能与执行测试本身的系统相同，也可能不同。
上面这个简单的例子就是 _直接_通信。与浏览器的通信也可以是通过 Selenium 服务器或 RemoteWebDriver 进行的 _远程_通信。RemoteWebDriver 与驱动程序和浏览器运行在同一个系统上。
远程通信也可以使用 Selenium Server 或 Selenium Grid 进行，这两者依次与主机系统上的驱动程序进行通信</description></item><item><title>期望状态的等待</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/support_features/expected_conditions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/support_features/expected_conditions/</guid><description>期望状态与 显示等待 一起使用. 与其定义要使用 lambda 执行的代码块, 不如使用 lambda 执行可以创建 Conditions 方法来表示等待的常见事物. 有些方法将定位器作为参数, 有些方法将元素作为参数.
这些方法可以包括以下条件:
元素存在 元素已过期 元素可见 文本可见 标题包含特定值 Java Python CSharp Ruby JavaScript Kotlin Expected Conditions Documentation
Add Example
[Expected Conditions Documentation](https://www.selenium.dev/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.expected_conditions.html) Add Example
.NET stopped supporting Expected Conditions in Selenium 4 to minimize maintenance hassle and redundancy. Ruby makes frequent use of blocks, procs and lambdas and does not need Expected Conditions classes Add Example
Add Example</description></item><item><title>设计模式和开发策略</title><link>https://www.selenium.dev/zh-cn/documentation/test_practices/design_strategies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/test_practices/design_strategies/</guid><description>Most of the documentation found in this section is still in English. Please note we are not accepting pull requests to translate this content as translating documentation of legacy components does not add value to the community nor the project. (previously located: https://github.com/SeleniumHQ/selenium/wiki/Bot-Style-Tests)
Overview Over time, projects tend to accumulate large numbers of tests. As the total number of tests increases, it becomes harder to make changes to the codebase &amp;mdash; a single &amp;ldquo;simple&amp;rdquo; change may cause numerous tests to fail, even though the application still works properly.</description></item><item><title>文件上传</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/elements/file_upload/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/elements/file_upload/</guid><description>Because Selenium cannot interact with the file upload dialog, it provides a way to upload files without opening the dialog. If the element is an input element with type file, you can use the send keys method to send the full path to the file that will be uploaded.
Java Python CSharp Ruby JavaScript Kotlin WebElement fileInput = driver.findElement(By.cssSelector(&amp;#34;input[type=file]&amp;#34;)); fileInput.sendKeys(uploadFile.getAbsolutePath()); driver.findElement(By.id(&amp;#34;file-submit&amp;#34;)).click(); View full example on GitHub file_input = driver.find_element(By.CSS_SELECTOR, &amp;#34;input[type=&amp;#39;file&amp;#39;]&amp;#34;) file_input.</description></item><item><title>验证码</title><link>https://www.selenium.dev/zh-cn/documentation/test_practices/discouraged/captchas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/test_practices/discouraged/captchas/</guid><description>验证码 (CAPTCHA), 是 全自动区分计算机和人类的图灵测试 (Completely Automated Public Turing test to tell Computers and Humans Apart) 的简称, 是被明确地设计用于阻止自动化的, 所以不要尝试!
规避验证码的检查, 主要有两个策略:
在测试环境中禁用验证码 添加钩子以允许测试绕过验证码</description></item><item><title>CLI 选项</title><link>https://www.selenium.dev/zh-cn/documentation/grid/configuration/cli_options/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/grid/configuration/cli_options/</guid><description>Page being translated from English to Chinese. Do you speak Chinese? Help us to translate it by sending us pull requests! Different sections are available to configure a Grid. Each section has options can be configured through command line arguments.
A complete description of the component to section mapping can be seen below.
Note that this documentation could be outdated if an option was modified or added but has not been documented yet.</description></item><item><title>GraphQL查询支持</title><link>https://www.selenium.dev/zh-cn/documentation/grid/advanced_features/graphql_support/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/grid/advanced_features/graphql_support/</guid><description>GraphQL 是一种用于API的查询语言, 也是用于使用现有数据完成这些查询的运行时. 其仅仅是使用户能够准确地获取所需.
枚举 枚举是表示字段的可能值的集合.
例如, Node对象具有一个称为status的字段. 状态是一个枚举 (特别是Status类型) , 因为它可能是UP , DRAINING 或 UNAVAILABLE.
标量 标量是基本类型的值: Int, Float, String, Boolean, 或 ID.
在调用GraphQL API时, 必须指定嵌套子字段, 直到只返回标量.
模式的结构 网格模式的结构如下:
{ session(id: &amp;#34;&amp;lt;session-id&amp;gt;&amp;#34;) : { id, capabilities, startTime, uri, nodeId, nodeUri, sessionDurationMillis slot : { id, stereotype, lastStarted } } grid: { uri, totalSlots, nodeCount, maxSession, sessionCount, version, sessionQueueSize } sessionsInfo: { sessionQueueRequests, sessions: [ { id, capabilities, startTime, uri, nodeId, nodeUri, sessionDurationMillis slot : { id, stereotype, lastStarted } } ] } nodesInfo: { nodes : [ { id, uri, status, maxSession, slotCount, sessions: [ { id, capabilities, startTime, uri, nodeId, nodeUri, sessionDurationMillis slot : { id, stereotype, lastStarted } } ], sessionCount, stereotypes, version, osInfo: { arch, name, version } } ] } } 查询 GraphQL 查询GraphQL的最佳方法是使用curl请求.</description></item><item><title>HTML runner</title><link>https://www.selenium.dev/zh-cn/documentation/legacy/selenium_ide/html_runner/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/legacy/selenium_ide/html_runner/</guid><description>Selenium HTML-runner 允许您从命令行运行 Test Suites。 Test Suites 是从 Selenium IDE 或兼容工具导出的 HTML。
公共信息 geckodriver / firefox / selenium-html-runner 版本的组合很重要。 可能在某个地方有一个软件兼容性矩阵。
selenium-html-runner 只运行 Test Suite（而不是 Test Case —— 例如从 Monitis Transaction Monitor 导出的东西）。一定要遵守这个规定。
对于没有 DISPLAY 的 Linux 用户，您需要启动具有 Virtual DISPLAY 的 html-runner （搜索 xvfb）
示例 Linux 环境 安装 / 下载以下软件包：
[user@localhost ~]$ cat /etc/redhat-release CentOS Linux release 7.4.1708 (Core) [user@localhost ~]$ rpm -qa | egrep -i &amp;#34;xvfb|java-1.8|firefox&amp;#34; xorg-x11-server-Xvfb-1.19.3-11.el7.x86_64 firefox-52.4.0-1.el7.centos.x86_64 java-1.8.0-openjdk-1.8.0.151-1.b12.el7_4.x86_64 java-1.8.0-openjdk-headless-1.8.0.151-1.b12.el7_4.x86_64 Test Suite 示例：</description></item><item><title>Internet Explorer Driver Internals</title><link>https://www.selenium.dev/zh-cn/documentation/ie_driver_server/internals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/ie_driver_server/internals/</guid><description>Client Code Into the Driver We use the W3C WebDriver protocol to communicate with a local instance of an HTTP server. This greatly simplifies the implementation of the language-specific code, and minimzes the number of entry points into the C++ DLL that must be called using a native-code interop technology such as JNA, ctypes, pinvoke or DL.
Memory Management The IE driver utilizes the Active Template Library (ATL) to take advantage of its implementation of smart pointers to COM objects.</description></item><item><title>Chrome DevTools Logging Features</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/bidi/cdp/logging/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/bidi/cdp/logging/</guid><description>Page being translated from English to Chinese. Do you speak Chinese? Help us to translate it by sending us pull requests! While Selenium 4 provides direct access to the Chrome DevTools Protocol, these methods will eventually be removed when WebDriver BiDi implemented.
Console Logs Java Python CSharp Ruby JavaScript Kotlin ((HasLogEvents) driver).onLogEvent(consoleEvent(e -&amp;gt; messages.add(e.getMessages().get(0)))); View full example on GitHub async with driver.bidi_connection() as session: async with Log(driver, session).add_listener(Console.ALL) as messages: View full example on GitHub using IJavaScriptEngine monitor = new JavaScriptEngine(driver); var messages = new List&amp;lt;string&amp;gt;(); monitor.</description></item><item><title>Selenium RC (Selenium 1)</title><link>https://www.selenium.dev/zh-cn/documentation/legacy/selenium_1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/legacy/selenium_1/</guid><description>介绍 在WebDriver / Selenium合并产生功能更强大的Selenium 2之前, Selenium RC一直是Selenium的主要项目. 再次特意强调的是, Selenium 1不再享有技术支持.
Selenium RC 的工作原理 首先, 我们将描述Selenium RC的组件如何运行 以及每个组件在运行测试脚本中所扮演的角色.
RC 组件 Selenium RC 组件包括:
Selenium 服务器, 用于启动并关闭浏览器, 解释运行从测试程序传递来的Selenese命令, 并充当 HTTP代理 , 拦截和验证在浏览器和AUT之间传递的HTTP消息. 客户端库, 提供每种编程语言和 Selenium RC 服务器之间的接口. 以下是一个简化的架构图:
该图显示了客户端库与服务器通信, 并传递了用来执行的每个Selenium命令. 然后, 服务器使用Selenium-Core的JavaScript命令 将Selenium命令传递到浏览器. 浏览器使用其JavaScript解释器执行Selenium命令. 这将运行您在测试脚本中指定的Selenese操作或验证行为.
Selenium 服务器 Selenium 服务器从您的测试程序接收Selenium命令, 对其进行解释, 然后将运行这些测试的结果报告给您的程序.
RC服务器捆绑了Selenium Core并将其自动注入浏览器. 当您的测试程序打开浏览器(使用客户端库API函数)时, 会发生这种情况. Selenium-Core是一个JavaScript程序, 实际上是一组JavaScript函数, 这些函数使用浏览器的内置JavaScript解释器来解释 和执行Selenese命令.
服务器使用简单的HTTP GET / POST请求从您的测试程序接收Selenese命令. 这意味着您可以使用任何可以发送HTTP请求的编程语言 来自动执行浏览器中的Selenium测试.
客户端库 客户端库提供了编程支持, 使您可以从自己设计的程序中运行Selenium命令. 每种受支持的语言都有一个不同的客户端库. Selenium客户端库提供了一个编程接口(API), 即一组函数, 可从您自己的程序中运行Selenium命令. 在每个界面中, 都有一个支持每个Selenese命令的编程功能.</description></item><item><title>安装Selenium类库</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/getting_started/install_library/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/getting_started/install_library/</guid><description>首先，您需要为自动化项目安装 Selenium 绑定库。 库的安装过程取决于您选择使用的语言。
请求对应的程序语言 Java Python CSharp Ruby JavaScript Kotlin 查看该库所支持java的最低版本 here.
应熟练掌握build tool以安装支持java的Selenium库
Maven 具体的依赖位于项目中的 pom.xml 文件:
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.seleniumhq.selenium&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;selenium-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${selenium.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; View full example on GitHub Gradle 具体的依赖位于项目中的 build.gradle 文件中的 testImplementation:
testImplementation &amp;#39;org.seleniumhq.selenium:selenium-java:4.25.0&amp;#39; testImplementation &amp;#39;org.junit.jupiter:junit-jupiter-engine:5.11.3&amp;#39; View full example on GitHub 该库所支持的Python版本最低版本可以在 支持的Python版本 章节中找到 PyPi
这里提供了几种不同的方式来安装 Selenium .
Pip pip install selenium 下载 此外你可以从这里下载 PyPI source archive (selenium-x.x.x.tar.gz) 并通过: setup.py 文件安装:
python setup.py install 在项目中使用 为了在项目中使用它,需要将它添加到 requirements.txt 文件中:</description></item><item><title>测试类型</title><link>https://www.selenium.dev/zh-cn/documentation/test_practices/testing_types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/test_practices/testing_types/</guid><description>验收测试 进行这种类型的测试以确定功能或系统是否满足客户的期望和要求. 这种测试通常涉及客户的合作或反馈, 是一种验证活动, 可以用于回答以下问题：
我们是否在制造 正确的 产品?
对于Web应用程序, 可以通过模拟用户期望的行为 直接使用Selenium来完成此测试的自动化. 可以通过记录/回放, 或通过本文档中介绍的各种支持的语言来完成此类模拟. 注意：有些人可能还会提到, 验收测试是 功能测试 的子类型.
功能测试 进行这种类型的测试是为了确定功能或系统是否正常运行而没有问题. 它会在不同级别检查系统, 以确保涵盖所有方案并且系统能够执行预期的 工作 . 这是一个验证活动, 它回答了以下问题：
我们是否在 正确地 制造产品？
这通常包括： 测试没有错误 (404, 异常…) , 以可用的方式 (正确的重定向) 正常运行, 以可访问的方式并匹配其规格 (请参见前述的 验收测试 ) .
对于Web应用程序, 可以通过模拟预期的结果, 直接使用Selenium来完成此测试的自动化. 可以通过记录/回放或通过本文档中说明的各种支持的语言来完成此模拟.
性能测试 顾名思义, 进行性能测试是为了衡量应用程序的性能.
性能测试主要有两种类型:
负载测试 进行了负载测试, 以验证应用程序在各种特定的负载 (通常是同时连接一定数量的用户) 下的运行状况
压力测试 进行压力测试, 以验证应用程序在压力 (或高于最大支持负载) 下的运行状况.
通常, 性能测试是通过执行一些Selenium书写的测试来完成的, 这些测试模拟了不同的用户 使用Web应用程序的特定功能 并检索了一些有意义的指标.
通常, 这是由其他检索指标的工具完成的.
JMeter 就是这样一种工具.
对于Web应用程序, 要测量的详细信息包括 吞吐量、 延迟、数据丢失、单个组件加载时间&amp;hellip;</description></item><item><title>查询网络元素</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/elements/finders/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/elements/finders/</guid><description>One of the most fundamental aspects of using Selenium is obtaining element references to work with. Selenium offers a number of built-in locator strategies to uniquely identify an element. There are many ways to use the locators in very advanced scenarios. For the purposes of this documentation, let&amp;rsquo;s consider this HTML snippet:
&amp;lt;ol id=&amp;#34;vegetables&amp;#34;&amp;gt; &amp;lt;li class=&amp;#34;potatoes&amp;#34;&amp;gt;… &amp;lt;li class=&amp;#34;onions&amp;#34;&amp;gt;… &amp;lt;li class=&amp;#34;tomatoes&amp;#34;&amp;gt;&amp;lt;span&amp;gt;Tomato is a Vegetable&amp;lt;/span&amp;gt;… &amp;lt;/ol&amp;gt; &amp;lt;ul id=&amp;#34;fruits&amp;#34;&amp;gt; &amp;lt;li class=&amp;#34;bananas&amp;#34;&amp;gt;… &amp;lt;li class=&amp;#34;apples&amp;#34;&amp;gt;… &amp;lt;li class=&amp;#34;tomatoes&amp;#34;&amp;gt;&amp;lt;span&amp;gt;Tomato is a Fruit&amp;lt;/span&amp;gt;… &amp;lt;/ul&amp;gt; First matching element Many locators will match multiple elements on the page.</description></item><item><title>从RC迁移到WebDriver</title><link>https://www.selenium.dev/zh-cn/documentation/legacy/selenium_2/upgrading/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/legacy/selenium_2/upgrading/</guid><description>如何迁移到Selenium WebDriver 在采用Selenium 2时, 一个常见的问题是, 在将新测试添加到现有测试集中时, 正确的做法是什么? 刚接触框架的用户可以通过使用新的WebDriver API编写测试开始. 但是, 已经拥有一套现有测试的用户又该如何呢? 本指南旨在演示如何将现有测试迁移到新的API, 从而允许使用WebDriver提供的新功能编写所有新测试.
此处介绍的方法描述了向WebDriver API的零星迁移, 而无需一次大刀阔斧地重新进行所有工作. 这意味着您可以留出更多时间来迁移现有测试, 这可以使您更轻松地决定将精力花在哪里.
本指南使用Java编写, 因为它为迁移提供了最佳支持. 由于我们为其他语言提供了更好的工具, 因此本指南将扩展为包括这些语言.
为什么要迁移到WebDriver 将一组测试从一个API移到另一个API需要大量的工作. 为什么您和您的团队考虑采取此举? 这是您应考虑迁移Selenium测试以使用WebDriver的一些原因.
较小, 紧凑的API. WebDriver的API比原始的Selenium RC API更面向对象. 这样可以更轻松地使用. 更好地模拟用户交互. WebDriver在可能的情况下利用本机事件与网页进行交互. 这更紧密地模仿了您的用户使用您的网站和应用程序的方式. 此外, WebDriver提供了高级的用户交互API, 使您可以为与网站的复杂交互建模. 浏览器供应商的支持. Opera, Mozilla和Google都是WebDriver开发的积极参与者, 并且各自都有工程师致力于改善框架. 通常, 这意味着对WebDriver的支持已包含在浏览器本身中： 您的测试运行得尽可能快且稳定. 在开始之前 为了使迁移过程尽可能轻松, 请确保所有测试都在最新的Selenium版本中正常运行. 这听起来似乎显而易见, 但是最好说一下!
开始上手 开始迁移的第一步是更改获取Selenium实例的方式. 使用Selenium RC时, 就像这样:
Selenium selenium = new DefaultSelenium(&amp;#34;localhost&amp;#34;, 4444, &amp;#34;*firefox&amp;#34;, &amp;#34;http://www.yoursite.com&amp;#34;); selenium.start(); 应该这样替换:
WebDriver driver = new FirefoxDriver(); Selenium selenium = new WebDriverBackedSelenium(driver, &amp;#34;http://www.</description></item><item><title>服务网格 3</title><link>https://www.selenium.dev/zh-cn/documentation/legacy/selenium_3/grid_3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/legacy/selenium_3/grid_3/</guid><description>服务网格 4
Most of the documentation found in this section is still in English. Please note we are not accepting pull requests to translate this content as translating documentation of legacy components does not add value to the community nor the project. Selenium服务网格 是一个能够让Selenium的测试把命令传送到一个远程浏览器实例的职能代理服务器。 他的目的是提供一个简便的方法来在多台终端上并行的执行测试任务。
在Selenium服务网格, 一台服务器作为转发器(hub)将JSON格式的测试命令转发到1台或多台注册的节点。 测试任务通过跟转发器(hub)的交互来操作远端浏览器实例。 转发器(hub)维护了一个可供使用的注册服务器列表，也允许我们通过转发器(hub)来控制这些实例。
Selenium服务网格允许我们在多台节点服务器上并行执行测试， 同时也中心化的管理多个浏览器版本，多种浏览器的配置。（以替代传统的基于个人的测试）
Selenium服务网格并不是万能的(silver bullet)。 它能够解决一些通用的代理问题和分布式的问题，但是并不能管理你的硬件，也可能不适合你的一些特殊需求。</description></item><item><title>命令监听器</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/support_features/listeners/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/support_features/listeners/</guid><description>允许您在每次发送特定 Selenium 命令时执行自定义操作
Java Python CSharp Ruby JavaScript Kotlin Add Example
Add Example
Add Example
Add Example
Add Example
Add Example</description></item><item><title>键盘操作</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/actions_api/keyboard/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/actions_api/keyboard/</guid><description>只有 2 个操作可以使用键盘完成: 按下某个键，以及释放一个按下的键. 除了支持 ASCII 字符外，每个键盘按键还具有 可以按特定顺序按下或释放的表现形式.
按键 除了由常规unicode表示的按键， 其他键盘按键被分配了一些unicode值以用于操作Selenium 每种语言都有自己的方式来援引这些按键; 这里 可以找到完整列表
Java Python CSharp Ruby JavaScript Kotlin Use the Java Keys enum
Use the Python Keys class
Use the .NET static Keys class
Use the Ruby KEYS constant
Use the JavaScript KEYS constant
Use the Java Keys enum
按下按键 Java Python CSharp Ruby JavaScript Kotlin new Actions(driver) .keyDown(Keys.SHIFT) .sendKeys(&amp;#34;a&amp;#34;) .perform(); View full example on GitHub ActionChains(driver)\ .key_down(Keys.SHIFT)\ .</description></item><item><title>Web元素交互</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/elements/interactions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/elements/interactions/</guid><description>仅有五种基本命令可用于元素的操作:
点击 (适用于任何元素) 发送键位 (仅适用于文本字段和内容可编辑元素) 清除 (仅适用于文本字段和内容可编辑元素) 提交 (仅适用于表单元素) 选择 (参见 选择列表元素) 附加验证 这些方法的设计目的是尽量模拟用户体验, 所以, 与 Actions接口 不同, 在指定制定操作之前, 会尝试执行两件事.
如果它确定元素在视口之外, 则会将元素滚动到视图中, 特别是将元素底部与视口底部对齐. 确保元素在执行操作之前是可交互的 . 这可能意味着滚动不成功, 或者该元素没有以其他方式显示.
确定某个元素是否显示在页面上太难了 无法直接在webdriver规范中定义, 因此Selenium发送一个带有JavaScript原子的执行命令, 检查是否有可能阻止该元素显示. 如果确定某个元素不在视口中, 不显示, 不可 键盘交互, 或不可 指针交互, 则返回一个元素不可交互 错误. 点击 元素点击命令 执行在 元素中央. 如果元素中央由于某些原因被 遮挡 , Selenium将返回一个 元素点击中断 错误.
Java Python CSharp Ruby JavaScript Kotlin driver.get(&amp;#34;https://www.selenium.dev/selenium/web/inputs.html&amp;#34;); // Click on the element WebElement checkInput=driver.findElement(By.name(&amp;#34;checkbox_input&amp;#34;)); checkInput.click(); View full example on GitHub # Navigate to url driver.</description></item><item><title>JavaScript 警告框,提示框和确认框</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/interactions/alerts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/interactions/alerts/</guid><description>WebDriver提供了一个API, 用于处理JavaScript提供的三种类型的原生弹窗消息. 这些弹窗由浏览器提供限定的样式.
Alerts 警告框 其中最基本的称为警告框, 它显示一条自定义消息, 以及一个用于关闭该警告的按钮, 在大多数浏览器中标记为&amp;quot;确定&amp;quot;(OK). 在大多数浏览器中, 也可以通过按&amp;quot;关闭&amp;quot;(close)按钮将其关闭, 但这始终与“确定”按钮具有相同的作用. 查看样例警告框.
WebDriver可以从弹窗获取文本并接受或关闭这些警告.
Java Python CSharp Ruby JavaScript Kotlin Alert alert = driver.switchTo().alert(); //Store the alert text in a variable and verify it String text = alert.getText(); assertEquals(text, &amp;#34;Sample Alert&amp;#34;); //Press the OK button View full example on GitHub element = driver.find_element(By.LINK_TEXT, &amp;#34;See an example alert&amp;#34;) element.click() wait = WebDriverWait(driver, timeout=2) alert = wait.until(lambda d : d.switch_to.alert) text = alert.</description></item><item><title>Selenium Grid快速起步</title><link>https://www.selenium.dev/zh-cn/documentation/grid/getting_started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/grid/getting_started/</guid><description>Page being translated from English to Chinese. Do you speak Chinese? Help us to translate it by sending us pull requests! 快速开始 先决条件 需要安装 Java 11 或更高版本 需要安装浏览器 需要安装浏览器驱动程序 Selenium Manager will configure the drivers automatically if you add --selenium-manager true. 需要已经安装并配置了 PATH 环境变量 从最新的发布版本下载 Selenium Server jar 文件 启动 Grid java -jar selenium-server-&amp;lt;version&amp;gt;.jar standalone 将您的 WebDriver 测试指向 http://localhost:4444 (可选) 通过在浏览器中打开 http://localhost:4444 检查正在运行的测试和可用的功能 *想知道如何将您的测试指向 http://localhost:4444吗? 请查看 RemoteWebDriver section。
要了解更多不同的配置选项，请查看以下各小节。</description></item><item><title>深度介绍</title><link>https://www.selenium.dev/zh-cn/documentation/overview/details/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/overview/details/</guid><description>Selenium 控制网页浏览器 Selenium 有很多功能， 但其核心是 web 浏览器自动化的一个工具集， 它使用最好的技术来远程控制浏览器实例， 并模拟用户与浏览器的交互。
它允许用户模拟终端用户执行的常见活动；将文本输入到字段中，选择下拉值和复选框，并单击文档中的链接。 它还提供许多其他控件，比如鼠标移动、任意 JavaScript 执行等等。
虽然 Selenium 主要用于网站的前端测试，但其核心是浏览器用户代理库。 这些接口在应用程序中无处不在，它们鼓励与其他库进行组合，以满足您的目的。
一个接口来统治它们 该项目的指导原则之一是支持所有（主要）浏览器技术的通用接口。 Web 浏览器是非常复杂的，高度工程化的应用程序， 以完全不同的方式执行它们的操作，但是在执行这些操作时，它们通常看起来是一样的 即使文本以相同的字体呈现，图像也会显示在相同的位置，并且链接会将您带到相同的目的地。 下面发生的事情就像白天和黑夜一样不同。 Selenium “抽象”了这些差异，向编写代码的人隐藏了它们的细节和复杂性。 这允许您编写几行代码来执行一个复杂的工作流程， 但是这几行代码将在 Firefox、 Internet Explorer、 Chrome 和所有其他支持的浏览器上执行。
工具和支持 Selenium 的极简设计方法使其具有通用性，可以作为更大应用程序中的组件。 Selenium 保护伞下提供的周边基础设施为您提供了组合自己的 浏览器 grid 的工具， 因此测试就可以跨一系列机器在不同的浏览器和多个操作系统上运行。
想象一下， 服务器机房或数据中心的一组计算机同时启动浏览器，访问站点的链接、表单和表格 — 全天 24 小时测试应用程序。 通过为最常见的语言提供的简单编程接口， 这些测试将不知疲倦地并行运行， 当错误发生时向您报告。
通过为用户提供工具和文档， 不仅可以控制浏览器， 还可以方便地扩展和部署这些grid， 从而帮助您实现这一目标。
谁在使用 Selenium 世界上许多最重要的公司都在基于浏览器的测试中采用了 Selenium， 这常常取代了多年来涉及其他专有工具的工作。 随着它越来越受欢迎， 它的需求和挑战也成倍增加。
随着网络变得越来越复杂，新的技术被添加到网站上， 这个项目的任务就是尽可能地跟上它们。 作为一个开源项目，这种支持是通过许多志愿者的慷慨捐赠来提供的， 每个志愿者都有一份“日常工作”。
该项目的另一个任务是鼓励更多的志愿者参与到这项工作中来， 并建立一个强大的社区，以便项目能够继续跟上新兴的技术， 并继续成为功能测试自动化的主导平台。</description></item><item><title>为 Selenium 文档做贡献</title><link>https://www.selenium.dev/zh-cn/documentation/about/contributing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/about/contributing/</guid><description>Selenium是一个大型软件项目, 其网站和文档是了解事情如何工作以及学习有效利用其潜力的关键.
该项目包含Selenium的网站和文档. 这是一项持续的工作(不针对任何特定版本), 用于提供有效使用Selenium、 如何参与以及如何为Selenium做出贡献的更新信息.
对网站和文档的贡献遵循以下部分中有关贡献的描述.
Selenium项目欢迎每一个人的贡献. 您可以通过多种方式提供帮助:
上报问题 在报告新问题或评论现有问题时, 请确保讨论与Selenium的软件、 其站点与文档的具体技术问题相关.
随着时间的推移, 所有Selenium组件的变化都非常快, 因此这可能会导致文档过时. 如前所述, 如果您确实遇到这种情况, 请不要为此担心. 您也可能知道如何更新文档, 因此请向我们发送包含相关更改的Pull Request.
如果不确定所发现的问题是否存在, 请通过以下沟通渠道进行描述 https://selenium.dev/support.
What to Help With Creating Examples Examples that need to be moved are marked with:
Add Example
We want to be able to run all of our code examples in the CI to ensure that people can copy and paste and execute everything on the site.</description></item><item><title>文件下载</title><link>https://www.selenium.dev/zh-cn/documentation/test_practices/discouraged/file_downloads/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/test_practices/discouraged/file_downloads/</guid><description>虽然可以通过在Selenium的控制下单击浏览器的链接来开始下载, 但是API并不会暴露下载进度, 因此这是一种不理想的测试下载文件的方式. 因为下载文件并非模拟用户与Web平台交互的重要方面. 取而代之的是, 应使用Selenium(以及任何必要的cookie)查找链接, 并将其传递给例如libcurl这样的HTTP请求库.
HtmlUnit driver 可以通过实现AttachmentHandler 接口将附件作为输入流进行访问来下载附件. 可以将AttachmentHandler添加到 HtmlUnit WebClient.</description></item><item><title>浏览器选项</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/drivers/options/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/drivers/options/</guid><description>在 Selenium 3 中, capabilities是借助&amp;quot;Desired Capabilities&amp;quot;类定义于会话中的. 从 Selenium 4 开始, 您必须使用浏览器选项类. 对于远程驱动程序会话, 浏览器选项实例是必需的, 因为它确定将使用哪个浏览器.
这些选项在 Capabilities 的 w3c 规范中进行了描述.
每个浏览器都有 自定义选项 , 是规范定义之外的内容.
browserName 默认情况下，使用 Options 类实例时会设置浏览器名称.
Java Python CSharp Ruby JavaScript Kotlin ChromeOptions chromeOptions = new ChromeOptions(); String name = chromeOptions.getBrowserName(); View full example on GitHub options = webdriver.ChromeOptions() View full example on GitHub Add Example
options = Selenium::WebDriver::Options.chrome View full example on GitHub Add Example
Add Example
browserVersion 此功能是可选的，用于在远程端设置可用的浏览器版本.</description></item><item><title>Grid端点</title><link>https://www.selenium.dev/zh-cn/documentation/grid/advanced_features/endpoints/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/grid/advanced_features/endpoints/</guid><description>Grid Grid 状态 Grid状态提供Grid的当前状态. 它包含每个注册节点的详细信息. 对于每个节点, 状态包括有关节点可用性、会话和插槽的信息.
cURL GET &amp;#39;http://localhost:4444/status&amp;#39; 检查会话所有者 要检查会话是否属于某一节点, 请使用下面列出的cURL命令.
cURL --request DELETE &amp;#39;http://localhost:4444/session/&amp;lt;session-id&amp;gt;&amp;#39; Which URL should I use? 在独立模式下, Grid URL是独立服务器的地址.
在集线器节点模式下, Grid URL是集线器服务器的地址.
在完全分布式模式下, Grid URL是路由服务器的地址.
以上所有模式的默认URL皆为http://localhost:4444.
分发器 删除节点 要从Grid中删除节点, 请使用下面列出的cURL命令. 它不会停止在该节点上运行的任何持续中的会话. 除非显式终止, 否则节点将继续按原样运行. 分发器不再知晓该节点, 因此任何匹配的新会话请求 也不会转发到该节点.
在独立模式下, 分发器URL是独立服务器的地址.
在集线器节点模式下, 分发器URL是集线器服务器的地址.
cURL --request DELETE &amp;#39;http://localhost:4444/se/grid/distributor/node/&amp;lt;node-id&amp;gt;&amp;#39; --header &amp;#39;X-REGISTRATION-SECRET: &amp;lt;secret&amp;gt; &amp;#39; 在完全分布式模式下, URL是分发器的地址.
cURL --request DELETE &amp;#39;http://localhost:4444/se/grid/distributor/node/&amp;lt;node-id&amp;gt;&amp;#39; --header &amp;#39;X-REGISTRATION-SECRET: &amp;lt;secret&amp;gt;&amp;#39; 如果在设置Grid时未配置注册密码, 则使用
cURL --request DELETE &amp;#39;http://&amp;lt;Router-URL&amp;gt;/se/grid/distributor/node/&amp;lt;node-id&amp;gt;&amp;#39; --header &amp;#39;X-REGISTRATION-SECRET;&amp;#39; 放空节点 节点放空命令用于优雅地关闭节点.</description></item><item><title>HTTP Client Configuration</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/drivers/http_client/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/drivers/http_client/</guid><description>允许您为HTTP库设置各种参数.
Java Python CSharp Ruby JavaScript Kotlin Add Example
Add Example
Add Example
client = Selenium::WebDriver::Remote::Http::Default.new(open_timeout: 30, read_timeout: 30) expect(client.open_timeout).to eq 30 View full example on GitHub Add Example
Add Example</description></item><item><title>HTTP响应码</title><link>https://www.selenium.dev/zh-cn/documentation/test_practices/discouraged/http_response_codes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/test_practices/discouraged/http_response_codes/</guid><description>对于Selenium RC中的某些浏览器配置， Selenium充当了浏览器和自动化站点之间的代理. 这意味着可以捕获或操纵通过Selenium传递的所有浏览器流量. captureNetworkTraffic() 方法旨在捕获浏览器和自动化站点之间的所有网络流量，包括HTTP响应码.
Selenium WebDriver是一种完全不同的浏览器自动化实现， 它更喜欢表现得像用户一样，这种方式来自于基于WebDriver编写测试的方式. 在自动化功能测试中，检查状态码并不是测试失败的特别重要的细节, 之前的步骤更重要.
浏览器将始终呈现HTTP状态代码，例如404或500错误页面. 遇到这些错误页面时，一种“快速失败”的简单方法是 在每次加载页面后检查页面标题或可信赖点的内容（例如 &amp;lt;h1&amp;gt; 标签）. 如果使用的是页面对象模型，则可以将此检查置于类构造函数中或类似于期望的页面加载的位置. 有时，HTTP代码甚至可能出现在浏览器的错误页面中， 您可以使用WebDriver读取此信息并改善调试输出.
检查网页本身的一种理想实践是符合WebDriver的呈现以及用户的视角.
如果您坚持，捕获HTTP状态代码的高级解决方案是复刻Selenium RC的行为去使用代理. WebDriver API提供了为浏览器设置代理的功能， 并且有许多代理可以通过编程方式来操纵发送到Web服务器和从Web服务器接收的请求的内容. 使用代理可以决定如何响应重定向响应代码. 此外，并非每个浏览器都将响应代码提供给WebDriver， 因此选择使用代理可以使您拥有适用于每个浏览器的解决方案.</description></item><item><title>PO设计模式</title><link>https://www.selenium.dev/zh-cn/documentation/test_practices/encouraged/page_object_models/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/test_practices/encouraged/page_object_models/</guid><description>Note: this page has merged contents from multiple sources, including the Selenium wiki
Overview Within your web app&amp;rsquo;s UI, there are areas where your tests interact with. A Page Object only models these as objects within the test code. This reduces the amount of duplicated code and means that if the UI changes, the fix needs only to be applied in one place.
Page Object is a Design Pattern that has become popular in test automation for enhancing test maintenance and reducing code duplication.</description></item><item><title>Selenium Manager (Beta)</title><link>https://www.selenium.dev/zh-cn/documentation/selenium_manager/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/selenium_manager/</guid><description>Motivation TL;DR: Selenium Manager is the official driver manager of the Selenium project, and it is shipped out of the box with every Selenium release.
Selenium uses the native support implemented by each browser to carry out the automation process. For this reason, Selenium users need to place a component called driver (chromedriver, geckodriver, msedgedriver, etc.) between the script using the Selenium API and the browser. For many years, managing these drivers was a manual process for Selenium users.</description></item><item><title>Toml配置选项</title><link>https://www.selenium.dev/zh-cn/documentation/grid/configuration/toml_options/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/grid/configuration/toml_options/</guid><description>CLI选项 中 显示的所有选项都可以通过 TOML 文件进行配置. 此页面显示不同Grid组件的配置示例.
请注意, 如果修改或添加了选项, 但尚未记录, 则此文档可能已过时. 如果您遇到这种情况, 请查看 &amp;ldquo;配置帮助&amp;rdquo; 部分, 并随时向我们发送更新此页面的请求.
概述 Selenium Grid对配置文件使用 TOML 格式. 配置文件由多个部分组成, 每个部分都有选项及其各自的值.
有关详细的使用指南, 请参阅TOML文档 . 如果出现解析错误, 请使用 TOML linter 验证配置.
一般配置结构具有以下模式:
[section1] option1=&amp;#34;value&amp;#34; [section2] option2=[&amp;#34;value1&amp;#34;,&amp;#34;value2&amp;#34;] option3=true 下面是一些使用Toml文件配置的 Grid组件示例, 该组件可以 从下面的方式开始:
java -jar selenium-server-&amp;lt;version&amp;gt;.jar &amp;lt;component&amp;gt; --config /path/to/file/&amp;lt;file-name&amp;gt;.toml 单机模式 单机服务器, 在端口4449上运行, 新会话请求超时500秒.
[server] port = 4449 [sessionqueue] session-request-timeout = 500 特定浏览器和最大会话数限制 默认情况下仅启用Firefox 和Chrome的单机服务器或节点.
[node] drivers = [&amp;#34;chrome&amp;#34;, &amp;#34;firefox&amp;#34;] max-sessions = 3 配置和定制驱动程序 具有定制驱动程序的单机或节点服务器, 允许使用Firefox试用或者每日构建的功能, 并且有不同的浏览器版本.</description></item><item><title>驱动服务类</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/drivers/service/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/drivers/service/</guid><description>服务类用于管理驱动程序的启动和停止. 它们不能与远程 WebDriver 会话一起使用.
服务类允许您指定有关驱动程序的信息, 诸如位置和要使用的端口. 它们还允许您指定传递哪些参数到命令行. 大多数有用的参数都与日志记录有关.
默认服务实例 使用默认服务实例启动驱动程序:
Java Python CSharp Ruby JavaScript Kotlin ChromeDriverService service = new ChromeDriverService.Builder().build(); driver = new ChromeDriver(service); View full example on GitHub Selenium v4.11
service = webdriver.ChromeService() driver = webdriver.Chrome(service=service) View full example on GitHub var service = ChromeDriverService.CreateDefaultService(); driver = new ChromeDriver(service); View full example on GitHub service = Selenium::WebDriver::Service.chrome @driver = Selenium::WebDriver.for :chrome, service: service View full example on GitHub Add Example</description></item><item><title>同颜色一起工作</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/support_features/colors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/support_features/colors/</guid><description>在测试中, 您偶尔会需要验证某事物的颜色；问题是网络上的颜色定义不是个常量. 如果有一种简单的方法可以比较颜色的十六进制与RGB呈现, 或者颜色的RGBA与HSLA呈现, 岂不美哉?
不用担心有一个解决方案：Color 类!
首先, 您需要导入该类:
Java Python CSharp Ruby JavaScript Kotlin import org.openqa.selenium.support.Color; from selenium.webdriver.support.color import Color // This feature is not implemented - Help us by sending a pr to implement this feature include Selenium::WebDriver::Support // This feature is not implemented - Help us by sending a pr to implement this feature import org.openqa.selenium.support.Color 您现在可以开始创建颜色对象. 每个颜色对象都需要使用您颜色的字符串定义来创建. 支持的颜色定义如下:
Java Python CSharp Ruby JavaScript Kotlin private final Color HEX_COLOUR = Color.</description></item><item><title>Chrome 特定功能</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/browsers/chrome/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/browsers/chrome/</guid><description>默认情况下，Selenium 4与Chrome v75及更高版本兼容. 但是请注意Chrome浏览器的版本与chromedriver的主版本需要匹配.
Options 所有浏览器的通用功能请看这 Options page.
Chrome浏览器的特有功能可以在谷歌的页面找到: Capabilities &amp;amp; ChromeOptions
基于默认选项的Chrome浏览器会话看起来是这样:
Java Python CSharp Ruby JavaScript Kotlin ChromeOptions options = new ChromeOptions(); driver = new ChromeDriver(options); View full example on GitHub options = webdriver.ChromeOptions() driver = webdriver.Chrome(options=options) View full example on GitHub var options = new ChromeOptions(); driver = new ChromeDriver(options); View full example on GitHub options = Selenium::WebDriver::Options.chrome @driver = Selenium::WebDriver.for :chrome, options: options View full example on GitHub .</description></item><item><title>同cookies一起工作</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/interactions/cookies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/interactions/cookies/</guid><description>Cookie是从网站发送并存储在您的计算机中的一小段数据. Cookies主要用于识别用户并加载存储的信息.
WebDriver API提供了一种使用内置的方法与Cookie进行交互:
添加 Cookie 这个方法常常用于将cookie添加到当前访问的上下文中. 添加Cookie仅接受一组已定义的可序列化JSON对象. 这里 是一个链接, 用于描述可接受的JSON键值的列表
首先, 您需要位于有效Cookie的域上. 如果您在开始与网站进行交互之前尝试预设cookie, 并且您的首页很大或需要一段时间才能加载完毕, 则可以选择在网站上找到一个较小的页面 (通常404页很小, 例如 http://example.com/some404page)
Java Python CSharp Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class addCookie { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(&amp;#34;http://www.example.com&amp;#34;); // Adds the cookie into current browser context driver.manage().addCookie(new Cookie(&amp;#34;key&amp;#34;, &amp;#34;value&amp;#34;)); } finally { driver.quit(); } } } from selenium import webdriver driver = webdriver.</description></item><item><title>Customizing a Node</title><link>https://www.selenium.dev/zh-cn/documentation/grid/advanced_features/customize_node/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/grid/advanced_features/customize_node/</guid><description>Page being translated from English to Chinese. Do you speak Chinese? Help us to translate it by sending us pull requests! How to customize a Node There are times when we would like a Node to be customized to our needs.
For e.g., we may like to do some additional setup before a session begins execution and some clean-up after a session runs to completion.
Following steps can be followed for this:</description></item><item><title>Unable to Locate Driver Error</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/troubleshooting/errors/driver_location/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/troubleshooting/errors/driver_location/</guid><description>Historically, this is the most common error beginning Selenium users get when trying to run code for the first time:
Java Python CSharp Ruby The path to the driver executable must be set by the webdriver.chrome.driver system property; for more information, see https://chromedriver.chromium.org/. The latest version can be downloaded from https://chromedriver.chromium.org/downloads The executable chromedriver needs to be available in the path. The file geckodriver does not exist. The driver can be downloaded at https://github.</description></item><item><title>Gmail, email 和 Facebook 登录</title><link>https://www.selenium.dev/zh-cn/documentation/test_practices/discouraged/gmail_email_and_facebook_logins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/test_practices/discouraged/gmail_email_and_facebook_logins/</guid><description>由于多种原因, 不建议使用WebDriver登录Gmail和Facebook等网站. 除了违反这些网站的使用条款之外 (您可能会面临帐户被关闭的风险) , 还有其运行速度缓慢且不可靠的因素.
理想的做法是使用电子邮件供应商提供的API, 或者对于Facebook, 使用开发者工具的服务, 该服务是被用于创建测试帐户、朋友等内容的API. 尽管使用API可能看起来有些额外的工作量, 但是您将获得基于速度、可靠性和稳定性的回报. API不会频繁更改, 但是网页和HTML定位符经常变化, 并且需要您更新测试框架的代码.
在任何时候测试使用WebDriver登录第三方站点, 都会增加测试失败的风险, 因为这会使您的测试时间更长. 通常的经验是, 执行时间较长的测试会更加脆弱和不可靠.
符合W3C conformant 的WebDriver实现, 也会使用 WebDriver 的属性对 navigator 对象进行注释, 用于缓解拒绝服务的攻击.</description></item><item><title>Mouse actions</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/actions_api/mouse/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/actions_api/mouse/</guid><description>一个鼠标仅可以完成3个操作： 按住按钮，松开按钮，还有移动光标。 Selenium组合了常见的操作并提供了方便的方法。
按住鼠标左键 这个方法包含2个操作，首先将光标移动到被操作元素的正中心，然后按下鼠标左键不松开。 这对于聚焦一个特殊元素很有用：
Java Python CSharp Ruby JavaScript Kotlin WebElement clickable = driver.findElement(By.id(&amp;#34;clickable&amp;#34;)); new Actions(driver) .clickAndHold(clickable) .perform(); View full example on GitHub clickable = driver.find_element(By.ID, &amp;#34;clickable&amp;#34;) ActionChains(driver)\ .click_and_hold(clickable)\ .perform() View full example on GitHub IWebElement clickable = driver.FindElement(By.Id(&amp;#34;clickable&amp;#34;)); new Actions(driver) .ClickAndHold(clickable) .Perform(); View full example on GitHub clickable = driver.find_element(id: &amp;#39;clickable&amp;#39;) driver.action .click_and_hold(clickable) .perform View full example on GitHub let clickable = driver.findElement(By.id(&amp;#34;clickable&amp;#34;)); const actions = driver.actions({async: true}); await actions.</description></item><item><title>Chrome DevTools Network Features</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/bidi/cdp/network/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/bidi/cdp/network/</guid><description>Page being translated from English to Chinese. Do you speak Chinese? Help us to translate it by sending us pull requests! While Selenium 4 provides direct access to the Chrome DevTools Protocol, these methods will eventually be removed when WebDriver BiDi implemented.
Basic authentication Some applications make use of browser authentication to secure pages. It used to be common to handle them in the URL, but browsers stopped supporting this.</description></item><item><title>定位策略</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/elements/locators/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/elements/locators/</guid><description>定位器是在页面上标识元素的一种方法。它是传送给 查找元素 方法的参数。
查看 鼓励测试练习 寻找 定位器的小技巧， 包含在查找方法中，不同时间，不同原因下，单独声明的定位器的使用方法。
元素选择策略 在 WebDriver 中有 8 种不同的内置元素定位策略：
定位器 Locator 描述 class name 定位class属性与搜索值匹配的元素（不允许使用复合类名） css selector 定位 CSS 选择器匹配的元素 id 定位 id 属性与搜索值匹配的元素 name 定位 name 属性与搜索值匹配的元素 link text 定位link text可视文本与搜索值完全匹配的锚元素 partial link text 定位link text可视文本部分与搜索值部分匹配的锚点元素。如果匹配多个元素，则只选择第一个元素。 tag name 定位标签名称与搜索值匹配的元素 xpath 定位与 XPath 表达式匹配的元素 Creating Locators To work on a web element using Selenium, we need to first locate it on the web page. Selenium provides us above mentioned ways, using which we can locate element on the page.</description></item><item><title>领域特定语言</title><link>https://www.selenium.dev/zh-cn/documentation/test_practices/encouraged/domain_specific_language/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/test_practices/encouraged/domain_specific_language/</guid><description>领域特定语言 (DSL) 是一种为用户提供解决问题的表达方式的系统. 它使用户可以按照自己的术语与系统进行交互, 而不仅仅是通过程序员的语言.
您的用户通常并不关心您网站的外观. 他们不在乎装饰, 动画或图形. 他们希望借助于您的系统, 以最小的难度使新员工融入整个流程； 他们想预订去阿拉斯加的旅行； 他们想以折扣价配置和购买独角兽. 您作为测试人员的工作应尽可能接近&amp;quot;捕捉”这种思维定势. 考虑到这一点, 我们开始着手&amp;quot;建模”您正在工作的应用程序, 以使测试脚本 (发布前用户仅有的代理) &amp;ldquo;说话”并代表用户.
在Selenium中, DSL通常由方法表示, 其编写方式使API简单易读-它们使开发人员和干系人 (用户, 产品负责人, 商业智能专家等) 之间能够产生汇报.
好处 可读: 业务关系人可以理解. 可写: 易于编写, 避免不必要的重复. 可扩展: 可以 (合理地) 添加功能而无需打破约定以及现有功能. 可维护: 通过将实现细节排除在测试用例之外, 您可以很好地隔离 AUT* 的修改. Java 以下是Java中合理的DSL方法的示例. 为简便起见, 假定 driver 对象是预定义的并且可用于该方法.
/** * Takes a username and password, fills out the fields, and clicks &amp;#34;login&amp;#34;. * @return An instance of the AccountPage */ public AccountPage loginAsUser(String username, String password) { WebElement loginField = driver.</description></item><item><title>配置自己的服务网格</title><link>https://www.selenium.dev/zh-cn/documentation/legacy/selenium_3/grid_setup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/legacy/selenium_3/grid_setup/</guid><description>使用Selenium网格， 你需要维护你自己的基础设置来作为节点使用， 这将是一个繁重的紧张的工作，很多组织使用IaaS供应商比如Amazon EC2或者Google来提供这些基础设施。
使用Sauce Labs或者Testing Bot这类提供了Selenium网格作为云服务的供应商也是一个选择。 当然，在你自己的硬件群运行节点也是可行的。 这一章会深入探讨如何用你自己的基础设施来运行你的服务网格，
快速开始 这个例子会向你展示如何开始Selenium 2服务网格的转发器(hub), 然后注册WebDriver节点和Selenium 1 RC节点。 我们也会向你展示如何使用Java来使用Selenium服务网格。 这个例子里转发器和节点被运行在了同一台终端机上，当然你也可以服务selenium-server-standalone到 多台终端机。
selenium-server-standalone 包含了运行网格所需要的转发器(hub),WebDriver和legacy RC needed, _ant_已经不是必须的了. 你可以在https://selenium.dev/downloads/.下载 selenium-server-standalone.jar
第一步: 启动转发器(hub) 转发器(hub)是接受测试请求并分发到合适的节点的中心点。 分发是基于节点的能力的，这就意味着一个有特定需求的测试仅会被分发到能提供这个需求的节点上。
因为一个测试所期望的能力，就如字面意思，期望，并不代表转发器(hub)能够找到一个真正满足所有期望的节点。
打开命令行窗口，来到存放selenium-server-standalone.jar文件的地方。 启动转发器(hub)并传入-role hub作为参数来启动一个独立的服务：
java -jar selenium-server-standalone.jar -role hub 转发器(hub)默认会监听4444端口，你也可以通过打开浏览器访问http://localhost:4444/grid/console来查看转发器(hub)的状态。
如果需要改变默认端口，你可以添加-port加上一个数字作为参数来代表你期望监听的端口， 同时，所有其他的可选参数都可以在下面这个JSON配置文件里找到。
你已经在上面获得了一个简单命令，当然如果你希望一些更高级的配置， 方便起见，你也可以指定一个JSON格式的配置文件来配置并启动你的转发器(hub)。 你可以这么做：
java -jar selenium-server-standalone.jar -role hub -hubConfig hubConfig.json -debug 下面你可以看到一个配置文件hubConfig.json的例子。 我们会在第二步深入探讨怎么来提供节点配置文件。
{ &amp;#34;_comment&amp;#34; : &amp;#34;Configuration for Hub - hubConfig.json&amp;#34;, &amp;#34;host&amp;#34;: ip, &amp;#34;maxSession&amp;#34;: 5, &amp;#34;port&amp;#34;: 4444, &amp;#34;cleanupCycle&amp;#34;: 5000, &amp;#34;timeout&amp;#34;: 300000, &amp;#34;newSessionWaitTimeout&amp;#34;: -1, &amp;#34;servlets&amp;#34;: [], &amp;#34;prioritizer&amp;#34;: null, &amp;#34;capabilityMatcher&amp;#34;: &amp;#34;org.</description></item><item><title>记录 Selenium 命令</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/troubleshooting/logging/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/troubleshooting/logging/</guid><description>启用日志记录是获取额外信息的宝贵方法, 这些信息可能有助于您确定 遇到问题的原因.
获取一个logger Java Python CSharp Ruby JavaScript Kotlin Java 日志通常是按类创建的. 您可以通过默认logger来使用所有loggers. 为了过滤特定类, 请参考 过滤器
获取根logger:
Logger logger = Logger.getLogger(&amp;#34;&amp;#34;); View full example on GitHub Java日志并不简单直接, 如果您只是在寻找一种简单的方法 查看重要的Selenium日志, 请参阅 Selenium Logger 项目
Python logs are typically created per module. You can match all submodules by referencing the top level module. So to work with all loggers in selenium module, you can do this:
logger = logging.getLogger(&amp;#39;selenium&amp;#39;) View full example on GitHub .</description></item><item><title>什么时候应该使用Grid</title><link>https://www.selenium.dev/zh-cn/documentation/grid/applicability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/grid/applicability/</guid><description>Page being translated from English to Chinese. Do you speak Chinese? Help us to translate it by sending us pull requests! 什么情况下可以使用 Selenium Grid ？
想要在不同的浏览器类型、浏览器版本和操作系统上并行运行测试时 想要缩短执行测试案例所需的时间 Selenium Grid 可以并行地在多台计算机（称为节点）上运行测试案例。对于大型和长时间运行的测试案例，这可以节省几分钟、几小时甚至几天的时间。
这有效的缩短了测试结果的反馈时间，使得在测试的应用程序发生变化时能够更快地得到测试结果。
Grid 可以并行地运行测试，支持多种不同的浏览器类型，并且可以同时运行多个相同浏览器的实例。
举个例子，假设一个拥有六个节点的Grid。第一台计算机拥有Firefox的最新版本，第二台拥有Firefox的上一个版本，第三台运行最新版Chrome，而其余三台机器是Mac Mini，允许在最新版本的Safari上并行运行三个测试。
执行时间可以用一个简单的公式来表示：
测试次数 × 平均测试时间 / 节点数 = 总执行时间
15 * 45s / 1 = 11m 15s // Without Grid 15 * 45s / 5 = 2m 15s // Grid with 5 Nodes 15 * 45s / 15 = 45s // Grid with 15 Nodes 100 * 120s / 15 = 13m 20s // Would take over 3 hours without Grid 在测试案例执行时，Grid 会按照测试配置将测试分配到相应的浏览器上运行。</description></item><item><title>关于网络元素的信息</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/elements/information/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/elements/information/</guid><description>您可以查询有关特定元素的许多详细信息。
是否显示 此方法用于检查连接的元素是否正确显示在网页上. 返回一个 Boolean 值， 如果连接的元素显示在当前的浏览器上下文中，则为True，否则返回false。
此功能于W3C规范中提及， 但由于无法覆盖所有潜在条件而无法定义。 因此，Selenium不能期望驱动程序直接实现这种功能，现在依赖于直接执行大量JavaScript函数。 这个函数对一个元素的性质和在树中的关系做了许多近似的判断，以返回一个值。
Java Python CSharp Ruby JavaScript Kotlin driver.get(&amp;#34;https://www.selenium.dev/selenium/web/inputs.html&amp;#34;); // isDisplayed // Get boolean value for is element display boolean isEmailVisible = driver.findElement(By.name(&amp;#34;email_input&amp;#34;)).isDisplayed(); assertEquals(isEmailVisible,true); View full example on GitHub # Navigate to the url driver.get(&amp;#34;https://www.selenium.dev/selenium/web/inputs.html&amp;#34;) # Get boolean value for is element display is_email_visible = driver.find_element(By.NAME, &amp;#34;email_input&amp;#34;).is_displayed() &amp;lt;div class=&amp;#34;highlight&amp;#34;&amp;gt;&amp;lt;pre tabindex=&amp;#34;0&amp;#34; style=&amp;#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&amp;#34;&amp;gt;&amp;lt;code class=&amp;#34;language-cs&amp;#34; data-lang=&amp;#34;cs&amp;#34;&amp;gt;&amp;lt;span style=&amp;#34;display:flex;&amp;#34;&amp;gt;&amp;lt;span&amp;gt; &amp;lt;span style=&amp;#34;color:#8f5902;font-style:italic&amp;#34;&amp;gt;// Navigate to Url&amp;lt;/span&amp;gt; &amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;#34;display:flex;&amp;#34;&amp;gt;&amp;lt;span&amp;gt; &amp;lt;span style=&amp;#34;color:#000&amp;#34;&amp;gt;driver&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;#34;color:#000;font-weight:bold&amp;#34;&amp;gt;.</description></item><item><title>Edge 特定功能</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/browsers/edge/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/browsers/edge/</guid><description>微软Edge是用Chromium实现的，最早支持版本是v79. 与Chrome类似, Edge驱动的主版本号必须与Edge浏览器的主要版本匹配.
在 Chrome 页面 上找到的所有capabilities和选项也适用于Edge.
选项 Capabilities common to all browsers are described on the Options page.
Capabilities unique to Chromium are documented at Google&amp;rsquo;s page for Capabilities &amp;amp; ChromeOptions
使用基本定义的选项启动 Edge 会话如下所示:
Java Python CSharp Ruby JavaScript Kotlin EdgeOptions options = new EdgeOptions(); driver = new EdgeDriver(options); View full example on GitHub options = webdriver.EdgeOptions() driver = webdriver.Edge(options=options) View full example on GitHub var options = new EdgeOptions(); driver = new EdgeDriver(options); View full example on GitHub options = Selenium::WebDriver::Options.</description></item><item><title>External datastore</title><link>https://www.selenium.dev/zh-cn/documentation/grid/advanced_features/external_datastore/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/grid/advanced_features/external_datastore/</guid><description>Page being translated from English to Chinese. Do you speak Chinese? Help us to translate it by sending us pull requests! Table of Contents Introduction Setup Database backed Session Map Steps Redis backed Session Map Steps Introduction Selenium Grid allows you to persist information related to currently running sessions into an external data store. The external data store could be backed by your favourite database (or) Redis Cache system.</description></item><item><title>Pen actions</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/actions_api/pen/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/actions_api/pen/</guid><description>Chromium Only
A Pen is a type of pointer input that has most of the same behavior as a mouse, but can also have event properties unique to a stylus. Additionally, while a mouse has 5 buttons, a pen has 3 equivalent button states:
0 — Touch Contact (the default; equivalent to a left click) 2 — Barrel Button (equivalent to a right click) 5 — Eraser Button (currently unsupported by drivers) Using a Pen Java Python CSharp Ruby JavaScript Kotlin Selenium v4.</description></item><item><title>测试依赖</title><link>https://www.selenium.dev/zh-cn/documentation/test_practices/discouraged/test_dependency/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/test_practices/discouraged/test_dependency/</guid><description>关于自动化测试的一个常见想法和误解是关于特定的测试顺序. 您的测试应该能够以任何顺序运行，而不是依赖于完成其他测试才能成功.</description></item><item><title>生成应用程序状态</title><link>https://www.selenium.dev/zh-cn/documentation/test_practices/encouraged/generating_application_state/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/test_practices/encouraged/generating_application_state/</guid><description>Selenium不应用于准备测试用例. 测试用例中所有重复性动作和准备工作, 都应通过其他方法来完成.
例如, 大多数Web UI都具有身份验证 (诸如一个登录表单) . 在每次测试之前通过Web浏览器进行登录的消除, 将提高测试的速度和稳定性. 应该创建一种方法来获取对 AUT* 的访问权限 (例如, 使用API登录并设置Cookie) . 此外, 不应使用Selenium创建预加载数据来进行测试的方法.
如前所述, 应利用现有的API为 AUT* 创建数据. *AUT: 待测系统</description></item><item><title>Firefox specific functionality</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/browsers/firefox/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/browsers/firefox/</guid><description>Selenium 4 requires Firefox 78 or greater. It is recommended to always use the latest version of geckodriver.
Options Capabilities common to all browsers are described on the Options page.
Capabilities unique to Firefox can be found at Mozilla&amp;rsquo;s page for firefoxOptions
Starting a Firefox session with basic defined options looks like this:
Java Python CSharp Ruby JavaScript Kotlin FirefoxOptions options = new FirefoxOptions(); driver = new FirefoxDriver(options); View full example on GitHub options = webdriver.</description></item><item><title>与IFrames和frames一起工作</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/interactions/frames/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/interactions/frames/</guid><description>框架是一种现在已被弃用的方法，用于从同一域中的多个文档构建站点布局。除非你使用的是 HTML5 之前的 webapp，否则你不太可能与他们合作。内嵌框架允许插入来自完全不同领域的文档，并且仍然经常使用。
如果您需要使用框架或 iframe, WebDriver 允许您以相同的方式使用它们。考虑 iframe 中的一个按钮。 如果我们使用浏览器开发工具检查元素，我们可能会看到以下内容:
&amp;lt;div id=&amp;#34;modal&amp;#34;&amp;gt; &amp;lt;iframe id=&amp;#34;buttonframe&amp;#34;name=&amp;#34;myframe&amp;#34;src=&amp;#34;https://seleniumhq.github.io&amp;#34;&amp;gt; &amp;lt;button&amp;gt;Click here&amp;lt;/button&amp;gt; &amp;lt;/iframe&amp;gt; &amp;lt;/div&amp;gt; 如果不是 iframe，我们可能会使用如下方式点击按钮:
Java Python CSharp Ruby JavaScript Kotlin // 这不会工作 driver.findElement(By.tagName(&amp;#34;button&amp;#34;)).click(); # 这不会工作 driver.find_element(By.TAG_NAME, &amp;#39;button&amp;#39;).click() // 这不会工作 driver.FindElement(By.TagName(&amp;#34;button&amp;#34;)).Click(); # 这不会工作 driver.find_element(:tag_name,&amp;#39;button&amp;#39;).click // 这不会工作 await driver.findElement(By.css(&amp;#39;button&amp;#39;)).click(); // 这不会工作 driver.findElement(By.tagName(&amp;#34;button&amp;#34;)).click() 但是，如果 iframe 之外没有按钮，那么您可能会得到一个 no such element 无此元素 的错误。 这是因为 Selenium 只知道顶层文档中的元素。为了与按钮进行交互，我们需要首先切换到框架， 这与切换窗口的方式类似。WebDriver 提供了三种切换到帧的方法。
使用 WebElement 使用 WebElement 进行切换是最灵活的选择。您可以使用首选的选择器找到框架并切换到它。
Java Python CSharp Ruby JavaScript Kotlin //switch To IFrame using Web Element WebElement iframe = driver.</description></item><item><title>Chrome DevTools Script Features</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/bidi/cdp/script/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/bidi/cdp/script/</guid><description>Page being translated from English to Chinese. Do you speak Chinese? Help us to translate it by sending us pull requests! While Selenium 4 provides direct access to the Chrome DevTools Protocol, these methods will eventually be removed when WebDriver BiDi implemented.
Script Pinning Java Python CSharp Ruby JavaScript Kotlin ScriptKey key = ((JavascriptExecutor) driver).pin(&amp;#34;return arguments;&amp;#34;); List&amp;lt;Object&amp;gt; arguments = (List&amp;lt;Object&amp;gt;) ((JavascriptExecutor) driver).executeScript(key, 1, true, element); View full example on GitHub Implementation Missing</description></item><item><title>Style guide for Selenium documentation</title><link>https://www.selenium.dev/zh-cn/documentation/about/style/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/about/style/</guid><description>Read our contributing documentation for complete instructions on how to add content to this documentation.
Alerts Alerts have been added to direct potential contributors to where specific content is missing.
{{&amp;lt; alert-content /&amp;gt;}} or
{{&amp;lt; alert-content &amp;gt;}} Additional information about what specific content is needed {{&amp;lt; /alert-content &amp;gt;}} Which gets displayed like this: Content Help Note: This section needs additional and/or updated content Additional information about what specific content is needed Check our contribution guidelines if you&amp;rsquo;d like to help.</description></item><item><title>Scroll wheel actions</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/actions_api/wheel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/actions_api/wheel/</guid><description>Selenium v4.2
Chromium Only
There are 5 scenarios for scrolling on a page.
Scroll to element This is the most common scenario. Unlike traditional click and send keys methods, the actions class does not automatically scroll the target element into view, so this method will need to be used if elements are not already inside the viewport.
This method takes a web element as the sole argument.
Regardless of whether the element is above or below the current viewscreen, the viewport will be scrolled so the bottom of the element is at the bottom of the screen.</description></item><item><title>等待</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/waits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/waits/</guid><description>Perhaps the most common challenge for browser automation is ensuring that the web application is in a state to execute a particular Selenium command as desired. The processes often end up in a race condition where sometimes the browser gets into the right state first (things work as intended) and sometimes the Selenium code executes first (things do not work as intended). This is one of the primary causes of flaky tests.</description></item><item><title>服务网格的组件</title><link>https://www.selenium.dev/zh-cn/documentation/legacy/selenium_3/grid_components/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/legacy/selenium_3/grid_components/</guid><description>转发器(hub) 中间人和管理者 接受请求 执行测试任务 接受客户端的指示并在远程节点上执行任务 管理进程 转发器(hub) 是一个接受所有所有测试任务的中心节点。 每个Selenium服务网格包含一个转发器(hub)。转发器(hub)需要能被所有的客户机（比如：持续集成服务器，开发机等等）访问到。 转发器(hub)会连接1个或者多个节点，这些节点会代理执行测试任务。
节点 浏览器会被安装在节点上 节点会把自己注册在转发器(hub)上并申报自己作为测试代理的能力(有些什么浏览器，每个浏览器可以运行几个实例等等) 接受转发器(hub)的指示并执行这些指示 节点 和不同的Selenium实例，他们能够在特定的计算机系统上执行测试。 一个服务网格中可以有很多节点。 这些终端设备并不需要使用统一的平台(或者说操作系统)也不需要选择相同的浏览器。 一个Windows节点可以提供IE作为一个浏览器选项来执行测试，然而Linux和MAC是不可能提供的。</description></item><item><title>模拟外部服务</title><link>https://www.selenium.dev/zh-cn/documentation/test_practices/encouraged/mock_external_services/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/test_practices/encouraged/mock_external_services/</guid><description>消除对外部服务的依赖性将大大提高测试的速度和稳定性.</description></item><item><title>线程守卫</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/support_features/thread_guard/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/support_features/thread_guard/</guid><description>此类仅在Java中可用 ThreadGuard检查是否仅从创建驱动程序的同一线程中调用了驱动程序. 线程问题 (尤其是在Parallel中运行测试时) 可能遇到神秘并且难以诊断错误. 使用此包装器可以防止此类错误,
并且在发生此类情况时会抛出异常.
以下的示例模拟一种线程冲突的情况:
public class DriverClash { //thread main (id 1) created this driver private WebDriver protectedDriver = ThreadGuard.protect(new ChromeDriver()); static { System.setProperty(&amp;#34;webdriver.chrome.driver&amp;#34;, &amp;#34;&amp;lt;Set path to your Chromedriver&amp;gt;&amp;#34;); } //Thread-1 (id 24) is calling the same driver causing the clash to happen Runnable r1 = () -&amp;gt; {protectedDriver.get(&amp;#34;https://selenium.dev&amp;#34;);}; Thread thr1 = new Thread(r1); void runThreads(){ thr1.start(); } public static void main(String[] args) { new DriverClash().</description></item><item><title>性能测试</title><link>https://www.selenium.dev/zh-cn/documentation/test_practices/discouraged/performance_testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/test_practices/discouraged/performance_testing/</guid><description>通常不建议使用Selenium和WebDriver进行性能测试. 并非因为不能做, 只是缺乏针对此类工作的优化, 因而难以得到乐观的结果.
对于用户而言, 在用户上下文中执行性能测试似乎是自然而然的选择, 但是WebDriver的测试会受到许多外部和内部的影响而变得脆弱, 这是您无法控制的. 例如, 浏览器的启动速度, HTTP服务器的速度, 托管JavaScript或CSS的第三方服务器的响应 以及WebDriver实现本身检测的损失. 这些因素的变化会影响结果. 很难区分网站自身与外部资源之间的性能差异, 并且也很难明确浏览器中使用WebDriver对性能的影响, 尤其是在注入脚本时.
另一个潜在的吸引点是&amp;quot;节省时间&amp;quot;-同时执行功能和性能测试. 但是, 功能和性能测试分别具有截然不同的目标. 要测试功能, 测试人员可能需要耐心等待加载, 但这会使性能测试结果蒙上阴影, 反之亦然.
为了提高网站的性能, 您需要不依赖于环境的差异来分析整体性能, 识别不良代码的实践, 对单个资源 (即CSS或JavaScript) 的性能进行细分 以了解需要改进的地方. 有很多性能测试工具已经可以完成这项工作, 并且提供了报告和分析结果, 甚至可以提出改进建议.
例如一种易于使用的 (开源) 软件包是: JMeter</description></item><item><title>远程WebDriver服务器</title><link>https://www.selenium.dev/zh-cn/documentation/legacy/selenium_2/remote_server/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/legacy/selenium_2/remote_server/</guid><description>服务器将始终在安装了待测浏览器的机器上运行. 可以从命令行或通过代码配置来使用服务器.
从命令行启动服务器 下载 selenium-server-standalone-{VERSION}.jar 后, 将其传到具有待测浏览器的电脑上. 然后, 切换到包含此jar文件的目录中, 运行以下命令:
java -jar selenium-server-standalone-{VERSION}.jar 运行服务器的注意事项 调用者应调用 Selenium#stop() 或 WebDriver#quit 以结束每次会话.
Selenium服务器在内存中保留每个运行会话的日志, 这些日志将在调用 Selenium#stop() 或 WebDriver#quit 时清除. 如果您忘记终止这些会话, 则可能会造成服务器内存泄漏. 如果您保持运行时间非常长的会话, 则可能需要不时执行停止或退出的操作 (或使用-Xmx jvm选项增加内存) .
超时 (自2.21版本) 服务器有两种不同的超时, 可以按如下设置:
java -jar selenium-server-standalone-{VERSION}.jar -timeout=20 -browserTimeout=60 browserTimeout 控制允许浏览器挂起的时间 (以秒为单位的值) . timeout 控制在回收会话之前允许客户端离开的时间 (以秒为单位的值) . 从2.21版本开始不再支持系统属性 selenium.server.session.timeout.
请注意, 当常规超时机制发生故障时, browserTimeout旨在用作备份超时机制, 该机制应主要在网格和服务器的环境中使用, 以确保崩溃或丢失的进程不会驻留太长时间, 从而干扰了运行时环境.
以编程方式配置服务器 从理论上讲, 此过程就像将 DriverServlet映射到URL一样简单, 但是也可以将页面托管在轻量级容器中, 例如完全用代码配置的Jetty. 步骤如下.
下载并解压 selenium-server.zip. 将这些Jar设置在CLASSPATH中. 创建一个名为 AppServer的新类. 在这里, 我使用Jetty, 因此您也需要download: import org.</description></item><item><title>服务网格的组件</title><link>https://www.selenium.dev/zh-cn/documentation/grid/components/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/grid/components/</guid><description>Page being translated from English to Chinese. Do you speak Chinese? Help us to translate it by sending us pull requests! Selenium Grid 4 是对以前版本的彻底重写。除了对性能和标准合规性进行全面改进外，还分解了 Grid 的不同功能以反映更现代的计算和软件开发时代。 Selenium Grid 4 专为容器化和云分布式可扩展性而构建，是现代时代的全新解决方案。
路由器（Router） 路由器 是 Grid 的入口点，接收所有外部请求，并将它们转发给正确的组件。
如果路由器收到新的会话请求，它将被转发到新会话队列。
如果请求属于一个已经存在的session，路由器会查询Session Map得到session运行所在的Node ID，然后将请求直接转发给Node。
路由器通过将请求发送到能够更好地处理它们的组件来平衡网格中的负载，而不会使过程中不需要的任何组件过载。
分发器（Distributor） 分发器有两个主要职责：
注册并跟踪所有Node及其功能 Node通过事件总线发送Node注册事件来注册到分发器。分发器读取它，然后尝试通过 HTTP 到达Node以确认它的存在。如果请求成功，Distributor注册节点并通过 GridModel 跟踪所有Node功能。
查询新会话队列并处理任何未决的新会话请求 当一个新的会话请求被发送到路由器时，它被转发到新会话队列，它将在队列中等待。 Distributor 将轮询新会话队列以查找未决的新会话请求，然后找到可以创建会话的合适Node。会话创建后，分发器将会话 ID 与正在执行会话的Node之间的关系存储在会话映射中。
会话映射（Session Map） 会话映射 是一个数据存储，用于保存会话 ID 和运行会话的Node之间的关系。它支持路由器在将请求转发到Node的过程中进行查询。路由器将向会话映射询问与会话 ID 关联的Node。
新会话队列（New Session Queue） 新会话队列按先进先出的顺序保存所有新会话请求。它具有可配置的参数，用于设置请求超时和请求重试间隔（检查超时的频率）。
路由器将新会话请求添加到新会话队列中并等待响应。新会话队列定期检查队列中是否有任何请求超时，如果是，则立即拒绝并将其删除。
分发器定期检查是否有可用的插槽。如果有可用的插槽，则分发器会轮询新会话队列以查找第一个匹配的请求。然后，分发器尝试创建新会话。</description></item><item><title>Print Page</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/interactions/print_page/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/interactions/print_page/</guid><description>Printing a webpage is a common task, whether for sharing information or maintaining archives. Selenium simplifies this process through its PrintOptions, PrintsPage, and browsingContext classes, which provide a flexible and intuitive interface for automating the printing of web pages. These classes enable you to configure printing preferences, such as page layout, margins, and scaling, ensuring that the output meets your specific requirements.
Configuring Orientation Using the getOrientation() and setOrientation() methods, you can get/set the page orientation &amp;mdash; either PORTRAIT or LANDSCAPE.</description></item><item><title>改善报告</title><link>https://www.selenium.dev/zh-cn/documentation/test_practices/encouraged/improved_reporting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/test_practices/encouraged/improved_reporting/</guid><description>Selenium并非旨在报告测试用例的运行状态. 利用单元测试框架的内置报告功能是一个好的开始. 大多数单元测试框架都有可以生成xUnit或HTML格式的报告. xUnit报表很受欢迎, 可以将其结果导入到持续集成（CI）服务器, 例如Jenkins、Travis、Bamboo等. 以下是一些链接, 可获取关于几种语言报表输出的更多信息.
NUnit 3 Console Runner
NUnit 3 Console Command Line
xUnit getting test results in TeamCity
xUnit getting test results in CruiseControl.NET
xUnit getting test results in Azure DevOps</description></item><item><title>爬取链接</title><link>https://www.selenium.dev/zh-cn/documentation/test_practices/discouraged/link_spidering/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/test_practices/discouraged/link_spidering/</guid><description>建议您不要使用WebDriver来通过链接进行爬网， 并非因为无法完成，而是因为它绝对不是最理想的工具。 WebDriver需要一些时间来启动，并且可能要花几秒钟到一分钟的时间， 具体取决于测试的编写方式，仅仅是为了获取页面并遍历DOM.
除了使用WebDriver之外， 您还可以通过执行 curl 命令或 使用诸如BeautifulSoup之类的库来节省大量时间， 因为这些方法不依赖于创建浏览器和导航至页面. 通过不使用WebDriver可以节省大量时间.</description></item><item><title>IE specific functionality</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/browsers/internet_explorer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/browsers/internet_explorer/</guid><description>As of June 2022, Selenium officially no longer supports standalone Internet Explorer. The Internet Explorer driver still supports running Microsoft Edge in &amp;ldquo;IE Compatibility Mode.&amp;rdquo;
Special considerations The IE Driver is the only driver maintained by the Selenium Project directly. While binaries for both the 32-bit and 64-bit versions of Internet Explorer are available, there are some known limitations with the 64-bit driver. As such it is recommended to use the 32-bit driver.</description></item><item><title>避免共享状态</title><link>https://www.selenium.dev/zh-cn/documentation/test_practices/encouraged/avoid_sharing_state/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/test_practices/encouraged/avoid_sharing_state/</guid><description>尽管在多个地方都提到过, 但这点仍值得被再次提及. 确保测试相互隔离.
不要共享测试数据. 想象一下有几个测试, 每个测试都会在选择操作执行之前查询数据库中的有效订单. 如果两个测试采用相同的顺序, 则很可能会出现意外行为.
清理应用程序中过时的数据, 这些数据可能会被其他测试. 例如无效的订单记录.
每次测试都创建一个新的WebDriver实例. 这在确保测试隔离的同时可以保障并行化更为简单.
If you choose pytest as your test runner, this can be easily done by yielding your driver in a global fixture. This way each test gets its own driver instance, and you can ensure that drivers always quit after a test is finished (pass or fail).</description></item><item><title>同窗口和标签一起工作</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/interactions/windows/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/interactions/windows/</guid><description>窗口和标签页 WebDriver 没有区分窗口和标签页。如果你的站点打开了一个新标签页或窗口，Selenium 将允许您使用窗口句柄来处理它。 每个窗口都有一个唯一的标识符，该标识符在单个会话中保持持久性。你可以使用以下方法获得当前窗口的窗口句柄:
Java Python CSharp Ruby JavaScript Kotlin // Navigate to Url driver.get(&amp;#34;https://www.selenium.dev/selenium/web/window_switching_tests/page_with_frame.html&amp;#34;); //fetch handle of this String currHandle=driver.getWindowHandle(); assertNotNull(currHandle); View full example on GitHub driver.current_window_handle // Navigate to Url driver.Url=&amp;#34;https://www.selenium.dev/selenium/web/window_switching_tests/page_with_frame.html&amp;#34;; //fetch handle of this String currHandle = driver.CurrentWindowHandle; Assert.IsNotNull(currHandle); View full example on GitHub driver.window_handle await driver.getWindowHandle(); driver.windowHandle 切换窗口或标签页 单击在 &amp;lt;a href=&amp;ldquo;https://seleniumhq.github.io&amp;quot;target=&amp;quot;_blank&amp;rdquo;&amp;gt;新窗口 中打开链接， 则屏幕会聚焦在新窗口或新标签页上，但 WebDriver 不知道操作系统认为哪个窗口是活动的。 要使用新窗口，您需要切换到它。 如果只有两个选项卡或窗口被打开，并且你知道从哪个窗口开始， 则你可以遍历 WebDriver， 通过排除法可以看到两个窗口或选项卡，然后切换到你需要的窗口或选项卡。
不过，Selenium 4 提供了一个新的 api NewWindow 它创建一个新选项卡 (或) 新窗口并自动切换到它。</description></item><item><title>编写第一个Selenium脚本</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/getting_started/first_script/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/getting_started/first_script/</guid><description>当你完成 Selenium安装 后, 便可以开始书写Selenium脚本了.
八个基本组成部分 Selenium所做的一切, 就是发送给浏览器命令, 用以执行某些操作或为信息发送请求. 您将使用Selenium执行的大部分操作, 都是以下基本命令的组合
点击 &amp;ldquo;View full example on GitHub&amp;rdquo; 的链接以查看上下文中的代码.
1. 使用驱动实例开启会话 关于如何启动会话，请浏览我们的文档 驱动会话
Java Python CSharp Ruby JavaScript Kotlin WebDriver driver = new ChromeDriver(); View full example on GitHub driver = webdriver.Chrome() View full example on GitHub IWebDriver driver = new ChromeDriver(); View full example on GitHub driver = Selenium::WebDriver.for :chrome View full example on GitHub driver = await new Builder().forBrowser(Browser.CHROME).build(); View full example on GitHub driver = ChromeDriver() View full example on GitHub 2.</description></item><item><title>使用定位器的提示</title><link>https://www.selenium.dev/zh-cn/documentation/test_practices/encouraged/locators/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/test_practices/encouraged/locators/</guid><description>这里有一些 支持的定位策略 的例子 .
一般来说，如果 HTML 的 id 是可用的、唯一的且是可预测的，那么它就是在页面上定位元素的首选方法。它们的工作速度非常快，可以避免复杂的 DOM 遍历带来的大量处理。
如果没有唯一的 id，那么最好使用写得好的 CSS 选择器来查找元素。XPath 和 CSS 选择器一样好用，但是它语法很复杂，并且经常很难调试。尽管 XPath 选择器非常灵活，但是他们通常未经过浏览器厂商的性能测试，并且运行速度很慢。
基于链接文本和部分链接文本的选择策略有其缺点，即只能对链接元素起作用。此外，它们在 WebDriver 内部调用 querySelectorAll 选择器。
标签名可能是一种危险的定位元素的方法。页面上经常出现同一标签的多个元素。这在调用 findElements(By) 方法返回元素集合的时候非常有用。
建议您尽可能保持定位器的紧凑性和可读性。使用 WebDriver 遍历 DOM 结构是一项性能花销很大的操作，搜索范围越小越好。</description></item><item><title>双因素认证</title><link>https://www.selenium.dev/zh-cn/documentation/test_practices/discouraged/two_factor_authentication/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/test_practices/discouraged/two_factor_authentication/</guid><description>双因素认证通常简写成 2FA 是一种一次性密码（OTP）通常用在移动应用上例如“谷歌认证器”， “微软认证器”等等，或者通过短信或者邮件来认证。在Selenium自动化中这些都是影响有效自动化 的极大挑战。虽然也有一些方法可以自动化这些过程，但是同样对于Selenium自动化也引入了很多不安全因素。 所以你应该要避免对2FA自动化。
这里有一些对于如何绕过2FA校验的建议：
在测试环境中对特定用户禁止2FA校验，这样对于这些特定用户可以直接进行自动化测试。 禁止2FA校验在测试环境中。 对于特定IP区域禁止2FA校验，这样我们可以配置测试机器的IP在这些白名单区域中。</description></item><item><title>测试的独立性</title><link>https://www.selenium.dev/zh-cn/documentation/test_practices/encouraged/test_independency/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/test_practices/encouraged/test_independency/</guid><description>将每个测试编写为独立的单元. 以不依赖于其他测试完成的方式编写测试:
例如有一个内容管理系统, 您可以借助其创建一些自定义内容, 这些内容在发布后作为模块显示在您的网站上, 并且CMS和应用程序之间的同步可能需要一些时间.
测试模块的一种错误方法是在测试中创建并发布内容, 然后在另一测试中检查该模块. 这是不可取的, 因为发布后内容可能无法立即用于其他测试.
与之相反的事, 您可以创建在受影响的测试中打开和关闭的打桩内容, 并将其用于验证模块. 而且, 对于内容的创建, 您仍然可以进行单独的测试.</description></item><item><title>Grid架构</title><link>https://www.selenium.dev/zh-cn/documentation/grid/architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/grid/architecture/</guid><description>Page being translated from English to Chinese. Do you speak Chinese? Help us to translate it by sending us pull requests! The Grid is designed as a set of components that all fulfill a role in maintaining the Grid. It can seem quite complicated, but hopefully this document can help clear up any confusion.
The Key Components The main components of the Grid are:
Event Bus Used for sending messages which may be received asynchronously between the other components.</description></item><item><title>Selenium IDE</title><link>https://www.selenium.dev/zh-cn/documentation/ide/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/ide/</guid><description>Selenium的集成开发环境 (Selenium IDE) 是一个易于使用的浏览器扩展, 利用既定的Selenium命令记录用户的浏览器行为, 参数由每个元素的上下文定义. 它提供了一种学习Selenium语法的极好方法. 其适用于谷歌Chrome、Mozilla火狐以及微软Edge浏览器.
有关更多信息, 请访问完整的 Selenium IDE 文档</description></item><item><title>Safari 特定功能</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/browsers/safari/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/browsers/safari/</guid><description>与Chromium和Firefox驱动不同, safari驱动随操作系统安装. 要在 Safari 上启用自动化, 请从终端运行以下命令:
safaridriver --enable 选项 所有浏览器通用的Capabilities在选项页.
Safari独有的Capabilities可以在Apple的页面关于Safari的WebDriver 上找到
使用基本定义的选项启动 Safari 会话如下所示:
Java Python CSharp Ruby JavaScript Kotlin SafariOptions options = new SafariOptions(); driver = new SafariDriver(options); View full example on GitHub options = webdriver.SafariOptions() driver = webdriver.Safari(options=options) View full example on GitHub var options = new SafariOptions(); driver = new SafariDriver(options); View full example on GitHub options = Selenium::WebDriver::Options.safari @driver = Selenium::WebDriver.for :safari, options: options View full example on GitHub .</description></item><item><title>考虑使用Fluent API</title><link>https://www.selenium.dev/zh-cn/documentation/test_practices/encouraged/consider_using_a_fluent_api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/test_practices/encouraged/consider_using_a_fluent_api/</guid><description>Martin Fowler创造了术语 &amp;ldquo;Fluent API&amp;rdquo;. Selenium已经在其 FluentWait 类中实现了类似的东西, 这是对标准 Wait 类的替代. 您可以在页面对象中启用Fluent API设计模式, 然后使用如下代码段查询Google搜索页面:
driver.get( &amp;#34;http://www.google.com/webhp?hl=en&amp;amp;amp;tab=ww&amp;#34; ); GoogleSearchPage gsp = new GoogleSearchPage(driver); gsp.setSearchString().clickSearchButton(); Google页面对象类具有这种流畅行为后可能看起来像这样:
public abstract class BasePage { protected WebDriver driver; public BasePage(WebDriver driver) { this.driver = driver; } } public class GoogleSearchPage extends BasePage { public GoogleSearchPage(WebDriver driver) { super(driver); // Generally do not assert within pages or components. // Effectively throws an exception if the lambda condition is not met.</description></item><item><title>升级到Selenium 4</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/troubleshooting/upgrade_to_selenium_4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/troubleshooting/upgrade_to_selenium_4/</guid><description>如果您使用的是官方支持的语言 (Ruby、JavaScript、C#、Python和Java), 那么升级到Selenium 4应该是一个轻松的过程. 在某些情况下可能会出现一些问题, 本指南将帮助您解决这些问题. 我们将完成升级项目依赖项的步骤, 并了解版本升级带来的主要反对意见和更改.
请按照以下步骤升级到Selenium 4:
准备我们的测试代码 升级依赖 潜在错误和弃用消息 注意：在开发Selenium 3.x版本的同时, 实现了对W3C WebDriver标准的支持. 此新协议和遗留JSON Wire协议均受支持. 在3.11版前后, Selenium代码与W3C 1级规范兼容. 最新版本的Selenium 3中的W3C兼容代码将在Selenium 4中正常工作.
准备测试代码 Selenium 4 移除了对遗留协议的支持, 并在底层实现上默认使用 W3C WebDriver 标准.
对于大多数情况, 这种实现不会影响终端用户.
主要的例外是 Capabilities 和 Actions 类.
Capabilities 如果测试capabilities的结构不符合 W3C标准, 可能会导致会话无法正常开启.
以下是 W3C WebDriver 标准capabilities列表:
browserName browserVersion (替代 version) platformName (替代 platform) acceptInsecureCerts pageLoadStrategy proxy timeouts unhandledPromptBehavior 可以在以下位置找到标准capabilities的最新列表 W3C WebDriver.
上面列表中未包含的任何capability, 都需要包含供应商前缀. 这适用于浏览器特定capability 以及云供应商特定capability. 例如, 如果您的云供应商为您的测试 使用 build 和 name capability, 您需要将它们包装在一个 cloud: options 块中 (请与您的云供应商联系以获取适当的前缀).</description></item><item><title>组织和执行Selenium代码</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/getting_started/using_selenium/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/getting_started/using_selenium/</guid><description>如果你不仅仅只是想执行一小撮的一次性脚本，你需要能组织和安排好你的代码。这一页会启发你如何真正地使用 Selenium 代码做高效的事情。
常见用法 大部分人使用 Selenium 执行针对 Web 应用的自动化测试，但是 Selenium 其实可以支持任何场景的浏览器自动化。
重复性任务 有时候你需要往网站记录日志或者下载一些东西，或者提交一个表单，你可以在预设的时间创建一个 Selenium 脚本去执行一个服务。
网页爬虫 你是否期望从一个不提供 API 的网站收集数据？Selenium 可以满足你，但是请确保你了解该网站的服务条例，因为有些网站不允许你这样做，甚至有些网站会屏蔽 Selenium。
测试 使用 Selenium 做测试需要在 Selenium 执行操作后进行断言，所以一个好的断言类库是很有必要的。至于组织测试用例结构的一些额外特性则需要Test Runner来完成。
IDEs 不管你要用 Selenium 来做什么，没有一个好的集成开发环境，你的工作肯定不会高效。以下是一些常见的 IDE 选择：
Eclipse IntelliJ IDEA PyCharm RubyMine Rider WebStorm VS Code Test Runner 即使不使用 Selenium 做测试，如果你有高级用例，使用一个 test runner 去更好地组织你的代码是很有意义的。学会使用 before/after hooks 和分组执行或者并行执行将会非常有用。
待选 有非常多不同的 test runner 可供选择。
这个教程中所有使用到 test runner 的代码示例都可以在我们的示例目录中找到（或者正在被迁移过去），而且这些示例在每一次发版都会被执行，以确保代码是正确的和最新的。下面是一份包含对应链接的 test runner 清单，其中第一项是被这个仓库和本页所有用例所使用的。
Java Python CSharp Ruby JavaScript Kotlin JUnit - A widely-used testing framework for Java-based Selenium tests.</description></item><item><title>使用选择列表元素</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/support_features/select_lists/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/support_features/select_lists/</guid><description>Select对象现在将为您提供一系列命令, 用于允许您与 &amp;lt;select&amp;gt; 元素进行交互.
如果您使用的是 Java 或 .NET， 请确保您在代码中已正确加载所需的包. 您可以通过GitHub查看下面示例的完整代码.
请注意，此类仅适用于 HTML 元素 select 和 option. 这个类将不适用于那些通过 div 或 li 并使用JavaScript遮罩层设计的下拉列表.
类型 选择方法的行为可能会有所不同， 具体取决于正在使用的 &amp;lt;select&amp;gt; 元素的类型.
单选 这是标准的下拉对象，其只能选定一个选项.
&amp;lt;select name=&amp;#34;selectomatic&amp;#34;&amp;gt; &amp;lt;option selected=&amp;#34;selected&amp;#34; id=&amp;#34;non_multi_option&amp;#34; value=&amp;#34;one&amp;#34;&amp;gt;One&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;two&amp;#34;&amp;gt;Two&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;four&amp;#34;&amp;gt;Four&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;still learning how to count, apparently&amp;#34;&amp;gt;Still learning how to count, apparently&amp;lt;/option&amp;gt; &amp;lt;/select&amp;gt; 复选 此选择列表允许同时选定和取消选择多个选项. 这仅适用于具有 multiple 属性的 &amp;lt;select&amp;gt;元素.
&amp;lt;select name=&amp;#34;multi&amp;#34; id=&amp;#34;multi&amp;#34; multiple=&amp;#34;multiple&amp;#34;&amp;gt; &amp;lt;option selected=&amp;#34;selected&amp;#34; value=&amp;#34;eggs&amp;#34;&amp;gt;Eggs&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;ham&amp;#34;&amp;gt;Ham&amp;lt;/option&amp;gt; &amp;lt;option selected=&amp;#34;selected&amp;#34; value=&amp;#34;sausages&amp;#34;&amp;gt;Sausages&amp;lt;/option&amp;gt; &amp;lt;option value=&amp;#34;onion gravy&amp;#34;&amp;gt;Onion gravy&amp;lt;/option&amp;gt; &amp;lt;/select&amp;gt; 构建类 首先定位一个 &amp;lt;select&amp;gt; 元素, 然后借助其初始化一个Select 对象.</description></item><item><title>远程WebDriver</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/drivers/remote_webdriver/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/drivers/remote_webdriver/</guid><description>Selenium lets you automate browsers on remote computers if there is a Selenium Grid running on them. The computer that executes the code is referred to as the client computer, and the computer with the browser and driver is referred to as the remote computer or sometimes as an end-node. To direct Selenium tests to the remote computer, you need to use a Remote WebDriver class and pass the URL including the port of the grid on that machine.</description></item><item><title>每次测试都刷新浏览器</title><link>https://www.selenium.dev/zh-cn/documentation/test_practices/encouraged/fresh_browser_per_test/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/test_practices/encouraged/fresh_browser_per_test/</guid><description>每次测试都从一个干净的已知状态开始. 理想情况下, 为每次测试打开一个新的虚拟机. 如果打开新虚拟机不切实际, 则至少应为每次测试启动一个新的WebDriver. 对于Firefox, 请使用您已知的配置文件去启动WebDriver. 大多数浏览器驱动器，像GeckoDriver和ChromeDriver那样，默认都会以干净的已知状态和一个新的用户配置文件开始。
WebDriver driver = new FirefoxDriver();</description></item><item><title>BiDirectional API (W3C compliant)</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/bidi/w3c/log/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/bidi/w3c/log/</guid><description>Page being translated from English to Chinese. Do you speak Chinese? Help us to translate it by sending us pull requests! This section contains the APIs related to logging.
Console logs Listen to the console.log events and register callbacks to process the event.
Java Ruby JavaScript Kotlin public void jsErrors() { CopyOnWriteArrayList&amp;lt;ConsoleLogEntry&amp;gt; logs = new CopyOnWriteArrayList&amp;lt;&amp;gt;(); try (LogInspector logInspector = new LogInspector(driver)) { logInspector.onConsoleEntry(logs::add); } driver.get(&amp;#34;https://www.selenium.dev/selenium/web/bidi/logEntryAdded.html&amp;#34;); View full example on GitHub Add Example</description></item><item><title>虚拟身份验证器</title><link>https://www.selenium.dev/zh-cn/documentation/webdriver/interactions/virtual_authenticator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.selenium.dev/zh-cn/documentation/webdriver/interactions/virtual_authenticator/</guid><description>Web 应用程序可以启用基于公钥的身份验证机制（称为 Web 身份验证）以无密码方式对用户进行身份验证。 Web 身份验证 定义了允许用户创建公钥凭据并将其注册到身份验证器的 API。 身份验证器可以是硬件设备或软件实体，用于存储用户的公钥凭证并根据请求检索它们。
顾名思义，虚拟身份验证器模拟此类身份验证器进行测试。
虚拟身份验证器选项 虚拟身份验证器具有 一组属性。 这些属性在 Selenium 绑定中映射为 VirtualAuthenticatorOptions。
Java CSharp Ruby Python JavaScript Kotlin VirtualAuthenticatorOptions options = new VirtualAuthenticatorOptions() .setIsUserVerified(true) .setHasUserVerification(true) .setIsUserConsenting(true) .setTransport(VirtualAuthenticatorOptions.Transport.USB) .setProtocol(VirtualAuthenticatorOptions.Protocol.U2F) .setHasResidentKey(false); View full example on GitHub // Create virtual authenticator options VirtualAuthenticatorOptions options = new VirtualAuthenticatorOptions() .SetIsUserVerified(true) .SetHasUserVerification(true) .SetIsUserConsenting(true) .SetTransport(VirtualAuthenticatorOptions.Transport.USB) .SetProtocol(VirtualAuthenticatorOptions.Protocol.U2F) .SetHasResidentKey(false); View full example on GitHub Add Example
options = VirtualAuthenticatorOptions() options.is_user_verified = True options.has_user_verification = True options.</description></item></channel></rss>