[
{
	"uri": "https://selenium.dev/documentation/fr/driver_idiosyncrasies/shared_capabilities/",
	"title": "Capabilities partagées",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n pageLoadStrategy When navigating to a new page via URL, by default Selenium will wait until the page has fully loaded before responding. This works well for beginners, but can cause long wait times on pages that load a large number of third party resources. Using a non default strategy can make test execution faster in cases like this, but can also introduce flakiness where elements on the page change position as elements load in and change size.\nThe page load strategy queries the document.readyState as described in the table below:\n   Strategy Ready State Notes     normal complete Used by default, waits for all resources to download   eager interactive DOM access is ready, but other resources like images may still be loading   none Any Does not block WebDriver at all    "
},
{
	"uri": "https://selenium.dev/documentation/fr/worst_practices/captchas/",
	"title": "Captchas",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n CAPTCHA, short for Completely Automated Public Turing test to tell Computers and Humans Apart, is explicitly designed to prevent automation, so don’t try! There are two primary strategies to get around CAPTCHA checks:\n Disable CAPTCHAs in your test environment Add a hook to allow tests to bypass the CAPTCHA  "
},
{
	"uri": "https://selenium.dev/documentation/fr/webdriver/understanding_the_components/",
	"title": "Comprendre les composants",
	"tags": [],
	"description": "",
	"content": " Pour créer une suite de tests à l\u0026rsquo;aide de WebDriver, vous devrez comprendre et utiliser efficacement un certain nombre de composants différents. logiciel, différentes personnes utilisent des termes différents pour la même idée. une ventilation de la façon dont les termes sont utilisés dans cette description.\nTerminologie  API: Interface de programmation d\u0026rsquo;application. Il s\u0026rsquo;agit de l\u0026rsquo;ensemble des \u0026ldquo;commandes\u0026rdquo; vous utilisez pour manipuler WebDriver. Bibliothèque: Un module de code qui contient les API et le code nécessaires Les bibliothèques sont spécifiques à chaque liaison de langue, par exemple .jar fichiers pour Java, fichiers .dll pour .NET, etc. Pilote: Responsable du contrôle du navigateur actuel. sont créés par les fournisseurs de navigateurs eux-mêmes. modules exécutables qui s\u0026rsquo;exécutent sur le système avec le navigateur lui-même, pas sur le système exécutant la suite de tests (bien que ceux-ci puissent être même système.) NOTE: Certaines personnes se réfèrent aux pilotes en tant que proxies. Framework: Une bibliothèque supplémentaire utilisée comme support pour WebDriver Ces cadres peuvent être des cadres de test tels que JUnit ou NUnit. Il peut également s\u0026rsquo;agir de cadres prenant en charge les fonctionnalités du langage naturel telles que comme Cucumber ou Robotium.Frameworks peut également être écrit et utilisé pour des choses telles que la manipulation ou la configuration du système sous test, les données création, test d\u0026rsquo;oracles, etc.  Les pièces et pièces Au minimum, WebDriver communique avec un navigateur via un pilote. est à double sens: WebDriver passe des commandes au navigateur via le pilote, et reçoit des informations via le même itinéraire.\nLe pilote est spécifique au navigateur, tel que ChromeDriver pour Google Chrome / Chrome, GeckoDriver pour Firefox de Mozilla, etc. Le pilote fonctionne sur le même système que le navigateur. Il peut s\u0026rsquo;agir ou non du même système sur lequel les tests eux-mêmes sont en cours d\u0026rsquo;exécution.\nCet exemple simple ci-dessus est la communication directe. le navigateur peut également être une communication à distance via Selenium Server ou RemoteWebDriver. RemoteWebDriver fonctionne sur le même système que le pilote et le navigateur.\nLa communication à distance peut également avoir lieu à l\u0026rsquo;aide de Selenium Server ou Selenium Grille, qui à son tour parlent au conducteur sur le système hôte\nOù les cadres s\u0026rsquo;intègrent WebDriver a un seul travail et un seul travail: communiquez avec le navigateur via des méthodes ci-dessus.WebDriver ne sait rien du test: il ne sait pas savoir comparer les choses, affirmer réussir ou échouer, et il ne sait certainement pas une chose à propos de la grammaire Reporting ou Given / When / Then.\nC\u0026rsquo;est là que divers frameworks entrent en jeu. Au minimum, vous aurez besoin d\u0026rsquo;un cadre de test qui correspond aux liaisons de langage, par exemple NUnit pour .NET, JUnit pour Java, RSpec pour Ruby, etc.\nLe framework de test est responsable de l\u0026rsquo;exécution et de l\u0026rsquo;exécution de votre WebDriver et les étapes connexes dans vos tests. En tant que tel, vous pouvez penser qu\u0026rsquo;il ressemble à à l\u0026rsquo;image suivante.\nDes cadres / outils en langage naturel tels que le concombre peuvent exister dans le cadre de cette Test Framework cadre dans la figure ci-dessus, ou ils peuvent envelopper le Test Framework entièrement dans leur propre mise en œuvre.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/front_matter/copyright_and_attributions/",
	"title": "Copyright et attributions",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n The Documentation of Selenium Copyright \u0026copy; 2013-2020 , Software Freedom Conservancy.\nEvery effort has been made to make this documentation as complete and as accurate as possible, but no warranty or fitness is implied. The information provided is on an “as-is” basis. The authors and the publisher shall have neither liability nor responsibility to any person or entity with respect to any loss or damages arising from the information contained in this book. No patent liability is assumed with respect to the use of the information contained herein.\nAttributions Thanks to: Selenium Main Repository .ghContributors { display: flex; flex-flow: wrap; align-content: flex-start; } .ghContributors \u0026gt; div { width: 50%; display: inline-flex; margin-bottom: 5px; } .ghContributors \u0026gt; div label { padding-left: 4px; } .ghContributors \u0026gt; div span { font-size: x-small; padding-left: 4px; }  @shs96c4442 commits \n@barancev2811 commits \n@jimevans2274 commits \n@jleyba1464 commits \n@jarib1298 commits \n@dfabulich1175 commits \n@illicitonion1162 commits \n@AutomatedTester761 commits \n@lukeis599 commits \n@eranmes473 commits \n@p0deje332 commits \n@mdub326 commits \n@titusfortner319 commits \n@andreastt289 commits \n@krosenvold225 commits \n@hugs205 commits \n@davehunt200 commits \n@hbchai191 commits \n@lmtierney179 commits \n@ph7147 commits \n@freynaud138 commits \n@samitbadle137 commits \n@nirvdrum133 commits \n@sevaseva115 commits \n@gigix109 commits \n@juangj108 commits \n@aslakhellesoy94 commits \n@alex-savchuk90 commits \n@andrashatvani66 commits \n@ajayk63 commits \n@asashour48 commits \n@twalpole48 commits \n@mikemelia46 commits \n@jherault44 commits \n@tebeka44 commits \n@santiycr41 commits \n@luke-hill37 commits \n@mach636 commits \n@diemol33 commits \n@ddavison31 commits \n@joshbruning30 commits \n@mikebroberts28 commits \n@valfirst22 commits \n@JohnChen021 commits \n@bret20 commits \n@cgoldberg20 commits \n@by-example19 commits \n@rbri16 commits \n@alb-i98614 commits \n@krmahadevan14 commits \n@bayandin12 commits \n@jayakumarc12 commits \n@carlosgcampos11 commits \n@43081j11 commits \n@corevo11 commits \n@detro10 commits \n@josephg10 commits \n@redsquirrel9 commits \n@RustyNail9 commits \n@InstyleVII8 commits \n@tourdedave8 commits \n@glib-briia7 commits \n@llaskin7 commits \n@DrMarcII7 commits \n@mmerrell7 commits \n@User2534897 commits \n@dratler7 commits \n@dima-groupon6 commits \n@nikolas6 commits \n@Herst5 commits \n@Dude-X5 commits \n@jimvm5 commits \n@JohanLorenzo5 commits \n@Harsha5095 commits \n@oddui5 commits \n@adiohana5 commits \n@Zitrax4 commits \n@dbo4 commits \n@xaircore4 commits \n@sangaline4 commits \n@Ardesco4 commits \n@klepikov4 commits \n@tobli4 commits \n@yizeng4 commits \n@abotalov4 commits \n@dylanlive4 commits \n@JasnoWa4 commits \n@mcharsley4 commits \n@GQAssurance4 commits \n@mojwang4 commits \n@alexhenrie3 commits \n@chrisblock3 commits \n@Marketionist3 commits \n@epall3 commits \n@thorn03 commits \n@johnjbarton3 commits \n@zch3 commits \n@zcmgyu3 commits \n@Dominator0083 commits \n@nschonni3 commits \n\nSelenium IDE .ghContributors { display: flex; flex-flow: wrap; align-content: flex-start; } .ghContributors \u0026gt; div { width: 50%; display: inline-flex; margin-bottom: 5px; } .ghContributors \u0026gt; div label { padding-left: 4px; } .ghContributors \u0026gt; div span { font-size: x-small; padding-left: 4px; }  @corevo2445 commits \n@tourdedave610 commits \n@baimao843788 commits \n@Jongkeun51 commits \n@petermouse36 commits \n@LinYunWen36 commits \n@zavelevsky34 commits \n@xdennisx15 commits \n@dvd9006 commits \n@manoj97883 commits \n@shs96c3 commits \n@zewa6663 commits \n@diemol2 commits \n@lukeis2 commits \n@Meir0172 commits \n@toshiya2 commits \n@amitzur1 commits \n@aplorenzen1 commits \n@p26351 commits \n@avoid3d1 commits \n@sotayamashita1 commits \n@samitbadle1 commits \n@swes11171 commits \n@vivrichards6001 commits \n@bolasblack1 commits \n@peter-kehl1 commits \n\nDocker Selenium .ghContributors { display: flex; flex-flow: wrap; align-content: flex-start; } .ghContributors \u0026gt; div { width: 50%; display: inline-flex; margin-bottom: 5px; } .ghContributors \u0026gt; div label { padding-left: 4px; } .ghContributors \u0026gt; div span { font-size: x-small; padding-left: 4px; }  @diemol209 commits \n@ddavison133 commits \n@mtscout653 commits \n@kayabendroth50 commits \n@elgalu24 commits \n@WillAbides8 commits \n@marten-cz5 commits \n@MacCracken5 commits \n@jsa345 commits \n@garagepoort4 commits \n@METAJIJI4 commits \n@manoj97884 commits \n@ZainabSalameh4 commits \n@vasikarla4 commits \n@chenrui3334 commits \n@niQo4 commits \n@testphreak4 commits \n@Remi-p3 commits \n@tnguyen143 commits \n@alexgibson3 commits \n@jeff-jk3 commits \n@pabloFuente3 commits \n@chuckg2 commits \n@davehunt2 commits \n@glib-briia2 commits \n@joaoluizjoaquim2 commits \n@mathieu-pousse2 commits \n@phensley2 commits \n@kaifried2 commits \n@ryneeverett2 commits \n@wheleph2 commits \n@schmunk422 commits \n@a-k-g1 commits \n@alexkogon1 commits \n@deviantintegral1 commits \n@anto-ac1 commits \n@eez01 commits \n@Grisu1181 commits \n@gensc0041 commits \n@budtmo1 commits \n@charford1 commits \n@cyrille-leclerc1 commits \n@deiwin1 commits \n@enolan1 commits \n@evertones1 commits \n@hnryjms1 commits \n@doublemarket1 commits \n@hazmeister1 commits \n@McGriddle1 commits \n@jamesottaway1 commits \n@jarspi1 commits \n@BeyondEvil1 commits \n@ja8zyjits1 commits \n@jwhitlock1 commits \n@jonaseicher1 commits \n@CaffeinatedCM1 commits \n@karel19801 commits \n@kmala1 commits \n@lcnja1 commits \n@lmtierney1 commits \n@lukeis1 commits \n@m15o1 commits \n@michallepicki1 commits \n@mikewrighton1 commits \n@meeroslaph1 commits \n@nicolaiparlog1 commits \n@double161 commits \n@reinholdfuereder1 commits \n@remcorakers1 commits \n@rjatkins1 commits \n@scottturley1 commits \n@sethuster1 commits \n@smccarthy1 commits \n@stigkj1 commits \n@tadashi07131 commits \n@gitter-badger1 commits \n@graingert1 commits \n@ThomasMeschke1 commits \n@cvakiitho1 commits \n@torstenwalter1 commits \n@victor-catalyst1 commits \n@vv-p1 commits \n@wesmcouch1 commits \n@reegnz1 commits \n@eitany1 commits \n@miyajan1 commits \n@mgingras1 commits \n@mirkotschaeni1 commits \n@mkrei1 commits \n@neben1 commits \n@oleg-filiutsich1 commits \n@pujan141 commits \n@kinjelom1 commits \n\nSelenium Website \u0026amp; Docs .ghContributors { display: flex; flex-flow: wrap; align-content: flex-start; } .ghContributors \u0026gt; div { width: 50%; display: inline-flex; margin-bottom: 5px; } .ghContributors \u0026gt; div label { padding-left: 4px; } .ghContributors \u0026gt; div span { font-size: x-small; padding-left: 4px; }  @selenium-ci138 commits \n@diemol137 commits \n@Harsha50985 commits \n@alenros28 commits \n@AlexAndradeSan25 commits \n@boris77917 commits \n@manoj978811 commits \n@kzhirata11 commits \n@hiroksarker10 commits \n@liushilive6 commits \n@hyanx5 commits \n@barancev4 commits \n@ArCiGo3 commits \n@Madh933 commits \n@takeya0x863 commits \n@cambiph3 commits \n@lvninety3 commits \n@Bredda2 commits \n@bongosway2 commits \n@palotas2 commits \n@miekof2 commits \n@natanportilho2 commits \n@urig2 commits \n@ilhanoztozlu2 commits \n@imba-tjd2 commits \n@0420syj2 commits \n@k198107032 commits \n@adithyab941 commits \n@vinogradoff1 commits \n@cjayswal1 commits \n@fastrde1 commits \n@f97gujo1 commits \n@bisforum1 commits \n@misiekofski1 commits \n@muditlambda1 commits \n@nikhil-lambda1 commits \n@TheTestLynx1 commits \n@MindScriptAct1 commits \n@sergey-oplavin1 commits \n@shs96c1 commits \n@thiagola921 commits \n@9484624481 commits \n@sangheon43531 commits \n@yingyingshang1 commits \n\nPrevious Selenium Website .ghContributors { display: flex; flex-flow: wrap; align-content: flex-start; } .ghContributors \u0026gt; div { width: 50%; display: inline-flex; margin-bottom: 5px; } .ghContributors \u0026gt; div label { padding-left: 4px; } .ghContributors \u0026gt; div span { font-size: x-small; padding-left: 4px; }  @lukeis417 commits \n@shs96c91 commits \n@tourdedave89 commits \n@pgrandje79 commits \n@barancev63 commits \n@lightbody59 commits \n@ajayk40 commits \n@tarun3kumar40 commits \n@ddavison36 commits \n@davehunt26 commits \n@manoj978824 commits \n@peter-kehl22 commits \n@lmtierney21 commits \n@samitbadle21 commits \n@santiycr19 commits \n@illicitonion17 commits \n@pnewhook14 commits \n@AutomatedTester12 commits \n@rasmusbergpalm11 commits \n@juangj11 commits \n@lukeis-sfdc10 commits \n@andreastt7 commits \n@hugs6 commits \n@jarib5 commits \n@jimevans5 commits \n@llaskin5 commits \n@PaulKC5 commits \n@titusfortner5 commits \n@corevo5 commits \n@diemol3 commits \n@asashour2 commits \n@oleksandr-lobunets2 commits \n@alex-savchuk2 commits \n@javabrett2 commits \n@darrincherry2 commits \n@eranmes2 commits \n@hazmeister2 commits \n@julianharty2 commits \n@mikemelia2 commits \n@paul-hammant2 commits \n@labkey-tchad2 commits \n@abhijain26182 commits \n@agabrys1 commits \n@azawawi1 commits \n@alb-i9861 commits \n@hollingsworthd1 commits \n@dylans1 commits \n@EmidioStani1 commits \n@FagnerMartinsBrack1 commits \n@Xaeroxe1 commits \n@JamesZoft1 commits \n@jleyba1 commits \n@JasnoWa1 commits \n@JustAGuyTryingToCodeSomething1 commits \n@kdamball1 commits \n@laurin11 commits \n@klamping1 commits \n@krmahadevan1 commits \n@krosenvold1 commits \n@mmerrell1 commits \n@grawk1 commits \n@mcavigelli1 commits \n@michaelwowro1 commits \n@muralidharand1 commits \n@meeroslaph1 commits \n@NickAb1 commits \n@ohadschn1 commits \n@oifland1 commits \n@rbri1 commits \n@roydekleijn1 commits \n@QuinnWilton1 commits \n@smatei1 commits \n@harrissAvalon1 commits \n@stevedesmond-ca1 commits \n@Vimal-N1 commits \n@yasinguzel1 commits \n@tobecrazy1 commits \n@Zearin1 commits \n@beckendorff1 commits \n@daveOrleans1 commits \n@androiddriver1 commits \n@mauk811 commits \n@pharry221 commits \n@prab21121 commits \n@refactoror1 commits \n@rogerdc1 commits \n@tibord1 commits \n@ygmarchi1 commits \n\nPrevious Documentation Rewrite Project .ghContributors { display: flex; flex-flow: wrap; align-content: flex-start; } .ghContributors \u0026gt; div { width: 50%; display: inline-flex; margin-bottom: 5px; } .ghContributors \u0026gt; div label { padding-left: 4px; } .ghContributors \u0026gt; div span { font-size: x-small; padding-left: 4px; }  @andreastt197 commits \n@selenium-ci105 commits \n@diemol54 commits \n@hazmeister30 commits \n@santiycr27 commits \n@AlexAndradeSan25 commits \n@lukeis21 commits \n@Harsha50917 commits \n@ddavison16 commits \n@davehunt12 commits \n@manoj978812 commits \n@orieken12 commits \n@djangofan12 commits \n@liushilive8 commits \n@User2534897 commits \n@jimholmes6 commits \n@imba-tjd6 commits \n@mmerrell6 commits \n@shs96c6 commits \n@picimako5 commits \n@vijay445 commits \n@cambiph5 commits \n@nvonop4 commits \n@rivlinp4 commits \n@sheg4 commits \n@detro3 commits \n@Ardesco3 commits \n@TheTestLynx3 commits \n@boris7792 commits \n@Bredda2 commits \n@juperala2 commits \n@lmtierney2 commits \n@systemboogie2 commits \n@palotas2 commits \n@miekof2 commits \n@sri852 commits \n@hoanluu2 commits \n@ilhanoztozlu2 commits \n@paul-barton2 commits \n@adithyab941 commits \n@alenros1 commits \n@p0deje1 commits \n@AJ-721 commits \n@abotalov1 commits \n@bhardin1 commits \n@chamiz1 commits \n@dennybiasiolli1 commits \n@donhuvy1 commits \n@bongosway1 commits \n@nicegraham1 commits \n@f97gujo1 commits \n@JakimLi1 commits \n@austenjt1 commits \n@kmcgon1 commits \n@MartinDelille1 commits \n@michael-coleman1 commits \n@misiekofski1 commits \n@MilanMasek1 commits \n@rakib-amin1 commits \n@NRezek1 commits \n@nikai3d1 commits \n@OndraM1 commits \n@sourabhkt1 commits \n@whhone1 commits \n@yarix1 commits \n@ZbigniewZabost1 commits \n@agmen1 commits \n@hking-shutterfly1 commits \n@jimevans1 commits \n@9484624481 commits \n@marilyn1 commits \n@riccione1 commits \n@tungla1 commits \n@zeljkofilipin1 commits \n\nThird-Party software used by Selenium documentation project:    Software Version License     Hugo v0.55.6 Apache 2.0   Hugo Learn Theme v2.3.0 MIT   Code Tabs Style \u0026mdash; MIT    License All code and documentation originating from the Selenium project is licensed under the Apache 2.0 license, with the Software Freedom Conservancy as the copyright holder.\nThe license is included here for convenience, but you can also find it on the Apache Foundation\u0026rsquo;s websites:\nApache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \u0026#34;License\u0026#34; shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \u0026#34;Licensor\u0026#34; shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \u0026#34;Legal Entity\u0026#34; shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \u0026#34;control\u0026#34; means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \u0026#34;You\u0026#34; (or \u0026#34;Your\u0026#34;) shall mean an individual or Legal Entity exercising permissions granted by this License. \u0026#34;Source\u0026#34; form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \u0026#34;Object\u0026#34; form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \u0026#34;Work\u0026#34; shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \u0026#34;Derivative Works\u0026#34; shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \u0026#34;Contribution\u0026#34; shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \u0026#34;submitted\u0026#34; means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \u0026#34;Not a Contribution.\u0026#34; \u0026#34;Contributor\u0026#34; shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \u0026#34;NOTICE\u0026#34; text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \u0026#34;[]\u0026#34; replaced with your own identifying information. (Don\u0026#39;t include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \u0026#34;printed page\u0026#34; as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License."
},
{
	"uri": "https://selenium.dev/documentation/fr/selenium_installation/installing_selenium_libraries/",
	"title": "Installer les librairies Selenium",
	"tags": [],
	"description": "",
	"content": " Vous devez d\u0026rsquo;abord installer les fixations Selenium pour votre projet d\u0026rsquo;automatisation. Le processus d\u0026rsquo;installation des bibliothèques dépend de la langue que vous choisissez d\u0026rsquo;utiliser.\nJava L\u0026rsquo;installation des bibliothèques Selenium pour Java peut être effectuée à l\u0026rsquo;aide de Maven. Ajoutez la dépendance selenium-java dans votre projet pom.xml:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; La dépendance selenium-java prend en charge l\u0026rsquo;exécution de votre automatisation projet avec tous les navigateurs pris en charge par Selenium. Si vous souhaitez exécuter des tests uniquement dans un navigateur spécifique, vous pouvez ajouter la dépendance pour ce navigateur dans votre fichier pom.xml. Par exemple, vous devez ajouter la dépendance suivante dans votre pom.xml fichier pour exécuter vos tests uniquement dans Firefox:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-firefox-driver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; De la même manière, si vous souhaitez exécuter des tests uniquement dans Chrome, vous devez ajouter la dépendance suivante:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-chrome-driver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Python L\u0026rsquo;installation des bibliothèques Selenium pour Python peut être effectuée à l\u0026rsquo;aide de pip:\npip install selenium Vous pouvez également télécharger l\u0026rsquo;archive source PyPI (selenium-x.x.x.tar.gz) et installez-le à l\u0026rsquo;aide de setup.py:\npython setup.py install C# L\u0026rsquo;installation des bibliothèques Selenium pour C # peut être effectuée à l\u0026rsquo;aide de NuGet:\n# Using package manager Install-Package Selenium.WebDriver # or using .Net CLI dotnet add package Selenium.WebDriver Ruby L\u0026rsquo;installation des bibliothèques Selenium pour Ruby peut être effectuée à l\u0026rsquo;aide de gem:\ngem install selenium-webdriver JavaScript L\u0026rsquo;installation des bibliothèques Selenium pour JavaScript peut être effectuée à l\u0026rsquo;aide de npm:\nnpm install selenium-webdriver"
},
{
	"uri": "https://selenium.dev/documentation/fr/introduction/the_selenium_project_and_tools/",
	"title": "Le projet Selenium et les outils",
	"tags": [],
	"description": "",
	"content": " Selenium contrôle les navigateurs Web Selenium est beaucoup de choses, mais à la base, c\u0026rsquo;est un ensemble d\u0026rsquo;outils pour l\u0026rsquo;automatisation du navigateur Web qui utilise les meilleures techniques disponibles pour contrôler à distance les instances du navigateur et émuler l\u0026rsquo;interaction d\u0026rsquo;un utilisateur avec le navigateur.\nIl permet aux utilisateurs de simuler les activités courantes effectuées par les utilisateurs finaux; saisir du texte dans les champs, sélectionner des valeurs déroulantes et cocher des cases, et cliquer sur les liens dans les documents. Il fournit également de nombreux autres contrôles tels que le mouvement de la souris, l\u0026rsquo;exécution arbitraire de JavaScript et bien plus encore.\nBien qu\u0026rsquo;utilisé principalement pour les tests frontaux des sites Web, Selenium est à la base une bibliothèque d\u0026rsquo;agent utilisateur de navigateur. Les interfaces sont omniprésentes à leur application, qui encourage la composition avec d\u0026rsquo;autres bibliothèques en fonction de votre objectif.\nUne interface pour les gouverner tous Un des principes directeurs du projet est de prendre en charge une interface commune pour toutes les (principales) technologies de navigateur. Les navigateurs Web sont des applications incroyablement complexes et hautement conçues, effectuer leurs opérations de manière complètement différente mais qui se ressemblent souvent en le faisant. Même si le texte est rendu dans les mêmes polices, les images sont affichées au même endroit et les liens vous mènent à la même destination. Ce qui se passe en dessous est aussi différent que la nuit et le jour. Le sélénium «résume» ces différences, cacher leurs détails et leurs subtilités à la personne qui écrit le code. Cela vous permet d\u0026rsquo;écrire plusieurs lignes de code pour effectuer un workflow compliqué, mais ces mêmes lignes s\u0026rsquo;exécuteront sur Firefox, Internet Explorer, Chrome et tous les autres navigateurs pris en charge.\nOutils et support L\u0026rsquo;approche de conception minimaliste de Selenium lui confère polyvalence à inclure en tant que composant dans des applications plus importantes. L\u0026rsquo;infrastructure environnante fournie sous l\u0026rsquo;égide du sélénium vous donne les outils pour assembler votre grille de navigateurs afin que les tests puissent être exécutés sur différents navigateurs et plusieurs systèmes d\u0026rsquo;exploitation sur une gamme de machines.\nImaginez une banque d\u0026rsquo;ordinateurs dans votre salle de serveurs ou votre centre de données allumer tous les navigateurs en même temps frapper les liens, les formulaires de votre site, et tables \u0026amp; mdash; tester votre application 24h / 24. Grâce à l\u0026rsquo;interface de programmation simple fourni pour les langues les plus courantes, ces tests se dérouleront sans relâche en parallèle, vous faire rapport en cas d\u0026rsquo;erreur.\nC\u0026rsquo;est un objectif pour aider à en faire une réalité pour vous, en fournissant aux utilisateurs des outils et de la documentation pour non seulement contrôler les navigateurs, mais pour faciliter la mise à l\u0026rsquo;échelle et le déploiement de telles grilles.\nQui utilise le sélénium Beaucoup des entreprises les plus importantes au monde ont adopté Selenium pour leurs tests sur navigateur, remplaçant souvent des efforts de plusieurs années impliquant d\u0026rsquo;autres outils propriétaires. À mesure qu\u0026rsquo;elle gagne en popularité, ses exigences et ses défis se multiplient.\nAlors que le Web devient plus compliqué et de nouvelles technologies sont ajoutées aux sites Web, c\u0026rsquo;est la mission de ce projet de les suivre autant que possible. Être un projet open source, ce soutien est assuré grâce au généreux don de temps de nombreux bénévoles, chacun a un \u0026ldquo;travail de jour\u0026rdquo;.\nUne autre mission du projet est d\u0026rsquo;encourager plus de volontaires pour participer à cet effort, et construire une communauté forte afin que le projet puisse continuer à suivre les technologies émergentes et restent une plate-forme dominante pour l\u0026rsquo;automatisation des tests fonctionnels.\nHistoire Lorsque Selenium 1 est sorti en 2004, il n\u0026rsquo;était pas nécessaire de réduire le temps passé vérification manuelle d\u0026rsquo;un comportement cohérent dans le front-end d\u0026rsquo;une application Web. Il a utilisé les outils disponibles à l\u0026rsquo;époque et s\u0026rsquo;est fortement appuyé sur l\u0026rsquo;injection de JavaScript dans la page Web testée pour émuler l\u0026rsquo;interaction d\u0026rsquo;un utilisateur.\nBien que JavaScript soit un bon outil pour vous permettre d\u0026rsquo;introspecter les propriétés du DOM et de faire certaines observations côté client que vous ne seriez pas en mesure de faire autrement, il ne répond pas à la capacité de reproduire naturellement les interactions d\u0026rsquo;un utilisateur comme si la souris et le clavier étaient utilisés.\nDepuis lors, le sélénium a grandi et mûri beaucoup, dans un outil largement utilisé par de nombreux \u0026amp; mdash; sinon la plupart des \u0026amp; mdash; les plus grandes organisations du monde. Selenium est passé d\u0026rsquo;une boîte à outils d\u0026rsquo;automatisation de tests homebrewed développée à Thoughtworks pour un public niché et un cas d\u0026rsquo;utilisation spécifique, à la bibliothèque d\u0026rsquo;automatisation du navigateur de facto du monde.\nTout comme Selenium RC utilisait les outils du commerce disponibles à l\u0026rsquo;époque, Selenium WebDriver perpétue cette tradition en prenant la partie d\u0026rsquo;interaction du navigateur avec le gazon du vendeur du navigateur et en leur demandant de prendre la responsabilité des implémentations back-end, orientées navigateur. Récemment, ce travail est devenu un processus de normalisation du W3C où l\u0026rsquo;objectif est de transformer le composant WebDriver dans Selenium dans la bibliothèque de contrôle à distance du jeur pour les agents utilisateurs.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/remote_webdriver/remote_webdriver_server/",
	"title": "Le serveur Remote WebDriver",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n The server will always run on the machine with the browser you want to test. The server can be used either from the command line or through code configuration.\nStarting the server from the command line Once you have downloaded selenium-server-standalone-{VERSION}.jar, place it on the computer with the browser you want to test. Then, from the directory with the jar, run the following:\njava -jar selenium-server-standalone-{VERSION}.jar Considerations for running the server The caller is expected to terminate each session properly, calling either Selenium#stop() or WebDriver#quit.\nThe selenium-server keeps in-memory logs for each ongoing session, which are cleared when Selenium#stop() or WebDriver#quit is called. If you forget to terminate these sessions, your server may leak memory. If you keep extremely long-running sessions, you will probably need to stop/quit every now and then (or increase memory with -Xmx jvm option).\nTimeouts (from version 2.21) The server has two different timeouts, which can be set as follows:\njava -jar selenium-server-standalone-{VERSION}.jar -timeout=20 -browserTimeout=60  browserTimeout  Controls how long the browser is allowed to hang (value in seconds).  timeout  Controls how long the client is allowed to be gone before the session is reclaimed (value in seconds).   The system property selenium.server.session.timeout is no longer supported as of 2.21.\nPlease note that the browserTimeout is intended as a backup timeout mechanism when the ordinary timeout mechanism fails, which should be used mostly in grid/server environments to ensure that crashed/lost processes do not stay around for too long, polluting the runtime environment.\nConfiguring the server programmatically In theory, the process is as simple as mapping the DriverServlet to a URL, but it\u0026rsquo;s also possible to host the page in a lightweight container, such as Jetty configured entirely in code. Steps to do this follow.\nDownload the selenium-server.zip and unpack. Put the JARs on the CLASSPATH. Create a new class called AppServer. Here, I\u0026rsquo;m using Jetty, so you\u0026rsquo;ll need to download that as well:\nimport org.mortbay.jetty.Connector; import org.mortbay.jetty.Server; import org.mortbay.jetty.nio.SelectChannelConnector; import org.mortbay.jetty.security.SslSocketConnector; import org.mortbay.jetty.webapp.WebAppContext; import javax.servlet.Servlet; import java.io.File; import org.openqa.selenium.remote.server.DriverServlet; public class AppServer { private Server server = new Server(); public AppServer() throws Exception { WebAppContext context = new WebAppContext(); context.setContextPath(\u0026#34;\u0026#34;); context.setWar(new File(\u0026#34;.\u0026#34;)); server.addHandler(context); context.addServlet(DriverServlet.class, \u0026#34;/wd/*\u0026#34;); SelectChannelConnector connector = new SelectChannelConnector(); connector.setPort(3001); server.addConnector(connector); server.start(); } }"
},
{
	"uri": "https://selenium.dev/documentation/fr/getting_started_with_webdriver/browsers/",
	"title": "Navigateurs",
	"tags": [],
	"description": "",
	"content": " Navigateurs consommateurs Le framework Selenium supporte officiellement les navigateurs suivants:\n   Navigateur Mainteneur Versions supportées     Chromium Chromium Toutes versions   Firefox Mozilla 54 and plus récentes   Internet Explorer Selenium 6 et plus récentes   Opera Opera Chromium / Presto 10.5 et plus récentes   Safari Apple 10 et plus récentes    Navigateurs spécialisés Il existe également un ensemble de navigateurs spécialisés, utilisés typiquement dans des environnements de développement.\nIls peuvent également être utilisés à des fins d\u0026rsquo;automatisation, et Selenium fournit un support pour les navigateurs spécialisés suivants:\n   Nom Driver Utilisation Mainteneur     HtmlUnitDriver Emulateur de navigateur headless supproté par Rhino Projet Selenium    "
},
{
	"uri": "https://selenium.dev/documentation/fr/grid/purposes_and_main_functionalities/",
	"title": "Objectifs et fonctionnalitées",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n  Central entry point for all tests Management and control of the nodes / environment where the browsers run Scaling Running tests in parallel Cross platform testing Load balancing  "
},
{
	"uri": "https://selenium.dev/documentation/fr/guidelines_and_recommendations/page_object_models/",
	"title": "Page object models",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Page Object is a Design Pattern which has become popular in test automation for enhancing test maintenance and reducing code duplication. A page object is an object-oriented class that serves as an interface to a page of your AUT. The tests then use the methods of this page object class whenever they need to interact with the UI of that page. The benefit is that if the UI changes for the page, the tests themselves don’t need to change, only the code within the page object needs to change. Subsequently all changes to support that new UI are located in one place.\nThe Page Object Design Pattern provides the following advantages:\n There is a clean separation between test code and page specific code such as locators (or their use if you’re using a UI Map) and layout. There is a single repository for the services or operations offered by the page rather than having these services scattered throughout the tests.  In both cases this allows any modifications required due to UI changes to all be made in one place. Useful information on this technique can be found on numerous blogs as this ‘test design pattern’ is becoming widely used. We encourage the reader who wishes to know more to search the internet for blogs on this subject. Many have written on this design pattern and can provide useful tips beyond the scope of this user guide. To get you started, though, we’ll illustrate page objects with a simple example.\nFirst, consider an example, typical of test automation, that does not use a page object:\n/*** * Tests login feature */ public class Login { public void testLogin() { // fill login data on sign-in page  driver.findElement(By.name(\u0026#34;user_name\u0026#34;)).sendKeys(\u0026#34;testUser\u0026#34;); driver.findElement(By.name(\u0026#34;password\u0026#34;)).sendKeys(\u0026#34;my supersecret password\u0026#34;); driver.findElement(By.name(\u0026#34;sign-in\u0026#34;)).click(); // verify h1 tag is \u0026#34;Hello userName\u0026#34; after login  driver.findElement(By.tagName(\u0026#34;h1\u0026#34;)).isDisplayed(); assertThat(driver.findElement(By.tagName(\u0026#34;h1\u0026#34;)).getText(), is(\u0026#34;Hello userName\u0026#34;)); } } There are two problems with this approach.\n There is no separation between the test method and the AUT’s locators (IDs in this example); both are intertwined in a single method. If the AUT’s UI changes its identifiers, layout, or how a login is input and processed, the test itself must change. The ID-locators would be spread in multiple tests, in all tests that had to use this login page.  Applying the page object techniques, this example could be rewritten like this in the following example of a page object for a Sign-in page.\nimport org.openqa.selenium.By; import org.openqa.selenium.WebDriver; /** * Page Object encapsulates the Sign-in page. */ public class SignInPage { protected static WebDriver driver; // \u0026lt;input name=\u0026#34;user_name\u0026#34; type=\u0026#34;text\u0026#34; value=\u0026#34;\u0026#34;\u0026gt;  private By usernameBy = By.name(\u0026#34;user_name\u0026#34;); // \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; value=\u0026#34;\u0026#34;\u0026gt;  private By passwordBy = By.name(\u0026#34;password\u0026#34;); // \u0026lt;input name=\u0026#34;sign_in\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;SignIn\u0026#34;\u0026gt;  private By signinBy = By.name(\u0026#34;sign_in\u0026#34;); public SignInPage(WebDriver driver){ this.driver = driver; } /** * Login as valid user * * @param userName * @param password * @return HomePage object */ public HomePage loginValidUser(String userName, String password) { driver.findElement(usernameBy).sendKeys(userName); driver.findElement(passwordBy).sendKeys(password); driver.findElement(signinBy).click(); return new HomePage(driver); } } and page object for a Home page could look like this.\nimport org.openqa.selenium.By; import org.openqa.selenium.WebDriver; /** * Page Object encapsulates the Home Page */ public class HomePage { protected static WebDriver driver; // \u0026lt;h1\u0026gt;Hello userName\u0026lt;/h1\u0026gt;  private By messageBy = By.tagName(\u0026#34;h1\u0026#34;); public HomePage(WebDriver driver){ this.driver = driver; if (!driver.getTitle().equals(\u0026#34;Home Page of logged in user\u0026#34;)) { throw new IllegalStateException(\u0026#34;This is not Home Page of logged in user,\u0026#34; + \u0026#34; current page is: \u0026#34; + driver.getCurrentUrl()); } } /** * Get message (h1 tag) * * @return String message text */ public String getMessageText() { return driver.findElement(messageBy).getText(); } public HomePage manageProfile() { // Page encapsulation to manage profile functionality  return new HomePage(driver); } /* More methods offering the services represented by Home Page of Logged User. These methods in turn might return more Page Objects for example click on Compose mail button could return ComposeMail class object */ } So now, the login test would use these two page objects as follows.\n/*** * Tests login feature */ public class TestLogin { @Test public void testLogin() { SignInPage signInPage = new SignInPage(driver); HomePage homePage = signInPage.loginValidUser(\u0026#34;userName\u0026#34;, \u0026#34;password\u0026#34;); assertThat(homePage.getMessageText(), is(\u0026#34;Hello userName\u0026#34;)); } } There is a lot of flexibility in how the page objects may be designed, but there are a few basic rules for getting the desired maintainability of your test code.\nPage objects themselves should never make verifications or assertions. This is part of your test and should always be within the test’s code, never in an page object. The page object will contain the representation of the page, and the services the page provides via methods but no code related to what is being tested should be within the page object.\nThere is one, single, verification which can, and should, be within the page object and that is to verify that the page, and possibly critical elements on the page, were loaded correctly. This verification should be done while instantiating the page object. In the examples above, both the SignInPage and HomePage constructors check that the expected page is available and ready for requests from the test.\nA page object does not necessarily need to represent an entire page. The Page Object design pattern could be used to represent components on a page. If a page in the AUT has multiple components, it may improve maintainability if there is a separate page object for each component.\nThere are other design patterns that also may be used in testing. Some use a Page Factory for instantiating their page objects. Discussing all of these is beyond the scope of this user guide. Here, we merely want to introduce the concepts to make the reader aware of some of the things that can be done. As was mentioned earlier, many have blogged on this topic and we encourage the reader to search for blogs on these topics.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/getting_started/",
	"title": "Pour débuter",
	"tags": [],
	"description": "",
	"content": " Pour débuter Si Selenium est nouveau pour vous, nous vous proposons quelques ressources qui pourront vous aider à vous mettre à niveau très rapidement.\n Tour rapide  WebDriver IDE Grid   "
},
{
	"uri": "https://selenium.dev/documentation/fr/legacy_docs/selenium_rc/",
	"title": "Selenium 1 (Selenium RC)",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Introduction Selenium RC was the main Selenium project for a long time, before the WebDriver/Selenium merge brought up Selenium 2, a more powerful tool. It is worth to highlight that Selenium 1 is not supported anymore.\nHow Selenium RC Works First, we will describe how the components of Selenium RC operate and the role each plays in running your test scripts.\nRC Components Selenium RC components are:\n The Selenium Server which launches and kills browsers, interprets and runs the Selenese commands passed from the test program, and acts as an HTTP proxy, intercepting and verifying HTTP messages passed between the browser and the AUT. Client libraries which provide the interface between each programming language and the Selenium RC Server.  Here is a simplified architecture diagram:\nThe diagram shows the client libraries communicate with the Server passing each Selenium command for execution. Then the server passes the Selenium command to the browser using Selenium-Core JavaScript commands. The browser, using its JavaScript interpreter, executes the Selenium command. This runs the Selenese action or verification you specified in your test script.\nSelenium Server Selenium Server receives Selenium commands from your test program, interprets them, and reports back to your program the results of running those tests.\nThe RC server bundles Selenium Core and automatically injects it into the browser. This occurs when your test program opens the browser (using a client library API function). Selenium-Core is a JavaScript program, actually a set of JavaScript functions which interprets and executes Selenese commands using the browser\u0026rsquo;s built-in JavaScript interpreter.\nThe Server receives the Selenese commands from your test program using simple HTTP GET/POST requests. This means you can use any programming language that can send HTTP requests to automate Selenium tests on the browser.\nClient Libraries The client libraries provide the programming support that allows you to run Selenium commands from a program of your own design. There is a different client library for each supported language. A Selenium client library provides a programming interface (API), i.e., a set of functions, which run Selenium commands from your own program. Within each interface, there is a programming function that supports each Selenese command.\nThe client library takes a Selenese command and passes it to the Selenium Server for processing a specific action or test against the application under test (AUT). The client library also receives the result of that command and passes it back to your program. Your program can receive the result and store it into a program variable and report it as a success or failure, or possibly take corrective action if it was an unexpected error.\nSo to create a test program, you simply write a program that runs a set of Selenium commands using a client library API. And, optionally, if you already have a Selenese test script created in the Selenium-IDE, you can generate the Selenium RC code. The Selenium-IDE can translate (using its Export menu item) its Selenium commands into a client-driver\u0026rsquo;s API function calls. See the Selenium-IDE chapter for specifics on exporting RC code from Selenium-IDE.\nInstallation Installation is rather a misnomer for Selenium. Selenium has a set of libraries available in the programming language of your choice. You could download them from the downloads page.\nOnce you\u0026rsquo;ve chosen a language to work with, you simply need to:\n Install the Selenium RC Server. Set up a programming project using a language specific client driver.  Installing Selenium Server The Selenium RC server is simply a Java jar file (selenium-server-standalone-.jar), which doesn\u0026rsquo;t require any special installation. Just downloading the zip file and extracting the server in the desired directory is sufficient.\nRunning Selenium Server Before starting any tests you must start the server. Go to the directory where Selenium RC\u0026rsquo;s server is located and run the following from a command-line console.\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar This can be simplified by creating a batch or shell executable file (.bat on Windows and .sh on Linux) containing the command above. Then make a shortcut to that executable on your desktop and simply double-click the icon to start the server.\nFor the server to run you\u0026rsquo;ll need Java installed and the PATH environment variable correctly configured to run it from the console. You can check that you have Java correctly installed by running the following on a console.\njava -version If you get a version number (which needs to be 1.5 or later), you\u0026rsquo;re ready to start using Selenium RC.\nUsing the Java Client Driver  Download Selenium java client driver zip from the SeleniumHQ downloads page. Extract selenium-java-.jar file Open your desired Java IDE (Eclipse, NetBeans, IntelliJ, Netweaver, etc.) Create a java project. Add the selenium-java-.jar files to your project as references. Add to your project classpath the file selenium-java-.jar. From Selenium-IDE, export a script to a Java file and include it in your Java project, or write your Selenium test in Java using the selenium-java-client API. The API is presented later in this chapter. You can either use JUnit, or TestNg to run your test, or you can write your own simple main() program. These concepts are explained later in this section. Run Selenium server from the console. Execute your test from the Java IDE or from the command-line.  For details on Java test project configuration, see the Appendix sections Configuring Selenium RC With Eclipse and Configuring Selenium RC With Intellij.\nUsing the Python Client Driver  Install Selenium via PIP, instructions linked at SeleniumHQ downloads page Either write your Selenium test in Python or export a script from Selenium-IDE to a python file. Run Selenium server from the console Execute your test from a console or your Python IDE  For details on Python client driver configuration, see the appendix Python Client Driver Configuration.\nUsing the .NET Client Driver  Download Selenium RC from the SeleniumHQ downloads page Extract the folder Download and install NUnit ( Note: You can use NUnit as your test engine. If you\u0026rsquo;re not familiar yet with NUnit, you can also write a simple main() function to run your tests; however NUnit is very useful as a test engine.) Open your desired .Net IDE (Visual Studio, SharpDevelop, MonoDevelop) Create a class library (.dll) Add references to the following DLLs: nmock.dll, nunit.core.dll, nunit. framework.dll, ThoughtWorks.Selenium.Core.dll, ThoughtWorks.Selenium.IntegrationTests.dll and ThoughtWorks.Selenium.UnitTests.dll Write your Selenium test in a .Net language (C#, VB.Net), or export a script from Selenium-IDE to a C# file and copy this code into the class file you just created. Write your own simple main() program or you can include NUnit in your project for running your test. These concepts are explained later in this chapter. Run Selenium server from console Run your test either from the IDE, from the NUnit GUI or from the command line  For specific details on .NET client driver configuration with Visual Studio, see the appendix .NET client driver configuration.\nUsing the Ruby Client Driver  If you do not already have RubyGems, install it from RubyForge. Run gem install selenium-client At the top of your test script, add require \u0026quot;selenium/client\u0026quot; Write your test script using any Ruby test harness (eg Test::Unit, Mini::Test or RSpec). Run Selenium RC server from the console. Execute your test in the same way you would run any other Ruby script.  For details on Ruby client driver configuration, see the Selenium-Client documentation_\nFrom Selenese to a Program The primary task for using Selenium RC is to convert your Selenese into a programming language. In this section, we provide several different language-specific examples.\nSample Test Script Let\u0026rsquo;s start with an example Selenese test script. Imagine recording the following test with Selenium-IDE.\n          open /    type q selenium rc   clickAndWait btnG    assertTextPresent Results * for selenium rc     Note: This example would work with the Google search page http://www.google.com\nSelenese as Programming Code Here is the test script exported (via Selenium-IDE) to each of the supported programming languages. If you have at least basic knowledge of an object- oriented programming language, you will understand how Selenium runs Selenese commands by reading one of these examples. To see an example in a specific language, select one of these buttons.\nCSharp using System; using System.Text; using System.Text.RegularExpressions; using System.Threading; using NUnit.Framework; using Selenium; namespace SeleniumTests { [TestFixture] public class NewTest { private ISelenium selenium; private StringBuilder verificationErrors; [SetUp] public void SetupTest() { selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start(); verificationErrors = new StringBuilder(); } [TearDown] public void TeardownTest() { try { selenium.Stop(); } catch (Exception) { // Ignore errors if unable to close the browser  } Assert.AreEqual(\u0026#34;\u0026#34;, verificationErrors.ToString()); } [Test] public void TheNewTest() { selenium.Open(\u0026#34;/\u0026#34;); selenium.Type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.Click(\u0026#34;btnG\u0026#34;); selenium.WaitForPageToLoad(\u0026#34;30000\u0026#34;); Assert.AreEqual(\u0026#34;selenium rc - Google Search\u0026#34;, selenium.GetTitle()); } } }  Java /** Add JUnit framework to your classpath if not already there * for this example to work */ package com.example.tests; import com.thoughtworks.selenium.*; import java.util.regex.Pattern; public class NewTest extends SeleneseTestCase { public void setUp() throws Exception { setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); } public void testNew() throws Exception { selenium.open(\u0026#34;/\u0026#34;); selenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.click(\u0026#34;btnG\u0026#34;); selenium.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(selenium.isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); } } Php \u0026lt;?php require_once \u0026#39;PHPUnit/Extensions/SeleniumTestCase.php\u0026#39;; class Example extends PHPUnit_Extensions_SeleniumTestCase { function setUp() { $this-\u0026gt;setBrowser(\u0026#34;*firefox\u0026#34;); $this-\u0026gt;setBrowserUrl(\u0026#34;http://www.google.com/\u0026#34;); } function testMyTestCase() { $this-\u0026gt;open(\u0026#34;/\u0026#34;); $this-\u0026gt;type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); $this-\u0026gt;click(\u0026#34;btnG\u0026#34;); $this-\u0026gt;waitForPageToLoad(\u0026#34;30000\u0026#34;); $this-\u0026gt;assertTrue($this-\u0026gt;isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); } } ?\u0026gt;  Python from selenium import selenium import unittest, time, re class NewTest(unittest.TestCase): def setUp(self): self.verificationErrors = [] self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() def test_new(self): sel = self.selenium sel.open(\u0026#34;/\u0026#34;) sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;) sel.click(\u0026#34;btnG\u0026#34;) sel.wait_for_page_to_load(\u0026#34;30000\u0026#34;) self.failUnless(sel.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;)) def tearDown(self): self.selenium.stop() self.assertEqual([], self.verificationErrors) Ruby require \u0026#34;selenium/client\u0026#34; require \u0026#34;test/unit\u0026#34; class NewTest \u0026lt; Test::Unit::TestCase def setup @verification_errors = [] if $selenium @selenium = $selenium else @selenium = Selenium::Client::Driver.new(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;, 60); @selenium.start end @selenium.set_context(\u0026#34;test_new\u0026#34;) end def teardown @selenium.stop unless $selenium assert_equal [], @verification_errors end def test_new @selenium.open \u0026#34;/\u0026#34; @selenium.type \u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34; @selenium.click \u0026#34;btnG\u0026#34; @selenium.wait_for_page_to_load \u0026#34;30000\u0026#34; assert @selenium.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;) end end In the next section we\u0026rsquo;ll explain how to build a test program using the generated code.\nProgramming Your Test Now we\u0026rsquo;ll illustrate how to program your own tests using examples in each of the supported programming languages. There are essentially two tasks:\n Generate your script into a programming language from Selenium-IDE, optionally modifying the result.\n Write a very simple main program that executes the generated code.\n  Optionally, you can adopt a test engine platform like JUnit or TestNG for Java, or NUnit for .NET if you are using one of those languages.\nHere, we show language-specific examples. The language-specific APIs tend to differ from one to another, so you\u0026rsquo;ll find a separate explanation for each.\n Java C# Python Ruby Perl, PHP  Java For Java, people use either JUnit or TestNG as the test engine.\nSome development environments like Eclipse have direct support for these via plug-ins. This makes it even easier. Teaching JUnit or TestNG is beyond the scope of this document however materials may be found online and there are publications available. If you are already a \u0026ldquo;java-shop\u0026rdquo; chances are your developers will already have some experience with one of these test frameworks.\nYou will probably want to rename the test class from \u0026ldquo;NewTest\u0026rdquo; to something of your own choosing. Also, you will need to change the browser-open parameters in the statement:\nselenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); The Selenium-IDE generated code will look like this. This example has comments added manually for additional clarity.\npackage com.example.tests; // We specify the package of our tests  import com.thoughtworks.selenium.*; // This is the driver\u0026#39;s import. You\u0026#39;ll use this for instantiating a  // browser and making it do what you need.  import java.util.regex.Pattern; // Selenium-IDE add the Pattern module because it\u0026#39;s sometimes used for  // regex validations. You can remove the module if it\u0026#39;s not used in your  // script.  public class NewTest extends SeleneseTestCase { // We create our Selenium test case  public void setUp() throws Exception { setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); // We instantiate and start the browser  } public void testNew() throws Exception { selenium.open(\u0026#34;/\u0026#34;); selenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;); selenium.click(\u0026#34;btnG\u0026#34;); selenium.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(selenium.isTextPresent(\u0026#34;Results * for selenium rc\u0026#34;)); // These are the real test steps  } } C# The .NET Client Driver works with Microsoft.NET. It can be used with any .NET testing framework like NUnit or the Visual Studio 2005 Team System.\nSelenium-IDE assumes you will use NUnit as your testing framework. You can see this in the generated code below. It includes the using statement for NUnit along with corresponding NUnit attributes identifying the role for each member function of the test class.\nYou will probably have to rename the test class from \u0026ldquo;NewTest\u0026rdquo; to something of your own choosing. Also, you will need to change the browser-open parameters in the statement:\nselenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;);  The generated code will look similar to this.\nusing System; using System.Text; using System.Text.RegularExpressions; using System.Threading; using NUnit.Framework; using Selenium; namespace SeleniumTests { [TestFixture] public class NewTest { private ISelenium selenium; private StringBuilder verificationErrors; [SetUp] public void SetupTest() { selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*iehta\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start(); verificationErrors = new StringBuilder(); } [TearDown] public void TeardownTest() { try { selenium.Stop(); } catch (Exception) { // Ignore errors if unable to close the browser  } Assert.AreEqual(\u0026#34;\u0026#34;, verificationErrors.ToString()); } [Test] public void TheNewTest() { // Open Google search engine.  selenium.Open(\u0026#34;http://www.google.com/\u0026#34;); // Assert Title of page.  Assert.AreEqual(\u0026#34;Google\u0026#34;, selenium.GetTitle()); // Provide search term as \u0026#34;Selenium OpenQA\u0026#34;  selenium.Type(\u0026#34;q\u0026#34;, \u0026#34;Selenium OpenQA\u0026#34;); // Read the keyed search term and assert it.  Assert.AreEqual(\u0026#34;Selenium OpenQA\u0026#34;, selenium.GetValue(\u0026#34;q\u0026#34;)); // Click on Search button.  selenium.Click(\u0026#34;btnG\u0026#34;); // Wait for page to load.  selenium.WaitForPageToLoad(\u0026#34;5000\u0026#34;); // Assert that \u0026#34;www.openqa.org\u0026#34; is available in search results.  Assert.IsTrue(selenium.IsTextPresent(\u0026#34;www.openqa.org\u0026#34;)); // Assert that page title is - \u0026#34;Selenium OpenQA - Google Search\u0026#34;  Assert.AreEqual(\u0026#34;Selenium OpenQA - Google Search\u0026#34;, selenium.GetTitle()); } } }  You can allow NUnit to manage the execution of your tests. Or alternatively, you can write a simple main() program that instantiates the test object and runs each of the three methods, SetupTest(), TheNewTest(), and TeardownTest() in turn.\nPython Pyunit is the test framework to use for Python.\nThe basic test structure is:\nfrom selenium import selenium # This is the driver\u0026#39;s import. You\u0026#39;ll use this class for instantiating a # browser and making it do what you need. import unittest, time, re # This are the basic imports added by Selenium-IDE by default. # You can remove the modules if they are not used in your script. class NewTest(unittest.TestCase): # We create our unittest test case def setUp(self): self.verificationErrors = [] # This is an empty array where we will store any verification errors # we find in our tests self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() # We instantiate and start the browser def test_new(self): # This is the test code. Here you should put the actions you need # the browser to do during your test. sel = self.selenium # We assign the browser to the variable \u0026#34;sel\u0026#34; (just to save us from  # typing \u0026#34;self.selenium\u0026#34; each time we want to call the browser). sel.open(\u0026#34;/\u0026#34;) sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34;) sel.click(\u0026#34;btnG\u0026#34;) sel.wait_for_page_to_load(\u0026#34;30000\u0026#34;) self.failUnless(sel.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;)) # These are the real test steps def tearDown(self): self.selenium.stop() # we close the browser (I\u0026#39;d recommend you to comment this line while # you are creating and debugging your tests) self.assertEqual([], self.verificationErrors) # And make the test fail if we found that any verification errors # were found Ruby Old (pre 2.0) versions of Selenium-IDE generate Ruby code that requires the old Selenium gem. Therefore, it is advisable to update any Ruby scripts generated by the IDE as follows:\n On line 1, change require \u0026quot;selenium\u0026quot; to require \u0026quot;selenium/client\u0026quot;\n On line 11, change Selenium::SeleniumDriver.new to Selenium::Client::Driver.new\n  You probably also want to change the class name to something more informative than \u0026ldquo;Untitled,\u0026rdquo; and change the test method\u0026rsquo;s name to something other than \u0026ldquo;test_untitled.\u0026rdquo;\nHere is a simple example created by modifying the Ruby code generated by Selenium IDE, as described above.\n# load the Selenium-Client gem require \u0026#34;selenium/client\u0026#34; # Load Test::Unit, Ruby\u0026#39;s default test framework. # If you prefer RSpec, see the examples in the Selenium-Client # documentation. require \u0026#34;test/unit\u0026#34; class Untitled \u0026lt; Test::Unit::TestCase # The setup method is called before each test. def setup # This array is used to capture errors and display them at the # end of the test run. @verification_errors = [] # Create a new instance of the Selenium-Client driver. @selenium = Selenium::Client::Driver.new \\ :host =\u0026gt; \u0026#34;localhost\u0026#34;, :port =\u0026gt; 4444, :browser =\u0026gt; \u0026#34;*chrome\u0026#34;, :url =\u0026gt; \u0026#34;http://www.google.com/\u0026#34;, :timeout_in_second =\u0026gt; 60 # Start the browser session @selenium.start # Print a message in the browser-side log and status bar # (optional). @selenium.set_context(\u0026#34;test_untitled\u0026#34;) end # The teardown method is called after each test. def teardown # Stop the browser session. @selenium.stop # Print the array of error messages, if any. assert_equal [], @verification_errors end # This is the main body of your test. def test_untitled # Open the root of the site we specified when we created the # new driver instance, above. @selenium.open \u0026#34;/\u0026#34; # Type \u0026#39;selenium rc\u0026#39; into the field named \u0026#39;q\u0026#39; @selenium.type \u0026#34;q\u0026#34;, \u0026#34;selenium rc\u0026#34; # Click the button named \u0026#34;btnG\u0026#34; @selenium.click \u0026#34;btnG\u0026#34; # Wait for the search results page to load. # Note that we don\u0026#39;t need to set a timeout here, because that # was specified when we created the new driver instance, above. @selenium.wait_for_page_to_load begin # Test whether the search results contain the expected text. # Notice that the star (*) is a wildcard that matches any # number of characters. assert @selenium.is_text_present(\u0026#34;Results * for selenium rc\u0026#34;) rescue Test::Unit::AssertionFailedError # If the assertion fails, push it onto the array of errors. @verification_errors \u0026lt;\u0026lt; $! end end end Perl, PHP The members of the documentation team have not used Selenium RC with Perl or PHP. If you are using Selenium RC with either of these two languages please contact the Documentation Team (see the chapter on contributing). We would love to include some examples from you and your experiences, to support Perl and PHP users.\nLearning the API The Selenium RC API uses naming conventions that, assuming you understand Selenese, much of the interface\nwill be self-explanatory. Here, however, we explain the most critical and possibly less obvious aspects.\nStarting the Browser CSharp selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;); selenium.Start();  Java setUp(\u0026#34;http://www.google.com/\u0026#34;, \u0026#34;*firefox\u0026#34;); Perl my $sel = Test::WWW::Selenium-\u0026gt;new( host =\u0026gt; \u0026#34;localhost\u0026#34;, port =\u0026gt; 4444, browser =\u0026gt; \u0026#34;*firefox\u0026#34;, browser_url =\u0026gt; \u0026#34;http://www.google.com/\u0026#34; ); Php $this-\u0026gt;setBrowser(\u0026#34;*firefox\u0026#34;); $this-\u0026gt;setBrowserUrl(\u0026#34;http://www.google.com/\u0026#34;); Python self.selenium = selenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;) self.selenium.start() Ruby @selenium = Selenium::ClientDriver.new(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.google.com/\u0026#34;, 10000); @selenium.start Each of these examples opens the browser and represents that browser by assigning a \u0026ldquo;browser instance\u0026rdquo; to a program variable. This program variable is then used to call methods from the browser. These methods execute the Selenium commands, i.e. like open or type or the verify commands.\nThe parameters required when creating the browser instance are:\n host Specifies the IP address of the computer where the server is located. Usually, this is the same machine as where the client is running, so in this case localhost is passed. In some clients this is an optional parameter.\n port Specifies the TCP/IP socket where the server is listening waiting for the client to establish a connection. This also is optional in some client drivers.\n browser The browser in which you want to run the tests. This is a required parameter.\n url The base url of the application under test. This is required by all the client libs and is integral information for starting up the browser-proxy-AUT communication.\n  Note that some of the client libraries require the browser to be started explicitly by calling its start() method.\nRunning Commands Once you have the browser initialized and assigned to a variable (generally named \u0026ldquo;selenium\u0026rdquo;) you can make it run Selenese commands by calling the respective methods from the browser variable. For example, to call the type method of the selenium object:\nselenium.type(\u0026#34;field-id\u0026#34;,\u0026#34;string to type\u0026#34;) In the background the browser will actually perform a type operation, essentially identical to a user typing input into the browser, by\nusing the locator and the string you specified during the method call.\nReporting Results Selenium RC does not have its own mechanism for reporting results. Rather, it allows you to build your reporting customized to your needs using features of your chosen programming language. That\u0026rsquo;s great, but what if you simply want something quick that\u0026rsquo;s already done for you? Often an existing library or test framework can meet your needs faster than developing your own test reporting code.\nTest Framework Reporting Tools Test frameworks are available for many programming languages. These, along with their primary function of providing a flexible test engine for executing your tests, include library code for reporting results. For example, Java has two commonly used test frameworks, JUnit and TestNG. .NET also has its own, NUnit.\nWe won\u0026rsquo;t teach the frameworks themselves here; that\u0026rsquo;s beyond the scope of this user guide. We will simply introduce the framework features that relate to Selenium along with some techniques you can apply. There are good books available on these test frameworks however along with information on the internet.\nTest Report Libraries Also available are third-party libraries specifically created for reporting test results in your chosen programming language. These often support a variety of formats such as HTML or PDF.\nWhat\u0026rsquo;s The Best Approach? Most people new to the testing frameworks will begin with the framework\u0026rsquo;s built-in reporting features. From there most will examine any available libraries as that\u0026rsquo;s less time consuming than developing your own. As you begin to use Selenium no doubt you will start putting in your own \u0026ldquo;print statements\u0026rdquo; for reporting progress. That may gradually lead to you developing your own reporting, possibly in parallel to using a library or test framework. Regardless, after the initial, but short, learning curve you will naturally develop what works best for your own situation.\nTest Reporting Examples To illustrate, we\u0026rsquo;ll direct you to some specific tools in some of the other languages supported by Selenium. The ones listed here are commonly used and have been used extensively (and therefore recommended) by the authors of this guide.\nTest Reports in Java  If Selenium Test cases are developed using JUnit then JUnit Report can be used to generate test reports.\n If Selenium Test cases are developed using TestNG then no external task is required to generate test reports. The TestNG framework generates an HTML report which list details of tests.\n ReportNG is a HTML reporting plug-in for the TestNG framework. It is intended as a replacement for the default TestNG HTML report. ReportNG provides a simple, colour-coded view of the test results.\n  Logging the Selenese Commands  Logging Selenium can be used to generate a report of all the Selenese commands in your test along with the success or failure of each. Logging Selenium extends the Java client driver to add this Selenese logging ability.  Test Reports for Python  When using Python Client Driver then HTMLTestRunner can be used to generate a Test Report.  Test Reports for Ruby  If RSpec framework is used for writing Selenium Test Cases in Ruby then its HTML report can be used to generate a test report.  Adding Some Spice to Your Tests Now we\u0026rsquo;ll get to the whole reason for using Selenium RC, adding programming logic to your tests. It\u0026rsquo;s the same as for any program. Program flow is controlled using condition statements and iteration. In addition you can report progress information using I/O. In this section we\u0026rsquo;ll show some examples of how programming language constructs can be combined with Selenium to solve common testing problems.\nYou will find as you transition from the simple tests of the existence of page elements to tests of dynamic functionality involving multiple web-pages and varying data that you will require programming logic for verifying expected results. Basically, the Selenium-IDE does not support iteration and standard condition statements. You can do some conditions by embedding javascript in Selenese parameters, however iteration is impossible, and most conditions will be much easier in a\nprogramming language. In addition, you may need exception handling for error recovery. For these reasons and others, we have written this section to illustrate the use of common programming techniques to give you greater \u0026lsquo;verification power\u0026rsquo; in your automated testing.\nThe examples in this section are written in C# and Java, although the code is simple and can be easily adapted to the other supported languages. If you have some basic knowledge of an object-oriented programming language you shouldn\u0026rsquo;t have difficulty understanding this section.\nIteration Iteration is one of the most common things people need to do in their tests. For example, you may want to to execute a search multiple times. Or, perhaps for verifying your test results you need to process a \u0026ldquo;result set\u0026rdquo; returned from a database.\nUsing the same Google search example we used earlier, let\u0026rsquo;s check the Selenium search results. This test could use the Selenese:\n          open /    type q selenium rc   clickAndWait btnG    assertTextPresent Results * for selenium rc    type q selenium ide   clickAndWait btnG    assertTextPresent Results * for selenium ide    type q selenium grid   clickAndWait btnG    assertTextPresent Results * for selenium grid     The code has been repeated to run the same steps 3 times. But multiple copies of the same code is not good program practice because it\u0026rsquo;s more work to maintain. By using a programming language, we can iterate over the search results for a more flexible and maintainable solution.\nIn C# // Collection of String values.  String[] arr = {\u0026#34;ide\u0026#34;, \u0026#34;rc\u0026#34;, \u0026#34;grid\u0026#34;}; // Execute loop for each String in array \u0026#39;arr\u0026#39;.  foreach (String s in arr) { sel.open(\u0026#34;/\u0026#34;); sel.type(\u0026#34;q\u0026#34;, \u0026#34;selenium \u0026#34; +s); sel.click(\u0026#34;btnG\u0026#34;); sel.waitForPageToLoad(\u0026#34;30000\u0026#34;); assertTrue(\u0026#34;Expected text: \u0026#34; +s+ \u0026#34; is missing on page.\u0026#34; , sel.isTextPresent(\u0026#34;Results * for selenium \u0026#34; + s)); }  Condition Statements To illustrate using conditions in tests we\u0026rsquo;ll start with an example. A common problem encountered while running Selenium tests occurs when an expected element is not available on page. For example, when running the following line:\nselenium.type(\u0026#34;q\u0026#34;, \u0026#34;selenium \u0026#34; +s); If element \u0026lsquo;q\u0026rsquo; is not on the page then an exception is thrown:\ncom.thoughtworks.selenium.SeleniumException: ERROR: Element q not found This can cause your test to abort. For some tests that\u0026rsquo;s what you want. But often that is not desirable as your test script has many other subsequent tests to perform.\nA better approach is to first validate whether the element is really present and then take alternatives when it it is not. Let\u0026rsquo;s look at this using Java.\n// If element is available on page then perform type operation.  if(selenium.isElementPresent(\u0026#34;q\u0026#34;)) { selenium.type(\u0026#34;q\u0026#34;, \u0026#34;Selenium rc\u0026#34;); } else { System.out.printf(\u0026#34;Element: \u0026#34; +q+ \u0026#34; is not available on page.\u0026#34;) } The advantage of this approach is to continue with test execution even if some UI elements are not available on page.\nExecuting JavaScript from Your Test JavaScript comes very handy in exercising an application which is not directly supported by selenium. The getEval method of selenium API can be used to execute JavaScript from selenium RC.\nConsider an application having check boxes with no static identifiers. In this case one could evaluate JavaScript from selenium RC to get ids of all check boxes and then exercise them.\npublic static String[] getAllCheckboxIds () { String script = \u0026#34;var inputId = new Array();\u0026#34;;// Create array in java script. \tscript += \u0026#34;var cnt = 0;\u0026#34;; // Counter for check box ids. \tscript += \u0026#34;var inputFields = new Array();\u0026#34;; // Create array in java script. \tscript += \u0026#34;inputFields = window.document.getElementsByTagName(\u0026#39;input\u0026#39;);\u0026#34;; // Collect input elements. \tscript += \u0026#34;for(var i=0; i\u0026lt;inputFields.length; i++) {\u0026#34;; // Loop through the collected elements. \tscript += \u0026#34;if(inputFields[i].id !=null \u0026#34; + \u0026#34;\u0026amp;\u0026amp; inputFields[i].id !=\u0026#39;undefined\u0026#39; \u0026#34; + \u0026#34;\u0026amp;\u0026amp; inputFields[i].getAttribute(\u0026#39;type\u0026#39;) == \u0026#39;checkbox\u0026#39;) {\u0026#34;; // If input field is of type check box and input id is not null. \tscript += \u0026#34;inputId[cnt]=inputFields[i].id ;\u0026#34; + // Save check box id to inputId array. \t\u0026#34;cnt++;\u0026#34; + // increment the counter. \t\u0026#34;}\u0026#34; + // end of if. \t\u0026#34;}\u0026#34;; // end of for. \tscript += \u0026#34;inputId.toString();\u0026#34; ;// Convert array in to string.\t\tString[] checkboxIds = selenium.getEval(script).split(\u0026#34;,\u0026#34;); // Split the string. \treturn checkboxIds; } To count number of images on a page:\nselenium.getEval(\u0026#34;window.document.images.length;\u0026#34;); Remember to use window object in case of DOM expressions as by default selenium window is referred to, not the test window.\nServer Options When the server is launched, command line options can be used to change the default server behaviour.\nRecall, the server is started by running the following.\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar To see the list of options, run the server with the -h option.\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -h You\u0026rsquo;ll see a list of all the options you can use with the server and a brief description of each. The provided descriptions will not always be enough, so we\u0026rsquo;ve provided explanations for some of the more important options.\nProxy Configuration If your AUT is behind an HTTP proxy which requires authentication then you should configure http.proxyHost, http.proxyPort, http.proxyUser and http.proxyPassword using the following command.\n$ java -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -Dhttp.proxyHost=proxy.com -Dhttp.proxyPort=8080 -Dhttp.proxyUser=username -Dhttp.proxyPassword=password Multi-Window Mode If you are using Selenium 1.0 you can probably skip this section, since multiwindow mode is the default behavior. However, prior to version 1.0, Selenium by default ran the application under test in a sub frame as shown here.\nSome applications didn\u0026rsquo;t run correctly in a sub frame, and needed to be loaded into the top frame of the window. The multi-window mode option allowed the AUT to run in a separate window rather than in the default frame where it could then have the top frame it required.\nFor older versions of Selenium you must specify multiwindow mode explicitly with the following option:\n-multiwindow  As of Selenium RC 1.0, if you want to run your test within a single frame (i.e. using the standard for earlier Selenium versions) you can state this to the Selenium Server using the option\n-singlewindow  Specifying the Firefox Profile Firefox will not run two instances simultaneously unless you specify a separate profile for each instance. Selenium RC 1.0 and later runs in a separate profile automatically, so if you are using Selenium 1.0, you can probably skip this section. However, if you\u0026rsquo;re using an older version of Selenium or if you need to use a specific profile for your tests (such as adding an https certificate or having some addons installed), you will need to explicitly specify the profile.\nFirst, to create a separate Firefox profile, follow this procedure. Open the Windows Start menu, select \u0026ldquo;Run\u0026rdquo;, then type and enter one of the following:\nfirefox.exe -profilemanager firefox.exe -P  Create the new profile using the dialog. Then when you run Selenium Server, tell it to use this new Firefox profile with the server command-line option -firefoxProfileTemplate and specify the path to the profile using its filename and directory path.\n-firefoxProfileTemplate \u0026#34;path to the profile\u0026#34;  Warning: Be sure to put your profile in a new folder separate from the default!!! The Firefox profile manager tool will delete all files in a folder if you delete a profile, regardless of whether they are profile files or not.\nMore information about Firefox profiles can be found in Mozilla\u0026rsquo;s Knowledge Base\nRun Selenese Directly Within the Server Using -htmlSuite You can run Selenese html files directly within the Selenium Server by passing the html file to the server\u0026rsquo;s command line. For instance:\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -htmlSuite \u0026#34;*firefox\u0026#34; \u0026#34;http://www.google.com\u0026#34; \u0026#34;c:\\absolute\\path\\to\\my\\HTMLSuite.html\u0026#34; \u0026#34;c:\\absolute\\path\\to\\my\\results.html\u0026#34; This will automatically launch your HTML suite, run all the tests and save a nice HTML report with the results.\nNote: When using this option, the server will start the tests and wait for a specified number of seconds for the test to complete; if the test doesn\u0026rsquo;t complete within that amount of time, the command will exit with a non-zero exit code and no results file will be generated.\nThis command line is very long so be careful when you type it. Note this requires you to pass in an HTML Selenese suite, not a single test. Also be aware the -htmlSuite option is incompatible with -interactive You cannot run both at the same time.\nSelenium Server Logging Server-Side Logs When launching selenium server the -log option can be used to record valuable debugging information reported by the Selenium Server to a text file.\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -log selenium.log This log file is more verbose than the standard console logs (it includes DEBUG level logging messages). The log file also includes the logger name, and the ID number of the thread that logged the message. For example:\n20:44:25 DEBUG [12] org.openqa.selenium.server.SeleniumDriverResourceHandler - Browser 465828/:top frame1 posted START NEW The message format is\nTIMESTAMP(HH:mm:ss) LEVEL [THREAD] LOGGER - MESSAGE This message may be multiline.\nBrowser-Side Logs JavaScript on the browser side (Selenium Core) also logs important messages; in many cases, these can be more useful to the end-user than the regular Selenium Server logs. To access browser-side logs, pass the -browserSideLog argument to the Selenium Server.\njava -jar selenium-server-standalone-\u0026lt;version-number\u0026gt;.jar -browserSideLog -browserSideLog must be combined with the -log argument, to log browserSideLogs (as well as all other DEBUG level logging messages) to a file.\nSpecifying the Path to a Specific Browser You can specify to Selenium RC a path to a specific browser. This is useful if you have different versions of the same browser and you wish to use a specific one. Also, this is used to allow your tests to run against a browser not directly supported by Selenium RC. When specifying the run mode, use the *custom specifier followed by the full path to the browser\u0026rsquo;s executable:\n*custom \u0026lt;path to browser\u0026gt;  Selenium RC Architecture Note: This topic tries to explain the technical implementation behind Selenium RC. It\u0026rsquo;s not fundamental for a Selenium user to know this, but could be useful for understanding some of the problems you might find in the future.\nTo understand in detail how Selenium RC Server works and why it uses proxy injection and heightened privilege modes you must first understand the same origin policy_.\nThe Same Origin Policy The main restriction that Selenium faces is the Same Origin Policy. This security restriction is applied by every browser in the market and its objective is to ensure that a site\u0026rsquo;s content will never be accessible by a script from another site. The Same Origin Policy dictates that any code loaded within the browser can only operate within that website\u0026rsquo;s domain. It cannot perform functions on another website. So for example, if the browser loads JavaScript code when it loads www.mysite.com, it cannot run that loaded code against www.mysite2.com\u0026ndash;even if that\u0026rsquo;s another of your sites. If this were possible, a script placed on any website you open would be able to read information on your bank account if you had the account page opened on other tab. This is called XSS (Cross-site Scripting).\nTo work within this policy, Selenium-Core (and its JavaScript commands that make all the magic happen) must be placed in the same origin as the Application Under Test (same URL).\nHistorically, Selenium-Core was limited by this problem since it was implemented in JavaScript. Selenium RC is not, however, restricted by the Same Origin Policy. Its use of the Selenium Server as a proxy avoids this problem. It, essentially, tells the browser that the browser is working on a single \u0026ldquo;spoofed\u0026rdquo; website that the Server provides.\nNote: You can find additional information about this topic on Wikipedia pages about Same Origin Policy and XSS.\nProxy Injection The first method Selenium used to avoid the The Same Origin Policy was Proxy Injection. In Proxy Injection Mode, the Selenium Server acts as a client-configured HTTP proxy1, that sits between the browser and the Application Under Test2. It then masks the AUT under a fictional URL (embedding Selenium-Core and the set of tests and delivering them as if they were coming from the same origin).\nHere is an architectural diagram.\nAs a test suite starts in your favorite language, the following happens:\n The client/driver establishes a connection with the selenium-RC server. Selenium RC server launches a browser (or reuses an old one) with a URL that injects Selenium-Core\u0026rsquo;s JavaScript into the browser-loaded web page. The client-driver passes a Selenese command to the server. The Server interprets the command and then triggers the corresponding JavaScript execution to execute that command within the browser. Selenium-Core instructs the browser to act on that first instruction, typically opening a page of the AUT. The browser receives the open request and asks for the website\u0026rsquo;s content from the Selenium RC server (set as the HTTP proxy for the browser to use). Selenium RC server communicates with the Web server asking for the page and once it receives it, it sends the page to the browser masking the origin to look like the page comes from the same server as Selenium-Core (this allows Selenium-Core to comply with the Same Origin Policy). The browser receives the web page and renders it in the frame/window reserved for it.   Heightened Privileges Browsers This workflow in this method is very similar to Proxy Injection but the main difference is that the browsers are launched in a special mode called Heightened Privileges, which allows websites to do things that are not commonly permitted (as doing XSS_, or filling file upload inputs and pretty useful stuff for Selenium). By using these browser modes, Selenium Core is able to directly open the AUT and read/interact with its content without having to pass the whole AUT through the Selenium RC server.\nHere is the architectural diagram.\nAs a test suite starts in your favorite language, the following happens:\n The client/driver establishes a connection with the selenium-RC server. Selenium RC server launches a browser (or reuses an old one) with a URL that will load Selenium-Core in the web page. Selenium-Core gets the first instruction from the client/driver (via another HTTP request made to the Selenium RC Server). Selenium-Core acts on that first instruction, typically opening a page of the AUT. The browser receives the open request and asks the Web Server for the page. Once the browser receives the web page, renders it in the frame/window reserved for it.  Handling HTTPS and Security Popups Many applications switch from using HTTP to HTTPS when they need to send encrypted information such as passwords or credit card information. This is common with many of today\u0026rsquo;s web applications. Selenium RC supports this.\nTo ensure the HTTPS site is genuine, the browser will need a security certificate. Otherwise, when the browser accesses the AUT using HTTPS, it will assume that application is not \u0026lsquo;trusted\u0026rsquo;. When this occurs the browser displays security popups, and these popups cannot be closed using Selenium RC.\nWhen dealing with HTTPS in a Selenium RC test, you must use a run mode that supports this and handles the security certificate for you. You specify the run mode when your test program initializes Selenium.\nIn Selenium RC 1.0 beta 2 and later use *firefox or *iexplore for the run mode. In earlier versions, including Selenium RC 1.0 beta 1, use *chrome or *iehta, for the run mode. Using these run modes, you will not need to install any special security certificates; Selenium RC will handle it for you.\nIn version 1.0 the run modes *firefox or *iexplore are recommended. However, there are additional run modes of *iexploreproxy and *firefoxproxy. These are provided for backwards compatibility only, and should not be used unless required by legacy test programs. Their use will present limitations with security certificate handling and with the running of multiple windows if your application opens additional browser windows.\nIn earlier versions of Selenium RC, *chrome or *iehta were the run modes that supported HTTPS and the handling of security popups. These were considered ‘experimental modes although they became quite stable and many people used them. If you are using Selenium 1.0 you do not need, and should not use, these older run modes.\nSecurity Certificates Explained Normally, your browser will trust the application you are testing by installing a security certificate which you already own. You can check this in your browser\u0026rsquo;s options or Internet properties (if you don\u0026rsquo;t know your AUT\u0026rsquo;s security certificate ask your system administrator). When Selenium loads your browser it injects code to intercept messages between the browser and the server. The browser now thinks untrusted software is trying to look like your application. It responds by alerting you with popup messages.\nTo get around this, Selenium RC, (again when using a run mode that support this) will install its own security certificate, temporarily, to your client machine in a place where the browser can access it. This tricks the browser into thinking it\u0026rsquo;s accessing a site different from your AUT and effectively suppresses the popups.\nAnother method used with earlier versions of Selenium was to install the Cybervillians security certificate provided with your Selenium installation. Most users should no longer need to do this however; if you are running Selenium RC in proxy injection mode, you may need to explicitly install this security certificate.\nSupporting Additional Browsers and Browser Configurations The Selenium API supports running against multiple browsers in addition to Internet Explorer and Mozilla Firefox. See the https://selenium.dev website for supported browsers. In addition, when a browser is not directly supported, you may still run your Selenium tests against a browser of your choosing by using the \u0026ldquo;*custom\u0026rdquo; run-mode (i.e. in place of *firefox or *iexplore) when your test application starts the browser. With this, you pass in the path to the browsers executable within the API call. This can also be done from the Server in interactive mode.\ncmd=getNewBrowserSession\u0026amp;1=*custom c:\\Program Files\\Mozilla Firefox\\MyBrowser.exe\u0026amp;2=http://www.google.com Running Tests with Different Browser Configurations Normally Selenium RC automatically configures the browser, but if you launch the browser using the \u0026ldquo;*custom\u0026rdquo; run mode, you can force Selenium RC to launch the browser as-is, without using an automatic configuration.\nFor example, you can launch Firefox with a custom configuration like this:\ncmd=getNewBrowserSession\u0026amp;1=*custom c:\\Program Files\\Mozilla Firefox\\firefox.exe\u0026amp;2=http://www.google.com Note that when launching the browser this way, you must manually configure the browser to use the Selenium Server as a proxy. Normally this just means opening your browser preferences and specifying \u0026ldquo;localhost:4444\u0026rdquo; as an HTTP proxy, but instructions for this can differ radically from browser to browser. Consult your browser\u0026rsquo;s documentation for details.\nBe aware that Mozilla browsers can vary in how they start and stop. One may need to set the MOZ_NO_REMOTE environment variable to make Mozilla browsers behave a little more predictably. Unix users should avoid launching the browser using a shell script; it\u0026rsquo;s generally better to use the binary executable (e.g. firefox-bin) directly.\nTroubleshooting Common Problems When getting started with Selenium RC there\u0026rsquo;s a few potential problems that are commonly encountered. We present them along with their solutions here.\nUnable to Connect to Server When your test program cannot connect to the Selenium Server, Selenium throws an exception in your test program. It should display this message or a similar one:\n\u0026#34;Unable to connect to remote server (Inner Exception Message: No connection could be made because the target machine actively refused it )\u0026#34; (using .NET and XP Service Pack 2)  If you see a message like this, be sure you started the Selenium Server. If so, then there is a problem with the connectivity between the Selenium Client Library and the Selenium Server.\nWhen starting with Selenium RC, most people begin by running their test program (with a Selenium Client Library) and the Selenium Server on the same machine. To do this use \u0026ldquo;localhost\u0026rdquo; as your connection parameter. We recommend beginning this way since it reduces the influence of potential networking problems which you\u0026rsquo;re getting started. Assuming your operating system has typical networking and TCP/IP settings you should have little difficulty. In truth, many people choose to run the tests this way.\nIf, however, you do want to run Selenium Server on a remote machine, the connectivity should be fine assuming you have valid TCP/IP connectivity between the two machines.\nIf you have difficulty connecting, you can use common networking tools like ping, telnet, ifconfig(Unix)/ipconfig (Windows), etc to ensure you have a valid network connection. If unfamilar with these, your system administrator can assist you.\nUnable to Load the Browser Ok, not a friendly error message, sorry, but if the Selenium Server cannot load the browser you will likely see this error.\n(500) Internal Server Error This could be caused by\n Firefox (prior to Selenium 1.0) cannot start because the browser is already open and you did not specify a separate profile. See the section on Firefox profiles under Server Options. The run mode you\u0026rsquo;re using doesn\u0026rsquo;t match any browser on your machine. Check the parameters you passed to Selenium when you program opens the browser. You specified the path to the browser explicitly (using \u0026ldquo;*custom\u0026rdquo;\u0026ndash;see above) but the path is incorrect. Check to be sure the path is correct. Also check the user group to be sure there are no known issues with your browser and the \u0026ldquo;*custom\u0026rdquo; parameters.  Selenium Cannot Find the AUT If your test program starts the browser successfully, but the browser doesn\u0026rsquo;t display the website you\u0026rsquo;re testing, the most likely cause is your test program is not using the correct URL.\nThis can easily happen. When you use Selenium-IDE to export your script, it inserts a dummy URL. You must manually change the URL to the correct one for your application to be tested.\nFirefox Refused Shutdown While Preparing a Profile This most often occurs when you run your Selenium RC test program against Firefox, but you already have a Firefox browser session running and, you didn\u0026rsquo;t specify a separate profile when you started the Selenium Server. The error from the test program looks like this:\nError: java.lang.RuntimeException: Firefox refused shutdown while preparing a profile  Here\u0026rsquo;s the complete error message from the server:\n16:20:03.919 INFO - Preparing Firefox profile... 16:20:27.822 WARN - GET /selenium-server/driver/?cmd=getNewBrowserSession\u0026amp;1=*fir efox\u0026amp;2=http%3a%2f%2fsage-webapp1.qa.idc.com HTTP/1.1 java.lang.RuntimeException: Firefox refused shutdown while preparing a profile at org.openqa.selenium.server.browserlaunchers.FirefoxCustomProfileLaunc her.waitForFullProfileToBeCreated(FirefoxCustomProfileLauncher.java:277) ... Caused by: org.openqa.selenium.server.browserlaunchers.FirefoxCustomProfileLaunc her$FileLockRemainedException: Lock file still present! C:\\DOCUME~1\\jsvec\\LOCALS ~1\\Temp\\customProfileDir203138\\parent.lock  To resolve this, see the section on Specifying a Separate Firefox Profile\nVersioning Problems Make sure your version of Selenium supports the version of your browser. For example, Selenium RC 0.92 does not support Firefox 3. At times you may be lucky (I was). But don\u0026rsquo;t forget to check which browser versions are supported by the version of Selenium you are using. When in doubt, use the latest release version of Selenium with the most widely used version of your browser.\nError message: \u0026ldquo;(Unsupported major.minor version 49.0)\u0026rdquo; while starting server This error says you\u0026rsquo;re not using a correct version of Java. The Selenium Server requires Java 1.5 or higher.\nTo check double-check your java version, run this from the command line.\njava -version You should see a message showing the Java version.\njava version \u0026#34;1.5.0_07\u0026#34; Java(TM) 2 Runtime Environment, Standard Edition (build 1.5.0_07-b03) Java HotSpot(TM) Client VM (build 1.5.0_07-b03, mixed mode) If you see a lower version number, you may need to update the JRE, or you may simply need to add it to your PATH environment variable.\n404 error when running the getNewBrowserSession command If you\u0026rsquo;re getting a 404 error while attempting to open a page on \u0026ldquo;http://www.google.com/selenium-server/\u0026quot;, then it must be because the Selenium Server was not correctly configured as a proxy. The \u0026ldquo;selenium-server\u0026rdquo; directory doesn\u0026rsquo;t exist on google.com; it only appears to exist when the proxy is properly configured. Proxy Configuration highly depends on how the browser is launched with firefox, iexplore, opera, or custom.\n iexplore: If the browser is launched using *iexplore, you could be having a problem with Internet Explorer\u0026rsquo;s proxy settings. Selenium Server attempts To configure the global proxy settings in the Internet Options Control Panel. You must make sure that those are correctly configured when Selenium Server launches the browser. Try looking at your Internet Options control panel. Click on the \u0026ldquo;Connections\u0026rdquo; tab and click on \u0026ldquo;LAN Settings\u0026rdquo;.\n If you need to use a proxy to access the application you want to test, you\u0026rsquo;ll need to start Selenium Server with \u0026ldquo;-Dhttp.proxyHost\u0026rdquo;; see the Proxy Configuration_ for more details. You may also try configuring your proxy manually and then launching the browser with *custom, or with *iehta browser launcher.   custom: When using *custom you must configure the proxy correctly(manually), otherwise you\u0026rsquo;ll get a 404 error. Double-check that you\u0026rsquo;ve configured your proxy settings correctly. To check whether you\u0026rsquo;ve configured the proxy correctly is to attempt to intentionally configure the browser incorrectly. Try configuring the browser to use the wrong proxy server hostname, or the wrong port. If you had successfully configured the browser\u0026rsquo;s proxy settings incorrectly, then the browser will be unable to connect to the Internet, which is one way to make sure that one is adjusting the relevant settings.\n For other browsers (*firefox, *opera) we automatically hard-code the proxy for you, and so there are no known issues with this functionality. If you\u0026rsquo;re encountering 404 errors and have followed this user guide carefully post your results to user group for some help from the user community.\n  Permission Denied Error The most common reason for this error is that your session is attempting to violate the same-origin policy by crossing domain boundaries (e.g., accesses a page from http://domain1 and then accesses a page from http://domain2) or switching protocols (moving from http://domainX to https://domainX).\nThis error can also occur when JavaScript attempts to find UI objects which are not yet available (before the page has completely loaded), or are no longer available (after the page has started to be unloaded). This is most typically encountered with AJAX pages which are working with sections of a page or subframes that load and/or reload independently of the larger page.\nThis error can be intermittent. Often it is impossible to reproduce the problem with a debugger because the trouble stems from race conditions which are not reproducible when the debugger\u0026rsquo;s overhead is added to the system. Permission issues are covered in some detail in the tutorial. Read the section about the The Same Origin Policy, Proxy Injection carefully.\nHandling Browser Popup Windows There are several kinds of \u0026ldquo;Popups\u0026rdquo; that you can get during a Selenium test. You may not be able to close these popups by running selenium commands if they are initiated by the browser and not your AUT. You may need to know how to manage these. Each type of popup needs to be addressed differently.\n HTTP basic authentication dialogs: These dialogs prompt for a username/password to login to the site. To login to a site that requires HTTP basic authentication, use a username and password in the URL, as described in RFC 1738_, like this: open(\u0026ldquo;http://myusername:myuserpassword@myexample.com/blah/blah/blah\u0026quot;).\n SSL certificate warnings: Selenium RC automatically attempts to spoof SSL certificates when it is enabled as a proxy; see more on this in the section on HTTPS. If your browser is configured correctly, you should never see SSL certificate warnings, but you may need to configure your browser to trust our dangerous \u0026ldquo;CyberVillains\u0026rdquo; SSL certificate authority. Again, refer to the HTTPS section for how to do this.\n modal JavaScript alert/confirmation/prompt dialogs: Selenium tries to conceal those dialogs from you (by replacing window.alert, window.confirm and window.prompt) so they won\u0026rsquo;t stop the execution of your page. If you\u0026rsquo;re seeing an alert pop-up, it\u0026rsquo;s probably because it fired during the page load process, which is usually too early for us to protect the page. Selenese contains commands for asserting or verifying alert and confirmation popups. See the sections on these topics in Chapter 4.\n  On Linux, why isn\u0026rsquo;t my Firefox browser session closing? On Unix/Linux you must invoke \u0026ldquo;firefox-bin\u0026rdquo; directly, so make sure that executable is on the path. If executing Firefox through a shell script, when it comes time to kill the browser Selenium RC will kill the shell script, leaving the browser running. You can specify the path to firefox-bin directly, like this.\ncmd=getNewBrowserSession\u0026amp;1=*firefox /usr/local/firefox/firefox-bin\u0026amp;2=http://www.google.com Firefox *chrome doesn\u0026rsquo;t work with custom profile Check Firefox profile folder -\u0026gt; prefs.js -\u0026gt; user_pref(\u0026ldquo;browser.startup.page\u0026rdquo;, 0); Comment this line like this: \u0026ldquo;//user_pref(\u0026ldquo;browser.startup.page\u0026rdquo;, 0);\u0026rdquo; and try again.\nIs it ok to load a custom pop-up as the parent page is loading (i.e., before the parent page\u0026rsquo;s javascript window.onload() function runs)? No. Selenium relies on interceptors to determine window names as they are being loaded. These interceptors work best in catching new windows if the windows are loaded AFTER the onload() function. Selenium may not recognize windows loaded before the onload function.\nFirefox on Linux On Unix/Linux, versions of Selenium before 1.0 needed to invoke \u0026ldquo;firefox-bin\u0026rdquo; directly, so if you are using a previous version, make sure that the real executable is on the path.\nOn most Linux distributions, the real firefox-bin is located on:\n/usr/lib/firefox-x.x.x/  Where the x.x.x is the version number you currently have. So, to add that path to the user\u0026rsquo;s path. you will have to add the following to your .bashrc file:\nexport PATH=\u0026#34;$PATH:/usr/lib/firefox-x.x.x/\u0026#34; If necessary, you can specify the path to firefox-bin directly in your test, like this:\n\u0026#34;*firefox /usr/lib/firefox-x.x.x/firefox-bin\u0026#34; IE and Style Attributes If you are running your tests on Internet Explorer and you cannot locate elements using their style attribute. For example:\n//td[@style=\u0026#34;background-color:yellow\u0026#34;] This would work perfectly in Firefox, Opera or Safari but not with IE. IE interprets the keys in @style as uppercase. So, even if the source code is in lowercase, you should use:\n//td[@style=\u0026#34;BACKGROUND-COLOR:yellow\u0026#34;] This is a problem if your test is intended to work on multiple browsers, but you can easily code your test to detect the situation and try the alternative locator that only works in IE.\nError encountered - \u0026ldquo;Cannot convert object to primitive value\u0026rdquo; with shut down of *googlechrome browser To avoid this error you have to start browser with an option that disables same origin policy checks:\nselenium.start(\u0026#34;commandLineFlags=--disable-web-security\u0026#34;); Error encountered in IE - \u0026ldquo;Couldn\u0026rsquo;t open app window; is the pop-up blocker enabled?\u0026rdquo; To avoid this error you have to configure the browser: disable the popup blocker AND uncheck \u0026lsquo;Enable Protected Mode\u0026rsquo; option in Tools \u0026gt;\u0026gt; Options \u0026gt;\u0026gt; Security.\n The proxy is a third person in the middle that passes the ball between the two parts. It acts as a \u0026ldquo;web server\u0026rdquo; that delivers the AUT to the browser. Being a proxy gives Selenium Server the capability of \u0026ldquo;lying\u0026rdquo; about the AUT\u0026rsquo;s real URL.\n[return] The browser is launched with a configuration profile that has set localhost:4444 as the HTTP proxy, this is why any HTTP request that the browser does will pass through Selenium server and the response will pass through it and not from the real server. [return]   "
},
{
	"uri": "https://selenium.dev/documentation/fr/getting_started/quick/",
	"title": "Tour rapide",
	"tags": [],
	"description": "",
	"content": " Selenium n\u0026rsquo;est pas juste un outil ou une API mais est composé de nombreux outils.\nWebDriver Si vous débutez dans l\u0026rsquo;automatisation de test de site web desktop vous allez utiliser les APIs WebDriver. WebDriver utilise les APIs d\u0026rsquo;automatisation fournies par les distributeurs de navigateur pour les contrôler et exécuter les tests. C\u0026rsquo;est comme si un utilisateur réel utilisait le navigateur. Puisque WebDriver n\u0026rsquo;a pas besoin que ses APIs soient compilées avec le code de l\u0026rsquo;application testée, il est non intrusif par nature. Ainsi vous testez exactement l\u0026rsquo;application qui sera en production.\nIDE IDE (Integrated Development Environment) est l\u0026rsquo;outil que vous utilisez pour développer vos cas de test Selenium. Il s\u0026rsquo;agit d\u0026rsquo;un Chrome facile à utiliser et l\u0026rsquo;extension Firefox et est généralement le moyen le plus efficace de développer cas de test. Il enregistre pour vous les actions des utilisateurs dans le navigateur, en utilisant commandes Selenium existantes, avec des paramètres définis par le contexte de cet élément. Ce n\u0026rsquo;est pas seulement un gain de temps, mais aussi un excellent moyen d\u0026rsquo;apprentissage de la syntaxe du script Selenium.\nGrid Peu après le développement de tests basés sur WebDriver, il se peut que vous rencontriez le besoin d\u0026rsquo;exécuter ceux-ci sur des combinaisons différentes de navigateurs / système d\u0026rsquo;exploitation. C\u0026rsquo;est ici que Grid intervient pour vous aider.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/introduction/on_test_automation/",
	"title": "A propos du test automatisé",
	"tags": [],
	"description": "",
	"content": " Commencez par vous demander si vous avez vraiment besoin ou non d\u0026rsquo;un navigateur. Il est probable qu\u0026rsquo;à un moment donné, si vous travaillez sur une application Web complexe, vous devrez ouvrir un navigateur et le tester.\nLes tests fonctionnels pour l\u0026rsquo;utilisateur final, tels que les tests au sélénium, sont cependant coûteux à exécuter. En outre, ils nécessitent généralement une infrastructure substantielle être en place pour fonctionner efficacement. C\u0026rsquo;est une bonne règle de toujours se demander si ce que l\u0026rsquo;on veut tester peut être fait en utilisant des approches de test plus légères telles que des tests unitaires ou avec une approche de niveau inférieur.\nUne fois que vous avez déterminé que vous êtes dans le domaine des tests de navigateurs Web, et vous avez votre environnement Selenium prêt à commencer à écrire des tests, vous effectuerez généralement une combinaison de trois étapes:\n Configurer les données Effectuer un ensemble discret d\u0026rsquo;actions Évaluez les résultats  Vous voudrez garder ces étapes aussi courtes que possible; une ou deux opérations devraient suffire la plupart du temps. L\u0026rsquo;automatisation des navigateurs a la réputation d\u0026rsquo;être \u0026ldquo;feuilletée\u0026rdquo;, mais en réalité, c\u0026rsquo;est parce que les utilisateurs en demandent souvent trop. Dans les chapitres suivants, nous reviendrons sur les techniques que vous pouvez utiliser pour atténuer les problèmes intermittents apparents dans les tests, en particulier sur la façon de surmonter les conditions de course entre le navigateur et WebDriver.\nGarder vos tests courts et en utilisant le navigateur Web uniquement lorsque vous n\u0026rsquo;avez absolument aucune alternative, vous pouvez avoir de nombreuses tâches avec un flocon de neige minimal.\nUn avantage distinct des tests au sélénium est leur capacité inhérente à tester tous les composants de l\u0026rsquo;application, du backend au frontend, du point de vue d\u0026rsquo;un utilisateur. En d\u0026rsquo;autres termes, alors que les tests fonctionnels peuvent être coûteux à exécuter, ils englobent également de grandes portions critiques pour l\u0026rsquo;entreprise à la fois.\nExigences de test Comme mentionné précédemment, les tests au sélénium peuvent être coûteux à exécuter. Dans quelle mesure cela dépend du navigateur sur lequel vous exécutez les tests, mais historiquement, le comportement des navigateurs a tellement varié qu\u0026rsquo;il a souvent était un objectif déclaré de contre-tester avec plusieurs navigateurs.\nSelenium vous permet d\u0026rsquo;exécuter les mêmes instructions sur plusieurs navigateurs sur plusieurs systèmes d\u0026rsquo;exploitation, mais l\u0026rsquo;énumération de tous les navigateurs possibles, leurs différentes versions et les nombreux systèmes d\u0026rsquo;exploitation sur lesquels ils s\u0026rsquo;exécutent deviendra rapidement une entreprise non triviale.\nCommençons par un exemple Larry a écrit un site Web qui permet aux utilisateurs de commander leur licornes personnalisées.\nLe flux de travail général (ce que nous appellerons le \u0026ldquo;chemin heureux\u0026rdquo;) est quelque chose comme ça:\n Créer un compte Configurer la licorne Ajoutez-le au panier Vérifiez et payez Donnez votre avis sur la licorne  Il serait tentant d\u0026rsquo;écrire un grand script Selenium pour effectuer toutes ces opérations, beaucoup essaieront. Résister à la tentation! Cela entraînera un test qui a) prend beaucoup de temps, b) sera soumis à des problèmes courants concernant les problèmes de synchronisation du rendu de page, et c) est telle qu\u0026rsquo;en cas d\u0026rsquo;échec, il ne vous donnera pas une méthode concise et \u0026ldquo;lisible\u0026rdquo; pour diagnostiquer ce qui a mal tourné.\nLa stratégie préférée pour tester ce scénario serait pour le décomposer en une série de tests indépendants et rapides, chacun a une «raison» d\u0026rsquo;exister.\nImaginons que vous souhaitiez tester la deuxième étape: Configuration de votre licorne. Il effectuera les actions suivantes:\n Créer un compte Configurer une licorne  Notez que nous ignorons le reste de ces étapes, nous testerons le reste du workflow dans d\u0026rsquo;autres petits cas de test discrets après avoir fini avec celui-ci.\nPour commencer, vous devez créer un compte. Vous avez ici quelques choix à faire:\n Voulez-vous utiliser un compte existant? Voulez-vous créer un nouveau compte? Y a-t-il des propriétés spéciales d\u0026rsquo;un tel utilisateur qui doivent être pris en compte avant le début de la configuration?  Quelle que soit la façon dont vous répondez à cette question, la solution consiste à l\u0026rsquo;intégrer à la partie \u0026ldquo;configurer les données\u0026rdquo; du test. Si Larry a exposé une API qui vous permet (ou n\u0026rsquo;importe qui) pour créer et mettre à jour des comptes utilisateurs, assurez-vous de l\u0026rsquo;utiliser pour répondre à cette question. Si possible, vous souhaitez lancer le navigateur uniquement après avoir un utilisateur \u0026ldquo;en main\u0026rdquo;, dont vous pouvez simplement vous connecter avec les informations d\u0026rsquo;identification.\nSi chaque test pour chaque workflow commence par la création d\u0026rsquo;un compte utilisateur, plusieurs secondes seront ajoutées à l\u0026rsquo;exécution de chaque test. Appeler une API et parler à une base de données sont rapides, Opérations \u0026ldquo;sans tête\u0026rdquo; qui ne nécessitent pas le processus coûteux de ouvrir un navigateur, naviguer vers les bonnes pages, cliquer et attendre que les formulaires soient soumis, etc.\nIdéalement, vous pouvez traiter cette phase de configuration en une seule ligne de code, qui s\u0026rsquo;exécutera avant le lancement de tout navigateur:\nJava Python C# Ruby JavaScript Kotlin // Create a user who has read-only permissions--they can configure a unicorn, // but they do not have payment information set up, nor do they have // administrative privileges. At the time the user is created, its email // address and password are randomly generated--you don\u0026#39;t even need to // know them. User user = UserFactory.createCommonUser(); //This method is defined elsewhere.  // Log in as this user. // Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the // AccountPage object is returned by the loginAs method, allowing you to then // perform actions from the AccountPage. AccountPage accountPage = loginAs(user.getEmail(), user.getPassword());   # Create a user who has read-only permissions--they can configure a unicorn, # but they do not have payment information set up, nor do they have # administrative privileges. At the time the user is created, its email # address and password are randomly generated--you don\u0026#39;t even need to # know them. user = user_factory.create_common_user() #This method is defined elsewhere. # Log in as this user. # Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the # AccountPage object is returned by the loginAs method, allowing you to then # perform actions from the AccountPage. account_page = login_as(user.get_email(), user.get_password())   // Create a user who has read-only permissions--they can configure a unicorn, // but they do not have payment information set up, nor do they have // administrative privileges. At the time the user is created, its email // address and password are randomly generated--you don\u0026#39;t even need to // know them. User user = UserFactory.CreateCommonUser(); //This method is defined elsewhere.  // Log in as this user. // Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the // AccountPage object is returned by the loginAs method, allowing you to then // perform actions from the AccountPage. AccountPage accountPage = LoginAs(user.Email, user.Password);   # Create a user who has read-only permissions--they can configure a unicorn, # but they do not have payment information set up, nor do they have # administrative privileges. At the time the user is created, its email # address and password are randomly generated--you don\u0026#39;t even need to # know them. user = UserFactory.create_common_user #This method is defined elsewhere. # Log in as this user. # Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the # AccountPage object is returned by the loginAs method, allowing you to then # perform actions from the AccountPage. account_page = login_as(user.email, user.password)   // Create a user who has read-only permissions--they can configure a unicorn, // but they do not have payment information set up, nor do they have // administrative privileges. At the time the user is created, its email // address and password are randomly generated--you don\u0026#39;t even need to // know them. var user = userFactory.createCommonUser(); //This method is defined elsewhere.  // Log in as this user. // Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the // AccountPage object is returned by the loginAs method, allowing you to then // perform actions from the AccountPage. var accountPage = loginAs(user.email, user.password);   // Create a user who has read-only permissions--they can configure a unicorn, // but they do not have payment information set up, nor do they have // administrative privileges. At the time the user is created, its email // address and password are randomly generated--you don\u0026#39;t even need to // know them. val user = UserFactory.createCommonUser() //This method is defined elsewhere.  // Log in as this user. // Logging in on this site takes you to your personal \u0026#34;My Account\u0026#34; page, so the // AccountPage object is returned by the loginAs method, allowing you to then // perform actions from the AccountPage. val accountPage = loginAs(user.getEmail(), user.getPassword())     Comme vous pouvez l\u0026rsquo;imaginer, la UserFactory peut être étendue pour fournir des méthodes telles que createAdminUser () et createUserWithPayment (). Le fait est que ces deux lignes de code ne vous distraient pas du but ultime de ce test: configurer une licorne.\nLes subtilités du modèle d\u0026rsquo;objet de page sera discuté dans les chapitres suivants, mais nous présenterons le concept ici:\nVos tests doivent être composés d\u0026rsquo;actions, réalisée du point de vue de l\u0026rsquo;utilisateur, dans le cadre des pages du site. Ces pages sont stockées en tant qu\u0026rsquo;objets, qui contiendra des informations spécifiques sur la composition de la page Web et comment les actions sont effectuées - dont très peu devrait vous concerner en tant que testeur.\nQuel genre de licorne veux-tu? Vous voudrez peut-être du rose, mais pas nécessairement. Le violet a été assez populaire ces derniers temps. A-t-elle besoin de lunettes de soleil? Tatouages ​​étoiles? Ces choix, bien que difficiles, sont votre principale préoccupation en tant que testeur - vous devez vous assurer que votre centre de traitement des commandes envoie la bonne licorne à la bonne personne, et cela commence par ces choix.\nNotez que nulle part dans ce paragraphe nous ne parlons de boutons, des champs, des listes déroulantes, des boutons radio ou des formulaires Web. Vos tests ne devraient pas non plus! Vous voulez écrire votre code comme l\u0026rsquo;utilisateur essayant de résoudre son problème. Voici une façon de procéder (à partir de l\u0026rsquo;exemple précédent):\nJava Python C# Ruby JavaScript Kotlin // The Unicorn is a top-level Object--it has attributes, which are set here. // This only stores the values; it does not fill out any web forms or interact // with the browser in any way. Unicorn sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS); // Since we are already \u0026#34;on\u0026#34; the account page, we have to use it to get to the // actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method // takes us there. AddUnicornPage addUnicornPage = accountPage.addUnicorn(); // Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to // its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, // fill out the form, and click submit. UnicornConfirmationPage unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles);   # The Unicorn is a top-level Object--it has attributes, which are set here. # This only stores the values; it does not fill out any web forms or interact # with the browser in any way. sparkles = Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) # Since we\u0026#39;re already \u0026#34;on\u0026#34; the account page, we have to use it to get to the # actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method # takes us there. add_unicorn_page = account_page.add_unicorn() # Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to # its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, # fill out the form, and click submit. unicorn_confirmation_page = add_unicorn_page.create_unicorn(sparkles)   // The Unicorn is a top-level Object--it has attributes, which are set here. // This only stores the values; it does not fill out any web forms or interact // with the browser in any way. Unicorn sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.Purple, UnicornAccessories.Sunglasses, UnicornAdornments.StarTattoos); // Since we are already \u0026#34;on\u0026#34; the account page, we have to use it to get to the // actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method // takes us there. AddUnicornPage addUnicornPage = accountPage.AddUnicorn(); // Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to // its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, // fill out the form, and click submit. UnicornConfirmationPage unicornConfirmationPage = addUnicornPage.CreateUnicorn(sparkles);   # The Unicorn is a top-level Object--it has attributes, which are set here. # This only stores the values; it does not fill out any web forms or interact # with the browser in any way. sparkles = Unicorn.new(\u0026#39;Sparkles\u0026#39;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) # Since we\u0026#39;re already \u0026#34;on\u0026#34; the account page, we have to use it to get to the # actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method # takes us there. add_unicorn_page = account_page.add_unicorn # Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to # its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, # fill out the form, and click submit. unicorn_confirmation_page = add_unicorn_page.create_unicorn(sparkles)   // The Unicorn is a top-level Object--it has attributes, which are set here. // This only stores the values; it does not fill out any web forms or interact // with the browser in any way. var sparkles = new Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS); // Since we are already \u0026#34;on\u0026#34; the account page, we have to use it to get to the // actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method // takes us there.  var addUnicornPage = accountPage.addUnicorn(); // Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to // its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, // fill out the form, and click submit. var unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles);   // The Unicorn is a top-level Object--it has attributes, which are set here. // This only stores the values; it does not fill out any web forms or interact // with the browser in any way. val sparkles = Unicorn(\u0026#34;Sparkles\u0026#34;, UnicornColors.PURPLE, UnicornAccessories.SUNGLASSES, UnicornAdornments.STAR_TATTOOS) // Since we are already \u0026#34;on\u0026#34; the account page, we have to use it to get to the // actual place where you configure unicorns. Calling the \u0026#34;Add Unicorn\u0026#34; method // takes us there. val addUnicornPage = accountPage.addUnicorn() // Now that we\u0026#39;re on the AddUnicornPage, we will pass the \u0026#34;sparkles\u0026#34; object to // its createUnicorn() method. This method will take Sparkles\u0026#39; attributes, // fill out the form, and click submit. unicornConfirmationPage = addUnicornPage.createUnicorn(sparkles)     Maintenant que vous avez configuré votre licorne, vous devez passer à l\u0026rsquo;étape 3: vous assurer que cela a réellement fonctionné.\nJava Python C# Ruby JavaScript Kotlin // The exists() method from UnicornConfirmationPage will take the Sparkles // object--a specification of the attributes you want to see, and compare // them with the fields on the page. Assert.assertTrue(\u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;, unicornConfirmationPage.exists(sparkles));   # The exists() method from UnicornConfirmationPage will take the Sparkles # object--a specification of the attributes you want to see, and compare # them with the fields on the page. assert unicorn_confirmation_page.exists(sparkles), \u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;   // The exists() method from UnicornConfirmationPage will take the Sparkles // object--a specification of the attributes you want to see, and compare // them with the fields on the page. Assert.True(unicornConfirmationPage.Exists(sparkles), \u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;);   # The exists() method from UnicornConfirmationPage will take the Sparkles # object--a specification of the attributes you want to see, and compare # them with the fields on the page. expect(unicorn_confirmation_page.exists?(sparkles)).to be, \u0026#39;Sparkles should have been created, with all attributes intact\u0026#39;   // The exists() method from UnicornConfirmationPage will take the Sparkles // object--a specification of the attributes you want to see, and compare // them with the fields on the page. assert(unicornConfirmationPage.exists(sparkles), \u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;);   // The exists() method from UnicornConfirmationPage will take the Sparkles // object--a specification of the attributes you want to see, and compare // them with the fields on the page. assertTrue(\u0026#34;Sparkles should have been created, with all attributes intact\u0026#34;, unicornConfirmationPage.exists(sparkles))     Notez que le testeur n\u0026rsquo;a toujours rien fait d\u0026rsquo;autre que parler des licornes dans ce code - pas de boutons, pas de localisateurs, pas de commandes de navigateur. Cette méthode de modélisation de l\u0026rsquo;application vous permet de garder ces commandes de niveau test en place et immuables, même si Larry décide la semaine prochaine qu\u0026rsquo;il n\u0026rsquo;aime plus Ruby-on-Rails et décide de réimplémenter l\u0026rsquo;ensemble du site dans les dernières fixations Haskell avec un frontal Fortran.\nVos objets de page nécessiteront une petite maintenance afin de se conformer à la refonte du site, mais ces tests resteront les mêmes. En prenant cette conception de base, vous souhaiterez continuer à parcourir vos workflows avec le moins d\u0026rsquo;étapes possibles face au navigateur. Votre prochain workflow impliquera l\u0026rsquo;ajout d\u0026rsquo;une licorne au panier d\u0026rsquo;achat. Vous voudrez probablement de nombreuses itérations de ce test afin de vous assurer que le chariot conserve correctement son état: Y a-t-il plus d\u0026rsquo;une licorne dans le panier avant de commencer? Combien peuvent tenir dans le panier? Si vous en créez plusieurs avec le même nom et / ou les mêmes fonctionnalités, est-ce que cela cassera? Gardera-t-il seulement celui existant ou en ajoutera-t-il un autre?\nChaque fois que vous vous déplacez dans le flux de travail, vous voulez éviter d\u0026rsquo;avoir à créer un compte, connectez-vous en tant qu\u0026rsquo;utilisateur et configurez la licorne. Idéalement, vous pourrez créer un compte et pré-configurer une licorne via l\u0026rsquo;API ou la base de données. Il vous suffit ensuite de vous connecter en tant qu\u0026rsquo;utilisateur, de localiser Sparkles, et l\u0026rsquo;ajouter au panier.\nAutomatiser ou ne pas automatiser? L\u0026rsquo;automatisation est-elle toujours avantageuse? Quand faut-il décider d\u0026rsquo;automatiser le test cas?\nIl n\u0026rsquo;est pas toujours avantageux d\u0026rsquo;automatiser les cas de test. Il y a des moments où des tests manuels peuvent être plus appropriés. Par exemple, si l\u0026rsquo;utilisateur de l\u0026rsquo;application l\u0026rsquo;interface changera considérablement dans un avenir proche, alors toute automatisation pourrait avoir besoin d\u0026rsquo;être réécrit de toute façon. De plus, parfois, il n\u0026rsquo;y a tout simplement pas assez le temps de construire l\u0026rsquo;automatisation des tests. À court terme, les tests manuels peuvent être plus efficace. Si une demande a un délai très serré, il n’existe actuellement aucun l\u0026rsquo;automatisation des tests est disponible, et il est impératif que les tests soient effectués dans les ce délai, puis le test manuel est la meilleure solution.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/driver_idiosyncrasies/driver_specific_capabilities/",
	"title": "Capabilities spécifiques du Driver",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Firefox Define Capabilities using FirefoxOptions FirefoxOptions is the new way to define capabilities for the Firefox browser and should generally be used in preference to DesiredCapabilities.\nJava Python C# Ruby JavaScript Kotlin FirefoxOptions options = new FirefoxOptions(); options.addPreference(\u0026#34;network.proxy.type\u0026#34;, 0); driver = new RemoteWebDriver(options);   from selenium.webdriver.firefox.options import Options options = Options() options.headless = True driver = webdriver.Firefox(options=options)   var options = new FirefoxOptions(); options.Proxy.Kind = ProxyKind.Direct; var driver = new FirefoxDriver(options);   require \u0026#39;selenium-webdriver\u0026#39; opts = Selenium::WebDriver::Firefox::Options.new(args: [\u0026#39;-headless\u0026#39;]) driver = Selenium::WebDriver.for(:firefox, options: opts)   const { Builder } = require(\u0026#34;selenium-webdriver\u0026#34;); const firefox = require(\u0026#39;selenium-webdriver/firefox\u0026#39;); const options = new firefox.Options(); options.headless(); const driver = new Builder() .forBrowser(\u0026#39;firefox\u0026#39;) .setFirefoxOptions(options) .build();   val options = new FirefoxOptions() options.addPreference(\u0026#34;network.proxy.type\u0026#34;, 0) driver = RemoteWebDriver(options)     Setting a custom profile It is possible to create a custom profile for Firefox as demonstrated below.\nJava Python C# Ruby JavaScript Kotlin FirefoxProfile profile = new FirefoxProfile(); FirefoxOptions options = new FirefoxOptions(); options.setProfile(profile); driver = new RemoteWebDriver(options);   from selenium.webdriver.firefox.options import Options from selenium.webdriver.firefox.firefox_profile import FirefoxProfile options=Options() firefox_profile = FirefoxProfile() firefox_profile.set_preference(\u0026#34;javascript.enabled\u0026#34;, False) options.profile = firefox_profile   var options = new FirefoxOptions(); var profile = new FirefoxProfile(); options.Profile = profile; var driver = new RemoteWebDriver(options);   profile = Selenium::WebDriver::Firefox::Profile.new profile[\u0026#39;browser.download.dir\u0026#39;] = \u0026#34;/tmp/webdriver-downloads\u0026#34; options = Selenium::WebDriver::Firefox::Options.new(profile: profile) driver = Selenium::WebDriver.for :firefox, options: options   const { Builder } = require(\u0026#34;selenium-webdriver\u0026#34;); const firefox = require(\u0026#39;selenium-webdriver/firefox\u0026#39;); const options = new firefox.Options(); let profile = \u0026#39;/path to custom profile\u0026#39;; options.setProfile(profile); const driver = new Builder() .forBrowser(\u0026#39;firefox\u0026#39;) .setFirefoxOptions(options) .build();   val options = FirefoxOptions() options.profile = FirefoxProfile() driver = RemoteWebDriver(options)     Internet Explorer fileUploadDialogTimeout In some environments, Internet Explorer may timeout when opening the File Upload dialog. IEDriver has a default timeout of 1000ms, but you can increase the timeout using the fileUploadDialogTimeout capability.\nJava Python C# Ruby JavaScript Kotlin InternetExplorerOptions options = new InternetExplorerOptions(); options.waitForUploadDialogUpTo(Duration.ofSeconds(2)); WebDriver driver = new RemoteWebDriver(options);   options = webdriver.IeOptions options.file_upload_dialog_timeout(2000) driver = webdriver.Ie(ie_driver_path, options=options)   var options = new InternetExplorerOptions(); options.FileUploadDialogTimeout = TimeSpan.FromMilliseconds(2000); var driver = new RemoteWebDriver(options);   options = Selenium::WebDriver::IE::Options.new options.file_upload_dialog_timeout = 2000 driver = Selenium::WebDriver.for(:ie, options: options)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    val options = InternetExplorerOptions() options.waitForUploadDialogUpTo(Duration.ofSeconds(2)) val driver = RemoteWebDriver(options)     "
},
{
	"uri": "https://selenium.dev/documentation/fr/grid/components_of_a_grid/",
	"title": "Composant d&#39;une Grid",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Hub  Intermediary and manager Accepts requests to run tests Takes instructions from client and executes them remotely on the nodes Manages threads  A Hub is a central point where all your tests are sent. Each Selenium Grid consists of exactly one hub. The hub needs to be reachable from the respective clients (i.e. CI server, Developer machine etc.) The hub will connect one or more nodes that tests will be delegated to.\nNodes  Where the browsers live Registers itself to the hub and communicates its capabilities Receives requests from the hub and executes them  Nodes are different Selenium instances that will execute tests on individual computer systems. There can be many nodes in a grid. The machines which are nodes do not need to be the same platform or have the same browser selection as that of the hub or the other nodes. A node on Windows might have the capability of offering Internet Explorer as a browser option, whereas this wouldn\u0026rsquo;t be possible on Linux or Mac.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/front_matter/typographical_conventions/",
	"title": "Conventions typographique",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Capitalisation of titles One should avoid title capitalisation, such as A Very Fine Heading, and instead go for A very fine heading. Gratutious capitalisation, or title case, often show a misunderstanding of – or a disregard for – orthographic conventions. We prefer what is known as sentence case, with a single initial capital to start headers.\nLine length When editing the documentation’s source, which is written in plain HTML, limit your line lengths to around 72 characters.\nSome of us take this one step further and use what is called semantic linefeeds, which is a technique whereby the HTML source lines, which are not read by the public, are split at ‘natural breaks’ in the prose. In other words, sentences are split at natural breaks between clauses. Instead of fussing with the lines of each paragraph so that they all end near the right margin, linefeeds can be added anywhere that there is a break between ideas.\nThis can make diffs very easy to read when collaborating through git, but it is not something we enforce contributors to use.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/guidelines_and_recommendations/domain_specific_language/",
	"title": "Domain specific language",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n A domain specific language (DSL) is a system which provides the user with an expressive means of solving a problem. It allows a user to interact with the system on their terms – not just programmer-speak.\nYour users, in general, do not care how your site looks. They do not care about the decoration, animations, or graphics. They want to use your system to push their new employees through the process with minimal difficulty; they want to book travel to Alaska; they want to configure and buy unicorns at a discount. Your job as tester is to come as close as you can to “capturing” this mind-set. With that in mind, we set about “modeling” the application you are working on, such that the test scripts (the user\u0026rsquo;s only pre-release proxy) “speak” for, and represent the user.\nWith Selenium, DSL is usually represented by methods, written to make the API simple and readable – they enable a report between the developers and the stakeholders (users, product owners, business intelligence specialists, etc.).\nBenefits  Readable: Business stakeholders can understand it. Writable: Easy to write, avoids unnecessary duplication. Extensible: Functionality can (reasonably) be added without breaking contracts and existing functionality. Maintainable: By leaving the implementation details out of test cases, you are well-insulated against changes to the AUT*.  Java Here is an example of a reasonable DSL method in Java. For brevity\u0026rsquo;s sake, it assumes the driver object is pre-defined and available to the method.\n/** * Takes a username and password, fills out the fields, and clicks \u0026#34;login\u0026#34;. * @return An instance of the AccountPage */ public AccountPage loginAsUser(String username, String password) { WebElement loginField = driver.findElement(By.id(\u0026#34;loginField\u0026#34;)); loginField.clear(); loginField.sendKeys(username); // Fill out the password field. The locator we\u0026#39;re using is \u0026#34;By.id\u0026#34;, and we should  // have it defined elsewhere in the class.  WebElement passwordField = driver.findElement(By.id(\u0026#34;password\u0026#34;)); passwordField.clear(); passwordField.sendKeys(password); // Click the login button, which happens to have the id \u0026#34;submit\u0026#34;.  driver.findElement(By.id(\u0026#34;submit\u0026#34;)).click(); // Create and return a new instance of the AccountPage (via the built-in Selenium  // PageFactory).  return PageFactory.newInstance(AccountPage.class); } This method completely abstracts the concepts of input fields, buttons, clicking, and even pages from your test code. Using this approach, all a tester has to do is call this method. This gives you a maintenance advantage: if the login fields ever changed, you would only ever have to change this method - not your tests.\npublic void loginTest() { loginAsUser(\u0026#34;cbrown\u0026#34;, \u0026#34;cl0wn3\u0026#34;); // Now that we\u0026#39;re logged in, do some other stuff--since we used a DSL to support  // our testers, it\u0026#39;s as easy as choosing from available methods.  do.something(); do.somethingElse(); Assert.assertTrue(\u0026#34;Something should have been done!\u0026#34;, something.wasDone()); // Note that we still haven\u0026#39;t referred to a button or web control anywhere in this  // script... } It bears repeating: one of your primary goals should be writing an API that allows your tests to address the problem at hand, and NOT the problem of the UI. The UI is a secondary concern for your users – they do not care about the UI, they just want to get their job done. Your test scripts should read like a laundry list of things the user wants to DO, and the things they want to KNOW. The tests should not concern themselves with HOW the UI requires you to go about it.\n*AUT: Application under test\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/getting_started_with_webdriver/third_party_drivers_and_plugins/",
	"title": "Driver tiers et plugins",
	"tags": [],
	"description": "",
	"content": "Selenium peut être étendu à travers l\u0026rsquo;utilisation de plugins. Vous trouverez ici un certain nombre de plugins créés et maintenus par des tierces parties. Pour de plus amples information sur la création de plugin ou pour en ajouter à la liste, consultez la documentation.\nVeuillez noter que ces plugins ne sont pas supportés, maintenus ou hébergés par le projet Selenium. De plus, soyez avertis que les plugins listés ci-dessous ne sont pas nécessairement sous Apache License v.2.0. Certains de ces plugins sont disponibles sous une autre licence libre et gratuite; d\u0026rsquo;autres ne sont disponibles que sous licence propriétaire. Toute question à propos de ces plugins et de leur licence de distribution doit être évoquée avec leur(s) développeur(s) respectif.\n   Browser Latest Change log Issue Tracker     Mozilla GeckoDriver latest change log issue tracker   Google Chrome Driver latest change log issue tracker   Opera latest - issue tracker   Microsoft Edge Driver latest - issue tracker   SafariDriver Built in - issue tracker    "
},
{
	"uri": "https://selenium.dev/documentation/fr/selenium_installation/installing_webdriver_binaries/",
	"title": "Installer les binaires WebDriver",
	"tags": [],
	"description": "",
	"content": "Pour exécuter votre projet et contrôler le navigateur, vous devez installer des binaires WebDriver spécifiques au navigateur.\nTéléchargez le binaire WebDriver pris en charge par votre navigateur et placez-le dans le CHEMIN système.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " Introduction Selenium est un projet englobant un ensemble d\u0026rsquo;outil et de librairies rendant possible l\u0026rsquo;automatisation de navigateur web.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/remote_webdriver/remote_webdriver_client/",
	"title": "Le client Remote WebDriver",
	"tags": [],
	"description": "",
	"content": " Pour exécuter un client WebDriver distant, nous devons d\u0026rsquo;abord nous connecter au RemoteWebDriver. Nous le faisons en pointant l\u0026rsquo;URL vers l\u0026rsquo;adresse du serveur exécutant nos tests. Afin de personnaliser notre configuration, nous avons défini les capacités souhaitées. Voici un exemple d\u0026rsquo;instanciation d\u0026rsquo;un objet WebDriver distant pointant vers notre serveur Web distant, www.example.com, exécuter nos tests sur Firefox.\nJava Python C# Ruby JavaScript Kotlin FirefoxOptions firefoxOptions = new FirefoxOptions(); WebDriver driver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions); driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.quit();   from selenium import webdriver firefox_options = webdriver.FirefoxOptions() driver = webdriver.Remote( command_executor=\u0026#39;http://www.example.com\u0026#39;, options=firefox_options ) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   FirefoxOptions firefoxOptions = new FirefoxOptions(); IWebDriver driver = new RemoteWebDriver(new Uri(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions); driver.Navigate().GoToUrl(\u0026#34;http://www.google.com\u0026#34;); driver.Quit();   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :remote, url: \u0026#34;http://www.example.com\u0026#34;, desired_capabilities: :firefox driver.get \u0026#34;http://www.google.com\u0026#34; driver.close   const { Builder, Capabilities } = require(\u0026#34;selenium-webdriver\u0026#34;); var capabilities = Capabilities.firefox(); (async function helloSelenium() { let driver = new Builder() .usingServer(\u0026#34;http://example.com\u0026#34;) .withCapabilities(capabilities) .build(); try { await driver.get(\u0026#39;http://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   firefoxOptions = FirefoxOptions() driver: WebDriver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), firefoxOptions) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()     Pour personnaliser davantage notre configuration de test, nous pouvons ajouter d\u0026rsquo;autres fonctionnalités souhaitées.\nOptions du navigateur Par exemple, supposons que vous vouliez exécuter Chrome sur Windows XP, en utilisant la version 67 de Chrome:\nJava Python C# Ruby JavaScript Kotlin ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setCapability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;); chromeOptions.setCapability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;); WebDriver driver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), chromeOptions); driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.quit();   from selenium import webdriver chrome_options = webdriver.ChromeOptions() chrome_options.set_capability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;) chrome_options.set_capability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;) driver = webdriver.Remote( command_executor=\u0026#39;http://www.example.com\u0026#39;, options=chrome_options ) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit()   var chromeOptions = new ChromeOptions(); chromeOptions.BrowserVersion = \u0026#34;67\u0026#34;; chromeOptions.PlatformName = \u0026#34;Windows XP\u0026#34;; IWebDriver driver = new RemoteWebDriver(new Uri(\u0026#34;http://www.example.com\u0026#34;), chromeOptions); driver.Navigate().GoToUrl(\u0026#34;http://www.google.com\u0026#34;); driver.Quit();   caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.platform = Windows XP caps.version = 67 driver = Selenium::WebDriver.for :remote, :url =\u0026gt; \u0026#34;http://www.example.com\u0026#34;, :desired_capabilities =\u0026gt; caps   const { Builder, Capabilities } = require(\u0026#34;selenium-webdriver\u0026#34;); const chrome = require(\u0026#34;selenium-webdriver/chrome\u0026#34;) var capabilities = Capabilities.chrome(); //To avoid InsecureCertificateError for selenium4-aplha5 capabilities.setAcceptInsecureCerts(true); capabilities.set(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;); capabilities.set(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;); (async function helloSelenium() { let driver = new Builder() .usingServer(\u0026#34;http://example.com\u0026#34;) .withCapabilities(capabilities) .build(); try { await driver.get(\u0026#39;http://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   val chromeOptions = ChromeOptions() chromeOptions.setCapability(\u0026#34;browserVersion\u0026#34;, \u0026#34;67\u0026#34;); chromeOptions.setCapability(\u0026#34;platformName\u0026#34;, \u0026#34;Windows XP\u0026#34;); val driver: WebDriver = new RemoteWebDriver(new URL(\u0026#34;http://www.example.com\u0026#34;), chromeOptions) driver.get(\u0026#34;http://www.google.com\u0026#34;) driver.quit();     Détecteur de fichiers local Le détecteur de fichiers local permet le transfert de fichiers depuis le client machine au serveur distant. Par exemple, si un test doit télécharger un fichier vers une application Web, un WebDriver distant peut transférer automatiquement le fichier de la machine locale au serveur Web distant pendant Durée. Cela permet au fichier d\u0026rsquo;être téléchargé depuis la machine distante exécuter le test. Il n\u0026rsquo;est pas activé par défaut et peut être activé dans de la manière suivante:\nJava Python C# Ruby JavaScript Kotlin driver.setFileDetector(new LocalFileDetector());   from selenium.webdriver.remote.file_detector import UselessFileDetector driver.file_detector = UselessFileDetector()   var allowsDetection = this.driver as IAllowsFileDetection; if (allowsDetection != null) { allowsDetection.FileDetector = new LocalFileDetector(); }   @driver.file_detector = lambda do |args| # args =\u0026gt; [\u0026#34;/path/to/file\u0026#34;] str = args.first.to_s str if File.exist?(str) end   var remote = require(\u0026#39;selenium-webdriver/remote\u0026#39;); driver.setFileDetector(new remote.FileDetector);   driver.fileDetector = LocalFileDetector()     Une fois le code ci-dessus défini, vous pouvez télécharger un fichier dans votre test de la manière suivante:\nJava Python C# Ruby JavaScript Kotlin driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;); WebElement upload = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)); upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;);   driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;) driver.find_element_by_id(\u0026#34;myfile\u0026#34;).send_keys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;)   driver.Navigate().GoToUrl(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;); IWebElement upload = driver.FindElement(By.Id(\u0026#34;myfile\u0026#34;)); upload.SendKeys(@\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;);   @driver.navigate.to \u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34; element = @driver.find_element(:id, \u0026#39;myfile\u0026#39;) element.send_keys \u0026#34;/Users/sso/SauceLabs/sauce/hostess/maitred/maitred/public/images/darkbulb.jpg\u0026#34;   driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;); var upload = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)); upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;);   driver.get(\u0026#34;http://sso.dev.saucelabs.com/test/guinea-file-upload\u0026#34;) val upload: WebElement = driver.findElement(By.id(\u0026#34;myfile\u0026#34;)) upload.sendKeys(\u0026#34;/Users/sso/the/local/path/to/darkbulb.jpg\u0026#34;)     "
},
{
	"uri": "https://selenium.dev/documentation/fr/webdriver/driver_requirements/",
	"title": "Les pré-requis de WebDriver",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Through WebDriver, Selenium supports all major browsers on the market such as Chrom(ium), Firefox, Internet Explorer, Opera, and Safari. Where possible, WebDriver drives the browser using the browser\u0026rsquo;s built-in support for automation, although not all browsers have official support for remote control.\nWebDriver\u0026rsquo;s aim is to emulate a real user\u0026rsquo;s interaction with the browser as closely as possible. This is possible at varying levels in different browsers. For more details on the different driver idiosyncracies, please see Driver Idiosyncracies.\nEven though all the drivers share a single user-facing interface for controlling the browser, they have slightly different ways of setting up browser sessions. Since many of the driver implementations are provided by third parties, they are not included in the standard Selenium distribution.\nDriver instantiation, profile management, and various browser specific settings are examples of parameters that have different requirements depending on the browser. This section explains the basic requirements for getting you started with the different browsers.\nAdding Executables to your PATH Most drivers require an extra executable for Selenium to communicate with the browser. You can manually specify where the executable lives before starting WebDriver, but this can make your tests less portable, as the executables will need to be in the same place on every machine, or included within your test code repository.\nBy adding a folder containing WebDriver\u0026rsquo;s binaries to your system\u0026rsquo;s path, Selenium will be able to locate the additional binaries without requiring your test code to locate the exact location of the driver.\n Create a directory to place the executables in, like C:\\WebDriver\\bin or /opt/WebDriver/bin Add the directory to your PATH:\n On Windows - Open a command prompt as administrator and the run the following command to permanently add the directory to your path for all users on your machine:\nsetx /m path \u0026#34;%path%;C:\\WebDriver\\bin\\\u0026#34; Bash users on macOS and Linux - In a terminal:\nexport PATH=$PATH:/opt/WebDriver/bin \u0026gt;\u0026gt; ~/.profile  You are now ready to test your changes. Close all open command prompts and open a new one. Type out the name of one of the binaries in the folder you created in the previous step, e.g:\nchromedriver If your PATH is configured correctly, you will see some output relating to the startup of the driver:\nStarting ChromeDriver 2.25.426935 (820a95b0b81d33e42712f9198c215f703412e1a1) on port 9515 Only local connections are allowed.  You can regain control of your command prompt by pressing Ctrl + C\nQuick reference    Browser Supported OS Maintained by Download Issue Tracker     Chromium/Chrome Windows/macOS/Linux Google Downloads Issues   Firefox Windows/macOS/Linux Mozilla Downloads Issues   Edge Windows 10 Microsoft Downloads Issues   Internet Explorer Windows Selenium Project Downloads Issues   Safari macOS El Capitan and newer Apple Built in Issues   Opera Windows/macOS/Linux Opera Downloads Issues    Chromium/Chrome To drive Chrome or Chromium, you have to download chromedriver and put it in a folder that is on your system\u0026rsquo;s path.\nOn Linux or macOS, this means modifying the PATH environmental variable. You can see what directories, separated by a colon, make up your system\u0026rsquo;s path by executing the following command:\n$ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin To include chromedriver on the path if it isn\u0026rsquo;t already, make sure you include the chromedriver binary\u0026rsquo;s parent directory. The following line will set the PATH environmental variable its current content, plus an additional path added after the colon:\n$ export PATH=\u0026#34;$PATH:/path/to/chromedriver\u0026#34; When chromedriver is available on your path, you should be able to execute the chromedriver executable from any directory.\nTo instantiate a Chrome/Chromium session, you can do the following:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeDriver; WebDriver driver = new ChromeDriver();   #Simple assignment from selenium.webdriver import Chrome driver = Chrome() #Or use the context manager from selenium.webdriver import Chrome with Chrome() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; IWebDriver driver = new ChromeDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :chrome   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); const chrome = require(\u0026#39;selenium-webdriver/chrome\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.chrome.ChromeDriver val driver: WebDriver = ChromeDriver()     Remember that you have to set the path to the chromedriver executable. This is possible using the following line:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;/path/to/chromedriver\u0026#34;);   Chrome(executable_path=\u0026#39;/path/to/chromedriver\u0026#39;)   new ChromeDriver(\u0026#34;/path/to/chromedriver\u0026#34;);   Selenium::WebDriver::Chrome.driver_path = \u0026#34;/path/to/chromedriver\u0026#34;   chrome.setDefaultService(new chrome.ServiceBuilder(\u0026#39;path/to/chromedriver\u0026#39;).build());   System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;/path/to/chromedriver\u0026#34;)     The chromedriver is implemented as a WebDriver remote server that by exposing Chrome\u0026rsquo;s internal automation proxy interface instructs the browser what to do.\nFirefox Starting with Selenium 3, Mozilla has taken over implementation of Firefox Driver, with geckodriver. The new driver for Firefox is called geckodriver and works with Firefox 48 and newer. Since the Firefox WebDriver is under development, the newer the Firefox version the better the support.\nAs geckodriver is the new default way of launching Firefox, you can instantiate Firefox in the same way as Selenium 2:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.Firefox.FirefoxDriver; WebDriver driver = new FirefoxDriver();   #Simple assignment from selenium.webdriver import Firefox driver = Firefox() #Or use the context manager from selenium.webdriver import Firefox with Firefox() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Firefox; IWebDriver driver = new FirefoxDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :firefox   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.Firefox.FirefoxDriver val driver: WebDriver = FirefoxDriver()     If you prefer not to set geckodriver\u0026rsquo;s location using PATH, set the geckodriver binary location programmatically:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.gecko.driver\u0026#34;, \u0026#34;/path/to/geckodriver\u0026#34;);   Firefox(executable_path=\u0026#39;/path/to/geckodriver\u0026#39;)   new FirefoxDriver(\u0026#34;/path/to/geckodriver\u0026#34;);   Selenium::WebDriver::Firefox.driver_path = \u0026#34;/path/to/geckodriver\u0026#34;   const firefox = require(\u0026#39;selenium-webdriver/firefox\u0026#39;); const options = new firefox.Options(); options.setBinary(\u0026#34;/path/to/geckodriver\u0026#34;);   System.setProperty(\u0026#34;webdriver.gecko.driver\u0026#34;, \u0026#34;/path/to/geckodriver\u0026#34;)     It is also possible to set the property at run time:\nmvn test -Dwebdriver.gecko.driver=/path/to/geckodriver It is currently possible to revert to the older, more feature complete Firefox driver, by installing Firefox 47.0.1 or 45 ESR and specifying a desired capability of marionette as false. Later releases of Firefox are no longer compatible.\nEdge Edge is Microsoft\u0026rsquo;s newest browser, included with Windows 10 and Server 2016. Updates to Edge are bundled with major Windows updates, so you\u0026rsquo;ll need to download a binary which matches the build number of your currently installed build of Windows. The Edge Developer site contains links to all the available binaries. Bugs against the EdgeDriver implementation can be raised with Microsoft. If you\u0026rsquo;d like to run tests against Edge, but aren\u0026rsquo;t running Windows 10, Microsoft offer free VMs for testers on the Edge Developer site.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.edge.EdgeDriver; WebDriver driver = new EdgeDriver();   #Simple assignment from selenium.webdriver import Edge driver = Edge() #Or use the context manager from selenium.webdriver import Edge with Edge() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Edge; IWebDriver driver = new EdgeDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :edge   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;MicrosoftEdge\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.edge.EdgeDriver val driver: WebDriver = EdgeDriver()     If Edge driver is not present in your path, you can set the path using the following line:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.edge.driver\u0026#34;, \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;);   Edge(executable_path=\u0026#39;/path/to/MicrosoftWebDriver.exe\u0026#39;)   new EdgeDriver(\u0026#34;/path/to/MicrosoftWebDriver.exe\u0026#34;);   Selenium::WebDriver::Edge.driver_path = \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    System.setProperty(\u0026#34;webdriver.edge.driver\u0026#34;, \u0026#34;C:/path/to/MicrosoftWebDriver.exe\u0026#34;)     Internet Explorer Internet Explorer was Microsoft\u0026rsquo;s default browser until Windows 10, although it is still included in Windows 10. Internet Explorer Driver is the only driver The Selenium project aims to support the same releases Microsoft considers current. Older releases may work, but will be unsupported.\nWhile the Selenium project provides binaries for both the 32-bit and 64-bit versions of Internet Explorer, there are some limitations with Internet Explorer 10 \u0026amp; 11 with the 64-bit driver, but using the 32-bit driver continues to work well. It should be noted that as Internet Explorer preferences are saved against the logged in user\u0026rsquo;s account, some additional setup is required.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.ie.InternetExplorerDriver; WebDriver driver = new InternetExplorerDriver();   #Simple assignment from selenium.webdriver import Ie driver = Ie() #Or use the context manager from selenium.webdriver import Ie with Ie() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.IE; IWebDriver driver = new InternetExplorerDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :internet_explorer   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;internet explorer\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.ie.InternetExplorerDriver val driver: WebDriver = InternetExplorerDriver()     If Internet Explorer driver is not present in your path, you can set the path using the following line:\nJava Python C# Ruby JavaScript Kotlin System.setProperty(\u0026#34;webdriver.ie.driver\u0026#34;, \u0026#34;C:/path/to/IEDriver.exe\u0026#34;);   Ie(executable_path=\u0026#39;/path/to/IEDriverServer.exe\u0026#39;)   new InternetExplorerDriver(\u0026#34;C:/path/to/IEDriver.exe\u0026#34;);   Selenium::WebDriver::IE.driver_path = \u0026#34;C:/path/to/IEDriver.exe\u0026#34;   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    System.setProperty(\u0026#34;webdriver.ie.driver\u0026#34;, \u0026#34;C:/path/to/IEDriver.exe\u0026#34;)     Microsoft also offer a WebDriver binary for Internet Explorer 11 on Windows 7 \u0026amp; 8.1. It has not been updated since 2014 and is based of a draft version of the W3 specification. Jim Evans has an excellent writeup on Microsoft\u0026rsquo;s implementation.\nOpera Current releases of Opera are built on top of the Chromium engine, and WebDriver is now supported via the closed-source Opera Chromium Driver, which can be added to your PATH or as a system property.\nInstantiating a driver session is similar to Firefox and Chromium:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.opera.OperaDriver; WebDriver driver = new OperaDriver();   #Simple assignment from selenium.webdriver import Opera driver = Opera() #Or use the context manager from selenium.webdriver import Opera with Opera() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Opera; IWebDriver driver = new OperaDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :opera   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    import org.openqa.selenium.WebDriver import org.openqa.selenium.opera.OperaDriver val driver: WebDriver = OperaDriver()     Safari High Sierra and later: * Run the following command from the terminal for the first time and type your password at the prompt to authorise WebDriver\nsafaridriver --enable El Capitan and Sierra:\n Enable the Developer menu from Safari preferences Check the Allow Remote Automation option from with the Develop menu Run the following command from the terminal for the first time and type your password at the prompt to authorise WebDriver\n/usr/bin/safaridriver -p 1337\u0026lt;/  You can then start a driver session using:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.WebDriver; import org.openqa.selenium.safari.SafariDriver; WebDriver driver = new SafariDriver();   #Simple assignment from selenium.webdriver import Safari driver = Safari() #Or use the context manager from selenium.webdriver import Safari with Safari() as driver: #your code inside this indent   using OpenQA.Selenium; using OpenQA.Selenium.Safari; IWebDriver driver = new SafariDriver();   require \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :safari   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function myFunction() { let driver = await new Builder().forBrowser(\u0026#39;safari\u0026#39;).build(); //your code inside this block })();   import org.openqa.selenium.WebDriver import org.openqa.selenium.safari.SafariDriver val driver: WebDriver = SafariDriver()     Those looking to automate Safari on iOS should look to the Appium project. Whilst Safari was previously available for Windows, Apple has long since dropped support, making it a poor choice of test platform.\nMock browsers HtmlUnit HtmlUnit is a \u0026ldquo;GUI-Less browser for Java programs\u0026rdquo;. It models HTML documents and provides an API that allows you to invoke pages, fill out forms, click links, etc. It has JavaScript support and is able to work with AJAX libraries, simulating Chrome, Firefox or Internet Explorer depending on the configuration used. It has been moved to a new location. The source is maintained on svn.\nPhantomJS PhantomJS is a headless browser based on Webkit, albeit a version much older than that used by Google Chrome or Safari. Whilst historically a popular choice, it would now be wise to avoid PhantomJS. The project has been unmaintained since the 5th of August, so whilst the web will continue to change, PhantomJS will not be updated. This was after Google announced the ability to run Chrome headlessly, something also now offered by Mozilla\u0026rsquo;s Firefox.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/legacy_docs/migrating_from_rc_to_webdriver/",
	"title": "Migrating from RC to WebDriver",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n How to Migrate to Selenium WebDriver A common question when adopting Selenium 2 is what\u0026rsquo;s the correct thing to do when adding new tests to an existing set of tests? Users who are new to the framework can begin by using the new WebDriver APIs for writing their tests. But what of users who already have suites of existing tests? This guide is designed to demonstrate how to migrate your existing tests to the new APIs, allowing all new tests to be written using the new features offered by WebDriver.\nThe method presented here describes a piecemeal migration to the WebDriver APIs without needing to rework everything in one massive push. This means that you can allow more time for migrating your existing tests, which may make it easier for you to decide where to spend your effort.\nThis guide is written using Java, because this has the best support for making the migration. As we provide better tools for other languages, this guide shall be expanded to include those languages.\nWhy Migrate to WebDriver Moving a suite of tests from one API to another API requires an enormous amount of effort. Why would you and your team consider making this move? Here are some reasons why you should consider migrating your Selenium Tests to use WebDriver.\n Smaller, compact API. WebDriver\u0026rsquo;s API is more Object Oriented than the original Selenium RC API. This can make it easier to work with. Better emulation of user interactions. Where possible, WebDriver makes use of native events in order to interact with a web page. This more closely mimics the way that your users work with your site and apps. In addition, WebDriver offers the advanced user interactions APIs which allow you to model complex interactions with your site. Support by browser vendors. Opera, Mozilla and Google are all active participants in WebDriver\u0026rsquo;s development, and each have engineers working to improve the framework. Often, this means that support for WebDriver is baked into the browser itself: your tests run as fast and as stably as possible.  Before Starting In order to make the process of migrating as painless as possible, make sure that all your tests run properly with the latest Selenium release. This may sound obvious, but it\u0026rsquo;s best to have it said!\nGetting Started The first step when starting the migration is to change how you obtain your instance of Selenium. When using Selenium RC, this is done like so:\nSelenium selenium = new DefaultSelenium(\u0026#34;localhost\u0026#34;, 4444, \u0026#34;*firefox\u0026#34;, \u0026#34;http://www.yoursite.com\u0026#34;); selenium.start(); This should be replaced like so:\nWebDriver driver = new FirefoxDriver(); Selenium selenium = new WebDriverBackedSelenium(driver, \u0026#34;http://www.yoursite.com\u0026#34;); Next Steps Once your tests execute without errors, the next stage is to migrate the actual test code to use the WebDriver APIs. Depending on how well abstracted your code is, this might be a short process or a long one. In either case, the approach is the same and can be summed up simply: modify code to use the new API when you come to edit it.\nIf you need to extract the underlying WebDriver implementation from the Selenium instance, you can simply cast it to WrapsDriver:\nWebDriver driver = ((WrapsDriver) selenium).getWrappedDriver(); This allows you to continue passing the Selenium instance around as normal, but to unwrap the WebDriver instance as required.\nAt some point, you\u0026rsquo;re codebase will mostly be using the newer APIs. At this point, you can flip the relationship, using WebDriver throughout and instantiating a Selenium instance on demand:\nSelenium selenium = new WebDriverBackedSelenium(driver, baseUrl); Common Problems Fortunately, you\u0026rsquo;re not the first person to go through this migration, so here are some common problems that others have seen, and how to solve them.\nClicking and Typing is More Complete A common pattern in a Selenium RC test is to see something like:\nselenium.type(\u0026#34;name\u0026#34;, \u0026#34;exciting tex\u0026#34;); selenium.keyDown(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); selenium.keyPress(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); selenium.keyUp(\u0026#34;name\u0026#34;, \u0026#34;t\u0026#34;); This relies on the fact that \u0026ldquo;type\u0026rdquo; simply replaces the content of the identified element without also firing all the events that would normally be fired if a user interacts with the page. The final direct invocations of \u0026ldquo;key*\u0026rdquo; cause the JS handlers to fire as expected.\nWhen using the WebDriverBackedSelenium, the result of filling in the form field would be \u0026ldquo;exciting texttt\u0026rdquo;: not what you\u0026rsquo;d expect! The reason for this is that WebDriver more accurately emulates user behavior, and so will have been firing events all along.\nThis same fact may sometimes cause a page load to fire earlier than it would do in a Selenium 1 test. You can tell that this has happened if a \u0026ldquo;StaleElementException\u0026rdquo; is thrown by WebDriver.\nWaitForPageToLoad Returns Too Soon Discovering when a page load is complete is a tricky business. Do we mean \u0026ldquo;when the load event fires\u0026rdquo;, \u0026ldquo;when all AJAX requests are complete\u0026rdquo;, \u0026ldquo;when there\u0026rsquo;s no network traffic\u0026rdquo;, \u0026ldquo;when document.readyState has changed\u0026rdquo; or something else entirely?\nWebDriver attempts to simulate the original Selenium behavior, but this doesn\u0026rsquo;t always work perfectly for various reasons. The most common reason is that it\u0026rsquo;s hard to tell the difference between a page load not having started yet, and a page load having completed between method calls. This sometimes means that control is returned to your test before the page has finished (or even started!) loading.\nThe solution to this is to wait on something specific. Commonly, this might be for the element you want to interact with next, or for some Javascript variable to be set to a specific value. An example would be:\nWait\u0026lt;WebDriver\u0026gt; wait = new WebDriverWait(driver, Duration.ofSeconds(30)); WebElement element= wait.until(visibilityOfElementLocated(By.id(\u0026#34;some_id\u0026#34;))); Where \u0026ldquo;visibilityOfElementLocated\u0026rdquo; is implemented as:\npublic ExpectedCondition\u0026lt;WebElement\u0026gt; visibilityOfElementLocated(final By locator) { return new ExpectedCondition\u0026lt;WebElement\u0026gt;() { public WebElement apply(WebDriver driver) { WebElement toReturn = driver.findElement(locator); if (toReturn.isDisplayed()) { return toReturn; } return null; } }; } This may look complex, but it\u0026rsquo;s almost all boiler-plate code. The only interesting bit is that the \u0026ldquo;ExpectedCondition\u0026rdquo; will be evaluated repeatedly until the \u0026ldquo;apply\u0026rdquo; method returns something that is neither \u0026ldquo;null\u0026rdquo; nor Boolean.FALSE.\nOf course, adding all these \u0026ldquo;wait\u0026rdquo; calls may clutter up your code. If that\u0026rsquo;s the case, and your needs are simple, consider using the implicit waits:\ndriver.manage().timeouts().implicitlyWait(30, TimeUnit.SECONDS); By doing this, every time an element is located, if the element is not present, the location is retried until either it is present, or until 30 seconds have passed.\nFinding By XPath or CSS Selectors Doesn\u0026rsquo;t Always Work, But It Does In Selenium 1 In Selenium 1, it was common for xpath to use a bundled library rather than the capabilities of the browser itself. WebDriver will always use the native browser methods unless there\u0026rsquo;s no alternative. That means that complex xpath expressions may break on some browsers.\nCSS Selectors in Selenium 1 were implemented using the Sizzle library. This implements a superset of the CSS Selector spec, and it\u0026rsquo;s not always clear where you\u0026rsquo;ve crossed the line. If you\u0026rsquo;re using the WebDriverBackedSelenium and use a Sizzle locator instead of a CSS Selector for finding elements, a warning will be logged to the console. It\u0026rsquo;s worth taking the time to look for these, particularly if tests are failing because of not being able to find elements.\nThere is No Browserbot Selenium RC was based on Selenium Core, and therefore when you executed Javascript, you could access bits of Selenium Core to make things easier. As WebDriver is not based on Selenium Core, this is no longer possible. How can you tell if you\u0026rsquo;re using Selenium Core? Simple! Just look to see if your \u0026ldquo;getEval\u0026rdquo; or similar calls are using \u0026ldquo;selenium\u0026rdquo; or \u0026ldquo;browserbot\u0026rdquo; in the evaluated Javascript.\nYou might be using the browserbot to obtain a handle to the current window or document of the test. Fortunately, WebDriver always evaluates JS in the context of the current window, so you can use \u0026ldquo;window\u0026rdquo; or \u0026ldquo;document\u0026rdquo; directly.\nAlternatively, you might be using the browserbot to locate elements. In WebDriver, the idiom for doing this is to first locate the element, and then pass that as an argument to the Javascript. Thus:\nString name = selenium.getEval( \u0026#34;selenium.browserbot.findElement(\u0026#39;id=foo\u0026#39;, browserbot.getCurrentWindow()).tagName\u0026#34;); becomes:\nWebElement element = driver.findElement(By.id(\u0026#34;foo\u0026#34;)); String name = (String) ((JavascriptExecutor) driver).executeScript( \u0026#34;return arguments[0].tagName\u0026#34;, element); Notice how the passed in \u0026ldquo;element\u0026rdquo; variable appears as the first item in the JS standard \u0026ldquo;arguments\u0026rdquo; array.\nExecuting Javascript Doesn\u0026rsquo;t Return Anything WebDriver\u0026rsquo;s JavascriptExecutor will wrap all JS and evaluate it as an anonymous expression. This means that you need to use the \u0026ldquo;return\u0026rdquo; keyword:\nString title = selenium.getEval(\u0026#34;browserbot.getCurrentWindow().document.title\u0026#34;); becomes:\n((JavascriptExecutor) driver).executeScript(\u0026#34;return document.title;\u0026#34;);"
},
{
	"uri": "https://selenium.dev/documentation/fr/support_packages/working_with_colours/",
	"title": "Travailler avec les couleurs",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n You will occasionally want to validate the colour of something as part of your tests; the problem is that colour definitions on the web are not constant. Would it not be nice if there was an easy way to compare a HEX representation of a colour with a RGB representation of a colour, or a RGBA representation of a colour with a HSLA representation of a colour?\nWorry not. There is a solution: the Color class!\nFirst of all, you will need to import the class:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.support.Color;   from selenium.webdriver.support.color import Color   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    include Selenium::WebDriver::Support   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    import org.openqa.selenium.support.Color    You can now start creating colour objects. Every colour object will need to be created from a string representation of your colour. Supported colour representations are:\nJava Python C# Ruby JavaScript Kotlin private final Color HEX_COLOUR = Color.fromString(\u0026#34;#2F7ED8\u0026#34;); private final Color RGB_COLOUR = Color.fromString(\u0026#34;rgb(255, 255, 255)\u0026#34;); private final Color RGB_COLOUR = Color.fromString(\u0026#34;rgb(40%, 20%, 40%)\u0026#34;); private final Color RGBA_COLOUR = Color.fromString(\u0026#34;rgba(255, 255, 255, 0.5)\u0026#34;); private final Color RGBA_COLOUR = Color.fromString(\u0026#34;rgba(40%, 20%, 40%, 0.5)\u0026#34;); private final Color HSL_COLOUR = Color.fromString(\u0026#34;hsl(100, 0%, 50%)\u0026#34;); private final Color HSLA_COLOUR = Color.fromString(\u0026#34;hsla(100, 0%, 50%, 0.5)\u0026#34;);   HEX_COLOUR = Color.from_string(\u0026#39;#2F7ED8\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(255, 255, 255)\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(40%, 20%, 40%)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(255, 255, 255, 0.5)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(40%, 20%, 40%, 0.5)\u0026#39;) HSL_COLOUR = Color.from_string(\u0026#39;hsl(100, 0%, 50%)\u0026#39;) HSLA_COLOUR = Color.from_string(\u0026#39;hsla(100, 0%, 50%, 0.5)\u0026#39;)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    HEX_COLOUR = Color.from_string(\u0026#39;#2F7ED8\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(255, 255, 255)\u0026#39;) RGB_COLOUR = Color.from_string(\u0026#39;rgb(40%, 20%, 40%)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(255, 255, 255, 0.5)\u0026#39;) RGBA_COLOUR = Color.from_string(\u0026#39;rgba(40%, 20%, 40%, 0.5)\u0026#39;) HSL_COLOUR = Color.from_string(\u0026#39;hsl(100, 0%, 50%)\u0026#39;) HSLA_COLOUR = Color.from_string(\u0026#39;hsla(100, 0%, 50%, 0.5)\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    private val HEX_COLOUR = Color.fromString(\u0026#34;#2F7ED8\u0026#34;) private val RGB_COLOUR = Color.fromString(\u0026#34;rgb(255, 255, 255)\u0026#34;) private val RGB_COLOUR_PERCENT = Color.fromString(\u0026#34;rgb(40%, 20%, 40%)\u0026#34;) private val RGBA_COLOUR = Color.fromString(\u0026#34;rgba(255, 255, 255, 0.5)\u0026#34;) private val RGBA_COLOUR_PERCENT = Color.fromString(\u0026#34;rgba(40%, 20%, 40%, 0.5)\u0026#34;) private val HSL_COLOUR = Color.fromString(\u0026#34;hsl(100, 0%, 50%)\u0026#34;) private val HSLA_COLOUR = Color.fromString(\u0026#34;hsla(100, 0%, 50%, 0.5)\u0026#34;)     The Color class also supports all of the base colour definitions specified in http://www.w3.org/TR/css3-color/#html4.\nJava Python C# Ruby JavaScript Kotlin private final Color BLACK = Color.fromString(\u0026#34;black\u0026#34;); private final Color CHOCOLATE = Color.fromString(\u0026#34;chocolate\u0026#34;); private final Color HOTPINK = Color.fromString(\u0026#34;hotpink\u0026#34;);   BLACK = Color.from_string(\u0026#39;black\u0026#39;) CHOCOLATE = Color.from_string(\u0026#39;chocolate\u0026#39;) HOTPINK = Color.from_string(\u0026#39;hotpink\u0026#39;)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    BLACK = Color.from_string(\u0026#39;black\u0026#39;) CHOCOLATE = Color.from_string(\u0026#39;chocolate\u0026#39;) HOTPINK = Color.from_string(\u0026#39;hotpink\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    private val BLACK = Color.fromString(\u0026#34;black\u0026#34;) private val CHOCOLATE = Color.fromString(\u0026#34;chocolate\u0026#34;) private val HOTPINK = Color.fromString(\u0026#34;hotpink\u0026#34;)     Sometimes browsers will return a colour value of \u0026ldquo;transparent\u0026rdquo; if no colour has been set on an element. The Color class also supports this:\nJava Python C# Ruby JavaScript Kotlin private final Color TRANSPARENT = Color.fromString(\u0026#34;transparent\u0026#34;);   TRANSPARENT = Color.from_string(\u0026#39;transparent\u0026#39;)   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    TRANSPARENT = Color.from_string(\u0026#39;transparent\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    private val TRANSPARENT = Color.fromString(\u0026#34;transparent\u0026#34;)     You can now safely query an element to get its colour/background colour knowing that any response will be correctly parsed and converted into a valid Color object:\nJava Python C# Ruby JavaScript Kotlin Color loginButtonColour = driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;color\u0026#34;); Color loginButtonBackgroundColour = driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;background-color\u0026#34;);   login_button_colour = driver.find_element_by_id(\u0026#39;login\u0026#39;).value_of_css_property(\u0026#39;color\u0026#39;) login_button_background_colour = driver.find_element_by_id(\u0026#39;login\u0026#39;).value_of_css_property(\u0026#39;background-color\u0026#39;);   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    login_button_colour = driver.find_element(id: \u0026#39;login\u0026#39;).css_value(\u0026#39;color\u0026#39;) login_button_background_colour = driver.find_element(id: \u0026#39;login\u0026#39;).css_value(\u0026#39;background-color\u0026#39;);   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    val loginButtonColour = driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;color\u0026#34;) val loginButtonBackgroundColour = driver.findElement(By.id(\u0026#34;login\u0026#34;)).getCssValue(\u0026#34;background-color\u0026#34;)     You can then directly compare colour objects:\nJava Python C# Ruby JavaScript Kotlin assert loginButtonBackgroundColour.equals(HOTPINK);   assert login_button_background_colour == HOTPINK   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    assert(login_button_background_colour == HOTPINK)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    assert(loginButtonBackgroundColour.equals(HOTPINK))     Or you can convert the colour into one of the following formats and perform a static validation:\nJava Python C# Ruby JavaScript Kotlin assert loginButtonBackgroundColour.asHex().equals(\u0026#34;#ff69b4\u0026#34;); assert loginButtonBackgroundColour.asRgba().equals(\u0026#34;rgba(255, 105, 180, 1)\u0026#34;); assert loginButtonBackgroundColour.asRgb().equals(\u0026#34;rgb(255, 105, 180)\u0026#34;);   assert login_button_background_colour.hex == \u0026#39;#ff69b4\u0026#39; assert login_button_background_colour.rgba == \u0026#39;rgba(255, 105, 180, 1)\u0026#39; assert login_button_background_colour.rgb == \u0026#39;rgb(255, 105, 180)\u0026#39;   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    assert(login_button_background_colour.hex == \u0026#39;#ff69b4\u0026#39;) assert(login_button_background_colour.rgba == \u0026#39;rgba(255, 105, 180, 1)\u0026#39;) assert(login_button_background_colour.rgb == \u0026#39;rgb(255, 105, 180)\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    assert(loginButtonBackgroundColour.asHex().equals(\u0026#34;#ff69b4\u0026#34;)) assert(loginButtonBackgroundColour.asRgba().equals(\u0026#34;rgba(255, 105, 180, 1)\u0026#34;)) assert(loginButtonBackgroundColour.asRgb().equals(\u0026#34;rgb(255, 105, 180)\u0026#34;))     Colours are no longer a problem.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/worst_practices/file_downloads/",
	"title": "Téléchargement de fichier",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Whilst it is possible to start a download by clicking a link with a browser under Selenium\u0026rsquo;s control, the API does not expose download progress, making it less than ideal for testing downloaded files. This is because downloading files is not considered an important aspect of emulating user interaction with the web platform. Instead, find the link using Selenium (and any required cookies) and pass it to a HTTP request library like libcurl.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/worst_practices/http_response_codes/",
	"title": "Codes réponse HTTP",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n For some browser configurations in Selenium RC, Selenium acted as a proxy between the browser and the site being automated. This meant that all browser traffic passed through Selenium could be captured or manipulated. The captureNetworkTraffic() method purported to capture all of the network traffic between the browser and the site being automated, including HTTP response codes.\nSelenium WebDriver is a completely different approach to browser automation, preferring to act more like a user and this is represented in the way you write tests with WebDriver. In automated functional testing, checking the status code is not a particularly important detail of a test\u0026rsquo;s failure; the steps that preceded it are more important.\nThe browser will always represent the HTTP status code, imagine for example a 404 or a 500 error page. A simple way to “fail fast” when you encounter one of these error pages is to check the page title or content of a reliable point (e.g. the \u0026lt;h1\u0026gt; tag) after every page load. If you are using the page object model, you can include this check in your class constructor or similar point where the page load is expected. Occasionally, the HTTP code may even be represented in the browser\u0026rsquo;s error page and you could use WebDriver to read this and improve your debugging output.\nChecking the webpage itself is in line with WebDriver\u0026rsquo;s ideal practice of representing and asserting upon the user’s view of the website.\nIf you insist, an advanced solution to capturing HTTP status codes is to replicate the behaviour of Selenium RC by using a proxy. WebDriver API provides the ability to set a proxy for the browser, and there are a number of proxies that will programmatically allow you to manipulate the contents of requests sent to and received from the web server. Using a proxy lets you decide how you want to respond to redirection response codes. Additionally, not every browser makes the response codes available to WebDriver, so opting to use a proxy allows you to have a solution that works for every browser.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/guidelines_and_recommendations/generating_application_state/",
	"title": "Generer l&#39;état de l&#39;application",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Selenium should not be used to prepare a test case. All repetitive actions and preparations for a test case, should be done through other methods. For example, most web UIs have authentication (e.g. a login form). Eliminating logging in via web browser before every test will improve both the speed and stability of the test. A method should be created to gain access to the AUT* (e.g. using an API to login and set a cookie). Also, creating methods to pre-load data for testing should not be done using Selenium. As mentioned previously, existing APIs should be leveraged to create data for the AUT*.\n*AUT: Application under test\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/selenium_installation/",
	"title": "Installation de Selenium",
	"tags": [],
	"description": "",
	"content": " Installation de Selenium La configuration de Selenium est très différente de la configuration d\u0026rsquo;autres outils commerciaux. Pour utiliser Selenium dans votre projet d\u0026rsquo;automatisation, vous devez installer les bibliothèques de liaisons linguistiques pour la langue de votre choix. De plus, vous aurez besoin des fichiers binaires WebDriver pour les navigateurs sur lesquels vous souhaitez automatiser et exécuter le test.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/selenium_installation/installing_standalone_server/",
	"title": "Installer le serveur Standalone",
	"tags": [],
	"description": "",
	"content": "Si vous prévoyez d\u0026rsquo;utiliser Grid, vous devez télécharger le selenium-server-standalone JAR. Tous les composants sont disponibles via selenium-server. Le JAR autonome contient tout, y compris le serveur Selenium distant et les liaisons côté client. Cela signifie que si vous utilisez le la jar selenium-server-standalone dans votre projet, vous n\u0026rsquo;avez pas besoin d\u0026rsquo;ajouter de sélénium-java ou un le jar spécifique au navigateur.\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.seleniumhq.selenium\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;selenium-server\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.X\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;"
},
{
	"uri": "https://selenium.dev/documentation/fr/getting_started_with_webdriver/locating_elements/",
	"title": "Localiser des éléments",
	"tags": [],
	"description": "",
	"content": " Localiser des éléments Une des techniques fondamentales à maîtriser lorsque l\u0026rsquo;on utilise WebDriver consiste à chercher des éléments sur une page. WebDriver offre pour cela un ensemble pré-défini de type de selecteurs, parmi lesquels la recherche d\u0026rsquo;une élément par son attribut ID:\nJava Python C# Ruby JavaScript Kotlin WebElement cheese = driver.findElement(By.id(\u0026#34;fromage\u0026#34;));   driver.find_element_by_id(\u0026#34;fromage\u0026#34;)   IWebElement element = driver.FindElement(By.Id(\u0026#34;fromage\u0026#34;));   cheese = driver.find_element(id: \u0026#39;cheese\u0026#39;)   const fromage = driver.findElement(By.id(\u0026#39;fromage\u0026#39;));   val cheese: WebElement = driver.findElement(By.id(\u0026#34;cheese\u0026#34;))     Comme démontré dans cet exemple, la localisation des éléments à l\u0026rsquo;aide de WebDriver se fait via une instance de l\u0026rsquo;objet WebDriver. La méthode findElement(By) retourne un autre type d\u0026rsquo;objet fondamental, un WebElement.\n WebDriver represente la navigateur WebElement represente un noeud particulier du DOM (un lien, un champ texte, etc.)  Un fois que l\u0026rsquo;on a obtenu la référence de l\u0026rsquo;élément web qui a été \u0026ldquo;trouvé\u0026rdquo;, on peut encore réduire la portée de notre recherche en utilisant le même appel de méthode sur l\u0026rsquo;instance de cet objet:\nJava Python C# Ruby JavaScript Kotlin WebElement fromage = driver.findElement(By.id(\u0026#34;fromage\u0026#34;)); WebElement cheddar = fromage.findElement(By.id(\u0026#34;cheddar\u0026#34;));   fromage = driver.find_element_by_id(\u0026#34;fromage\u0026#34;) cheddar = fromage.find_elements_by_id(\u0026#34;cheddar\u0026#34;)   IWebElement fromage = driver.FindElement(By.Id(\u0026#34;fromage\u0026#34;)); IWebElement cheddar = fromage.FindElement(By.Id(\u0026#34;cheddar\u0026#34;));   fromage = driver.find_element(id: \u0026#39;fromage\u0026#39;) cheddar = fromage.find_element(id: \u0026#39;cheddar\u0026#39;)   const fromage = driver.findElement(By.id(\u0026#39;fromage\u0026#39;)); const cheddar = fromage.findElement(By.id(\u0026#39;cheddar\u0026#39;));   val cheese = driver.findElement(By.id(\u0026#34;cheese\u0026#34;)) val cheddar = cheese.findElement(By.id(\u0026#34;cheddar\u0026#34;))     Nous pouvons faire cela car les types WebDriver et WebElement implémentent tous deux l\u0026rsquo;interface SearchContext. Dans WebDriver, ce principe est connu sous le nom de role-based interface. Les interfaces basées sur le rôle nous permettent de déterminer si une implémentation particulière de driver supporte une fonctionnalité donnée. Ces interfaces sont clairement définies et tente d\u0026rsquo;adhérer au principe de responsabilité unique. Vous pouvez en lire plus sur le design de WebDriver et sur quels drivers supportent quels rôles dans le chapitre Un Autre Chapitre Qui Aura Un Nom. Par conséquent, l\u0026rsquo;interface By utilisée précédement fournit également d\u0026rsquo;autres stratégies de localisation. Une recherche imbriquée peut ne pas être la startégie la plus adaptée pour trouver notre cheddar puisqu\u0026rsquo;elle nécessite que deux instructions séparées soient envoyées au navigateur ; tout d\u0026rsquo;abord rechercher un élément ayant pour ID \u0026ldquo;fromage\u0026rdquo;, puis une recherche pour \u0026ldquo;cheddar\u0026rdquo; dans ce contexte plus restreint.\nPour améliorer légèrement les performances, nous pourrions essayer un sélecteur (une stratégie de localisation) plus spécifique : WebDriver supporte la localisation d\u0026rsquo;élément via sélecteur CSS, nous permettant de combiner les deux sélecteurs précédents en un seul:\nJava Python C# Ruby JavaScript Kotlin driver.findElement(By.cssSelector(\u0026#34;#fromage #cheddar\u0026#34;));   cheddar = driver.find_element_by_css_selector(\u0026#34;#fromage #cheddar\u0026#34;)   driver.FindElement(By.CssSelector(\u0026#34;#fromage #cheddar\u0026#34;));   driver.find_element(css: \u0026#39;#fromage #cheddar\u0026#39;)   const cheddar = driver.findElement(By.css(\u0026#39;#fromage #cheddar\u0026#39;));   driver.findElement(By.cssSelector(\u0026#34;#cheese #cheddar\u0026#34;))     Localiser plusieurs éléments Il est possible que le document web sur lequel nous travaillons dispose d\u0026rsquo;une liste ordonnée de nos fromages préférés:\n\u0026lt;ol id=fromage\u0026gt; \u0026lt;li id=cheddar\u0026gt;… \u0026lt;li id=brie\u0026gt;… \u0026lt;li id=rochefort\u0026gt;… \u0026lt;li id=camembert\u0026gt;… \u0026lt;/ul\u0026gt; Puisque plus de fromage est sans conteste meilleur, et qu\u0026rsquo;il serait lourd de devoir récupérer chaque item un par un, une technique supérieure est d\u0026rsquo;utiliser la forme plurielle findElements(By). Cette méthode retourne une collection d\u0026rsquo;éléments web. Si un seul élement a été trouvé, la méthode renverra tout de même une collection (d\u0026rsquo;un seul élément). Si aucun élément ne correspond au sélécteur, la collection retournée sera alors vide.\nJava Python C# Ruby JavaScript Kotlin List\u0026lt;WebElement\u0026gt; pleinDeFromage = driver.findElements(By.cssSelector(\u0026#34;#fromage li\u0026#34;));   plein_de_fromage = driver.find_elements_by_css_selector(\u0026#34;#fromage li\u0026#34;)   IReadOnlyList\u0026lt;IWebElement\u0026gt; pleinDeFromage = driver.FindElements(By.CssSelector(“#fromage li”));   plein_de_fromage = driver.find_elements(css: \u0026#39;#fromage li\u0026#39;)   const pleinDeFromage = driver.findElements(By.css(\u0026#39;#fromage li\u0026#39;));   val muchoCheese: List\u0026lt;WebElement\u0026gt; = driver.findElements(By.cssSelector(\u0026#34;#cheese li\u0026#34;))     Stratégie de sélection des éléments WebDriver possède huit stratégies de localisation pré-définies différentes:\n   Sélecteur Description     class name Localise les éléments dont le nom de la classe contient la valeur recherchée (nom composés non permis)   css selector Localise les éléments correspondant à un sélecteur CSS   id Localise les éléments dont l\u0026rsquo;attribut ID correspond à la valeur recherchée   name Localise les éléments dont l\u0026rsquo;attribut NAME correspond à la valeur recherchée   link text Localise les éléments de type ancre (lien) dont le texte visible correspond à la valeur recherchée   partial link text Localise les éléments de type ancre (lien) dont le texte visible contient la valeur recherchée   tag name Localise les éléments dont le nom de tag correspond à la valeur recherchée   xpath Localise les éléments correspondant à un chemin XPath    Astuces d\u0026rsquo;utilisation des sélecteurs En règle général, si des ID HTML sont disponibles, uniques et prédictibles avec constance, alors il est préférable d\u0026rsquo;utiliser cette stratégie pour la localisation d\u0026rsquo;élément sur une page. Elle a tendance à être très rapide et évite les longs traitements liés à des traversées complexes du DOM.\nSi des IDs uniques ne sont pas disponibles, un sélecteur CSS bien écrit est la méthode de localisation la plus adaptée. Un sélecteur XPath marchera aussi bien qu\u0026rsquo;un sélecteur CSS, cependant sa syntaxe est plus complexe, et souvent, plus compliquée à débugguer. Même si les sélecteur XPath sont très flexibles, ils sont rarement testés d\u0026rsquo;un point de vue performance par les fournisseurs de navigateur et ont donc tendance à être assez lents.\nLes stratégies basés sur link text et partial link text sont contraingnantes du fait qu\u0026rsquo;elles ne fonctionnent que sur des éléments de type lien hypertexte. De plus, elles sont implémentées au sein de WebDriver via des sélecteurs XPath.\nLe nom de tag est une façon dangereuse de localiser des éléments. Il y a fréquemment de multiples éléments ayant le même tag sur une page. Cette stratégie est principalement utile lorsque utilisée avec la méthode findElements(By), renvoyant une collection des élements.\nAu final, la recommendation est de garder ses sélecteurs aussi compacts et lisibles que possible. Demander à WebDriver de traverser la structure du DOM est une opération très coûteuse, de fait plus le scope de recherche sera restreint, meilleures seront les performances.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/webdriver/browser_manipulation/",
	"title": "Manipulation du navigateur",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Ruby Ruby is not installed by default on Windows. Download the latest version and run the installer. You can leave all settings at default values, except at the Installation Destination and Optional Tasks screen check Add Ruby executables to your PATH checkbox. To drive any browser, you have to install selenium-webdriver Ruby gem. To install it, open command prompt and type this:\ngem install selenium-webdriver Or, if you use Bundler, add this line to your application\u0026rsquo;s Gemfile:\ngem \u0026#34;selenium-webdriver\u0026#34; And then execute the following command in prompt:\nbundle install Internet Explorer Internet Explorer is installed by default on Windows, so no installation is needed. To drive Internet Explorer on Windows, you have to download the latest Internet Explorer Driver and put the file into a folder that is in PATH. To find out which directories are in PATH, type echo %PATH% in command prompt.\n$ echo %PATH% C:\\Ruby200\\bin;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem C:\\Ruby200\\bin looks like a good place. Unzip IEDriverServer file and move IEDriverServer.exe there.\nThis should open a new Internet Explorer window:\nrequire \u0026#34;selenium-webdriver\u0026#34; driver = Selenium::WebDriver.for :internet_explorer Browser navigation Navigate to The first thing you will want to do after launching a browser is to open your website. This can be achieved in a single line:\nJava Python C# Ruby JavaScript Kotlin //Convenient driver.get(\u0026#34;https://selenium.dev\u0026#34;); //Longer way driver.navigate().to(\u0026#34;https://selenium.dev\u0026#34;);   driver.get(\u0026#34;https://selenium.dev\u0026#34;)   driver.Navigate().GoToUrl(@\u0026#34;https://selenium.dev\u0026#34;);   # Convenient way driver.get \u0026#39;https://selenium.dev\u0026#39; # Longer Way driver.navigate.to \u0026#39;https://selenium.dev\u0026#39;   await driver.get(\u0026#39;https://selenium.dev\u0026#39;);   //Convenient driver.get(\u0026#34;https://selenium.dev\u0026#34;) //Longer way driver.navigate().to(\u0026#34;https://selenium.dev\u0026#34;)     Get current URL You can read the current URL from the browser\u0026rsquo;s address bar using:\nJava Python C# Ruby JavaScript Kotlin driver.getCurrentUrl();  driver.current_url  driver.Url;   driver.current_url  await driver.getCurrentUrl();   driver.getCurrentUrl();    Back Pressing the browser\u0026rsquo;s back button:\nJava Python C# Ruby JavaScript Kotlin driver.navigate().back();  driver.back()  driver.Navigate().Back();   driver.navigate.back  await driver.navigate().back();   driver.navigate().back()     Forward Pressing the browser\u0026rsquo;s forward button:\nJava Python C# Ruby JavaScript Kotlin driver.navigate().forward();  driver.forward()  driver.Navigate().Forward();   driver.navigate.forward  await driver.navigate().forward();   driver.navigate().forward();    Refresh Refresh the current page:\nJava Python C# Ruby JavaScript Kotlin driver.navigate().refresh();  driver.refresh()  driver.Navigate().Refresh();   driver.navigate.refresh  await driver.navigate().refresh();   driver.navigate().refresh()    Get title You can read the current page title from the browser:\nJava Python C# Ruby JavaScript Kotlin driver.getTitle();  driver.title  driver.Title;   driver.title  await driver.getTitle();   driver.getTitle()    Windows and tabs WebDriver doesn\u0026rsquo;t make the distinction between windows and tabs. If your site opens a new tab or window, Selenium will let you work with it using a window handle. Each window has a unique identifier which remains persistent in a single session. You can get the window handle of the current window by using:\nJava Python C# Ruby JavaScript Kotlin driver.getWindowHandle();  driver.current_window_handle  driver.CurrentWindowHandle;   driver.window_handle  await driver.getWindowHandle();   driver.getWindowHandle()    Switching windows or tabs Clicking a link which opens in a new window will focus the new window or tab on screen, but WebDriver will not know which window the Operating System considers active. To work with the new window you will need to switch to it. If you have only two tabs or windows open, and you know which window you start with, by the process of elimination you can loop over both windows or tabs that WebDriver can see, and switch to the one which is not the original.\nHowever, Selenium 4 provides a new api NewWindow  which creates a new tab (or) new window and automatically switches to it.\nJava Python C# Ruby JavaScript Kotlin //Store the ID of the original window String originalWindow = driver.getWindowHandle(); //Check we don\u0026#39;t have other windows open already assert driver.getWindowHandles().size() == 1; //Click the link which opens in a new window driver.findElement(By.linkText(\u0026#34;new window\u0026#34;)).click(); //Wait for the new window or tab wait.until(numberOfWindowsToBe(2)); //Loop through until we find a new window handle for (String windowHandle : driver.getWindowHandles()) { if(!originalWindow.contentEquals(windowHandle)) { driver.switchTo().window(windowHandle); break; } } //Wait for the new tab to finish loading content wait.until(titleIs(\u0026#34;Selenium documentation\u0026#34;));   from selenium import webdriver from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC # Start the driver with webdriver.Firefox() as driver: # Open URL driver.get(\u0026#34;https://seleniumhq.github.io\u0026#34;) # Setup wait for later wait = WebDriverWait(driver, 10) # Store the ID of the original window original_window = driver.current_window_handle # Check we don\u0026#39;t have other windows open already assert len(driver.window_handles) == 1 # Click the link which opens in a new window driver.find_element_by_link_text(\u0026#34;new window\u0026#34;).click() # Wait for the new window or tab wait.until(EC.number_of_windows_to_be(2)) # Loop through until we find a new window handle for window_handle in driver.window_handles: if window_handle != original_window: driver.switch_to.window(window_handle) break # Wait for the new tab to finish loading content wait.until(EC.title_is(\u0026#34;SeleniumHQ Browser Automation\u0026#34;))   //Store the ID of the original window string originalWindow = driver.CurrentWindowHandle; //Check we don\u0026#39;t have other windows open already Assert.AreEqual(driver.WindowHandles.Count, 1); //Click the link which opens in a new window driver.FindElement(By.LinkText(\u0026#34;new window\u0026#34;)).Click(); //Wait for the new window or tab wait.Until(wd =\u0026gt; wd.WindowHandles.Count == 2); //Loop through until we find a new window handle foreach(string window in driver.WindowHandles) { if(originalWindow != window) { driver.SwitchTo().Window(window); break; } } //Wait for the new tab to finish loading content wait.Until(wd =\u0026gt; wd.Title == \u0026#34;Selenium documentation\u0026#34;);   #Store the ID of the original window original_window = driver.window_handle #Check we don\u0026#39;t have other windows open already assert(driver.window_handles.length == 1, \u0026#39;Expected one window\u0026#39;) #Click the link which opens in a new window driver.find_element(link: \u0026#39;new window\u0026#39;).click #Wait for the new window or tab wait.until { driver.window_handles.length == 2 } #Loop through until we find a new window handle driver.window_handles.each do |handle| if handle != original_window driver.switch_to.window handle break end end #Wait for the new tab to finish loading content wait.until { driver.title == \u0026#39;Selenium documentation\u0026#39;}   //Store the ID of the original window const originalWindow = await driver.getWindowHandle(); //Check we don\u0026#39;t have other windows open already assert((await driver.getAllWindowHandles()).length === 1); //Click the link which opens in a new window await driver.findElement(By.linkText(\u0026#39;new window\u0026#39;)).click(); //Wait for the new window or tab await driver.wait( async () =\u0026gt; (await driver.getAllWindowHandles()).length === 2, 10000 ); //Loop through until we find a new window handle const windows = await driver.getAllWindowHandles(); windows.forEach(async handle =\u0026gt; { if (handle !== originalWindow) { await driver.switchTo().window(handle); } }); //Wait for the new tab to finish loading content await driver.wait(until.titleIs(\u0026#39;Selenium documentation\u0026#39;), 10000);   //Store the ID of the original window val originalWindow = driver.getWindowHandle() //Check we don\u0026#39;t have other windows open already assert(driver.getWindowHandles().size() === 1) //Click the link which opens in a new window driver.findElement(By.linkText(\u0026#34;new window\u0026#34;)).click() //Wait for the new window or tab wait.until(numberOfWindowsToBe(2)) //Loop through until we find a new window handle for (windowHandle in driver.getWindowHandles()) { if (!originalWindow.contentEquals(windowHandle)) { driver.switchTo().window(windowHandle) break } } //Wait for the new tab to finish loading content wait.until(titleIs(\u0026#34;Selenium documentation\u0026#34;))     Create new window (or) new tab and switch Creates a new window (or) tab and will focus the new window or tab on screen. You don\u0026rsquo;t need to switch to work with the new window (or) tab. If you have more than two windows (or) tabs opened other than the new window, you can loop over both windows or tabs that WebDriver can see, and switch to the one which is not the original.\nNote: This feature works with Selenium 4 and later versions.\nJava Python C# Ruby JavaScript Kotlin // Opens a new tab and switches to new tab driver.switchTo().newWindow(WindowType.TAB); // Opens a new window and switches to new window driver.switchTo().newWindow(WindowType.WINDOW);   # Opens a new tab and switches to new tab driver.switch_to.new_window(\u0026#39;tab\u0026#39;) # Opens a new window and switches to new window driver.switch_to.new_window(\u0026#39;window\u0026#39;)   // Opens a new tab and switches to new tab driver.SwitchTo().NewWindow(WindowType.Tab) // Opens a new window and switches to new window driver.SwitchTo().NewWindow(WindowType.Window)   # Note: The new_window in ruby only opens a new tab (or) Window and will not switch automatically # The user has to switch to new tab (or) new window # Opens a new tab and switches to new tab driver.manage.new_window(:tab) # Opens a new window and switches to new window driver.manage.new_window(:window)   // Opens a new tab and switches to new tab await driver.switchTo().newWindow(\u0026#39;tab\u0026#39;); // Opens a new window and switches to new window await driver.switchTo().newWindow(\u0026#39;window\u0026#39;);   // Opens a new tab and switches to new tab driver.switchTo().newWindow(WindowType.TAB) // Opens a new window and switches to new window driver.switchTo().newWindow(WindowType.WINDOW)     Closing a window or tab When you are finished with a window or tab and it is not the last window or tab open in your browser, you should close it and switch back to the window you were using previously. Assuming you followed the code sample in the previous section you will have the previous window handle stored in a variable. Put this together and you will get:\nJava Python C# Ruby JavaScript Kotlin //Close the tab or window driver.close(); //Switch back to the old tab or window driver.switchTo().window(originalWindow);   #Close the tab or window driver.close() #Switch back to the old tab or window driver.switch_to.window(original_window)   //Close the tab or window driver.Close(); //Switch back to the old tab or window driver.SwitchTo().Window(originalWindow);   #Close the tab or window driver.close #Switch back to the old tab or window driver.switch_to.window original_window   //Close the tab or window await driver.close(); //Switch back to the old tab or window await driver.switchTo().window(originalWindow);   //Close the tab or window driver.close() //Switch back to the old tab or window driver.switchTo().window(originalWindow)     Forgetting to switch back to another window handle after closing a window will leave WebDriver executing on the now closed page, and will trigger a No Such Window Exception. You must switch back to a valid window handle in order to continue execution.\nQuitting the browser at the end of a session When you are finished with the browser session you should call quit, instead of close:\nJava Python C# Ruby JavaScript Kotlin driver.quit();  driver.quit()  driver.Quit();   driver.quit  await driver.quit();   driver.quit()     Quit will:  Close all the windows and tabs associated with that WebDriver session The browser process The background driver process Notify Selenium Grid that the browser is no longer in use so it can be used by another session (if you are using Selenium Grid)   Failure to call quit will leave extra background processes and ports running on your machine which could cause you problems later.\nSome test frameworks offer methods and annotations which you can hook into to tear down at the end of a test.\nJava Python C# Ruby JavaScript Kotlin /** * Example using JUnit * https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/AfterAll.html */ @AfterAll public static void tearDown() { driver.quit(); }   # We don\u0026#39;t have a Python code sample yet - Help us out and raise a PR    /* Example using Visual Studio\u0026#39;s UnitTesting https://msdn.microsoft.com/en-us/library/microsoft.visualstudio.testtools.unittesting.aspx */ [TestCleanup] public void TearDown() { driver.Quit(); }   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    /** * Example using Mocha * https://mochajs.org/#hooks */ after(\u0026#39;Tear down\u0026#39;, async function () { await driver.quit(); });   /** * Example using JUnit * https://junit.org/junit5/docs/current/api/org/junit/jupiter/api/AfterAll.html */ @AfterAll fun tearDown() { driver.quit() }     If not running WebDriver in a test context, you may consider using try / finally which is offered by most languages so that an exception will still clean up the WebDriver session.\nJava Python C# Ruby JavaScript Kotlin try { //WebDriver code here... } finally { driver.quit(); }   try: #WebDriver code here... finally: driver.quit()   try { //WebDriver code here... } finally { driver.Quit(); }   begin #WebDriver code here... ensure driver.quit end   try { //WebDriver code here... } finally { await driver.quit(); }   try { //WebDriver code here... } finally { driver.quit() }     Python\u0026rsquo;s WebDriver now supports the python context manager, which when using the with keyword can automatically quit the driver at the end of execution.\nwith webdriver.Firefox() as driver: # WebDriver code here... # WebDriver will automatically quit after indentation Frames and Iframes Frames are a now deprecated means of building a site layout from multiple documents on the same domain. You are unlikely to work with them unless you are working with an pre HTML5 webapp. Iframes allow the insertion of a document from an entirely different domain, and are still commonly used.\nIf you need to work with frames or iframes, Webdriver allows you to work with them in the same way. Consider a button within an iframe. If we inspect the element using the browser development tools, we might see the following:\n\u0026lt;div id=\u0026#34;modal\u0026#34;\u0026gt; \u0026lt;iframe id=\u0026#34;buttonframe\u0026#34; name=\u0026#34;myframe\u0026#34; src=\u0026#34;https://seleniumhq.github.io\u0026#34;\u0026gt; \u0026lt;button\u0026gt;Click here\u0026lt;/button\u0026gt; \u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; If it wasn\u0026rsquo;t for the iframe we would expect to click on the button using something like:\nJava Python C# Ruby JavaScript Kotlin //This won\u0026#39;t work driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # This Wont work driver.find_element_by_tag_name(\u0026#39;button\u0026#39;).click()   //This won\u0026#39;t work driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # This won\u0026#39;t work driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   // This won\u0026#39;t work await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   //This won\u0026#39;t work driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     However, if there are no buttons outside of the iframe, you might instead get a no such element error. This happens because Selenium is only aware of the elements in the top level document. To interact with the button, we will need to first switch to the frame, in a similar way to how we switch windows. WebDriver offers three ways of switching to a frame.\nUsing a WebElement Switching using a WebElement is the most flexible option. You can find the frame using your preferred selector and switch to it.\nJava Python C# Ruby JavaScript Kotlin //Store the web element WebElement iframe = driver.findElement(By.cssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)); //Switch to the frame driver.switchTo().frame(iframe); //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # Store iframe web element iframe = driver.find_element_by_css_selector(\u0026#34;#modal \u0026gt; iframe\u0026#34;) # switch to selected iframe driver.switch_to.frame(iframe) # Now click on button driver.find_element_by_tag_name(\u0026#39;button\u0026#39;).click()   //Store the web element IWebElement iframe = driver.FindElement(By.CssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)); //Switch to the frame driver.SwitchTo().Frame(iframe); //Now we can click the button driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # Store iframe web element iframe = driver.find_element(:css,\u0026#39;#modal \u0026gt; iframe\u0026#39;) # Switch to the frame driver.switch_to.frame iframe # Now, Click on the button driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   // Store the web element const iframe = driver.findElement(By.css(\u0026#39;#modal \u0026gt; iframe\u0026#39;)); // Switch to the frame await driver.switchTo().frame(iframe); // Now we can click the button await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   //Store the web element WebElement iframe = driver.findElement(By.cssSelector(\u0026#34;#modal\u0026gt;iframe\u0026#34;)) //Switch to the frame driver.switchTo().frame(iframe) //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     Using a name or ID If your frame or iframe has an id or name attribute, this can be used instead. If the name or ID is not unique on the page, then the first one found will be switched to.\nJava Python C# Ruby JavaScript Kotlin //Using the ID driver.switchTo().frame(\u0026#34;buttonframe\u0026#34;); //Or using the name instead driver.switchTo().frame(\u0026#34;myframe\u0026#34;); //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click();   # Switch frame by id driver.switch_to.frame(\u0026#39;buttonframe\u0026#39;) # Now, Click on the button driver.find_element_by_tag_name(\u0026#39;button\u0026#39;).click()   //Using the ID driver.SwitchTo().Frame(\u0026#34;buttonframe\u0026#34;); //Or using the name instead driver.SwitchTo().Frame(\u0026#34;myframe\u0026#34;); //Now we can click the button driver.FindElement(By.TagName(\u0026#34;button\u0026#34;)).Click();   # Switch by ID driver.switch_to.frame \u0026#39;buttonframe\u0026#39; # Now, Click on the button driver.find_element(:tag_name,\u0026#39;button\u0026#39;).click   // Using the ID await driver.switchTo().frame(\u0026#39;buttonframe\u0026#39;); // Or using the name instead await driver.switchTo().frame(\u0026#39;myframe\u0026#39;); // Now we can click the button await driver.findElement(By.css(\u0026#39;button\u0026#39;)).click();   //Using the ID driver.switchTo().frame(\u0026#34;buttonframe\u0026#34;) //Or using the name instead driver.switchTo().frame(\u0026#34;myframe\u0026#34;) //Now we can click the button driver.findElement(By.tagName(\u0026#34;button\u0026#34;)).click()     Using an index It is also possible to use the index of the frame, such as can be queried using window.frames in JavaScript.\nJava Python C# Ruby JavaScript Kotlin // Switches to the second frame driver.switchTo().frame(1);   # Switch to the second frame driver.switch_to.frame(1)   // Switches to the second frame driver.SwitchTo().Frame(1);   # switching to second iframe based on index iframe = driver.find_elements_by_tag_name(\u0026#39;iframe\u0026#39;)[1] # switch to selected iframe driver.switch_to.frame(iframe)   // Switches to the second frame await driver.switchTo().frame(1);   // Switches to the second frame driver.switchTo().frame(1)     Leaving a frame To leave an iframe or frameset, switch back to the default content like so:\nJava Python C# Ruby JavaScript Kotlin // Return to the top level driver.switchTo().defaultContent();   # switch back to default content driver.switch_to.default_content()   // Return to the top level driver.SwitchTo().DefaultContent();   # Return to the top level driver.switch_to.default_content   // Return to the top level await driver.switchTo().defaultContent();   // Return to the top level driver.switchTo().defaultContent()     Window management Screen resolution can impact how your web application renders, so WebDriver provides mechanisms for moving and resizing the browser window.\nGet window size Fetches the size of the browser window in pixels.\nJava Python C# Ruby JavaScript Kotlin //Access each dimension individually int width = driver.manage().window().getSize().getWidth(); int height = driver.manage().window().getSize().getHeight(); //Or store the dimensions and query them later Dimension size = driver.manage().window().getSize(); int width1 = size.getWidth(); int height1 = size.getHeight();   # Access each dimension individually width = driver.get_window_size().get(\u0026#34;width\u0026#34;) height = driver.get_window_size().get(\u0026#34;height\u0026#34;) # Or store the dimensions and query them later size = driver.get_window_size() width1 = size.get(\u0026#34;width\u0026#34;) height1 = size.get(\u0026#34;height\u0026#34;)   //Access each dimension individually int width = driver.Manage().Window.Size.Width; int height = driver.Manage().Window.Size.Height; //Or store the dimensions and query them later System.Drawing.Size size = driver.Manage().Window.Size; int width1 = size.Width; int height1 = size.Height;   # Access each dimension individually width = driver.manage.window.size.width height = driver.manage.window.size.height # Or store the dimensions and query them later size = driver.manage.window.size width1 = size.width height1 = size.height   // Access each dimension individually const { width, height } = await driver.manage().window().getRect(); // Or store the dimensions and query them later const rect = await driver.manage().window().getRect(); const width1 = rect.width; const height1 = rect.height;   //Access each dimension individually val width = driver.manage().window().getSize().getWidth() val height = driver.manage().window().getSize().getHeight() //Or store the dimensions and query them later val size = driver.manage().window().getSize() val width1 = size.getWidth() val height1 = size.getHeight()     Set window size Restores the window and sets the window size. Java Python C# Ruby JavaScript Kotlin driver.manage().window().setSize(new Dimension(1024, 768));  driver.set_window_size(1024, 768)  driver.Manage().Window.Size = new Size(1024, 768);   driver.manage.window.resize_to(1024,768)  await driver.manage().window().setRect({ width: 1024, height: 768 });   driver.manage().window().size(Dimension(1024, 768))   \nGet window position Fetches the coordinates of the top left coordinate of the browser window.\nJava Python C# Ruby JavaScript Kotlin // Access each dimension individually int x = driver.manage().window().getPosition().getX(); int y = driver.manage().window().getPosition().getY(); // Or store the dimensions and query them later Point position = driver.manage().window().getPosition(); int x1 = position.getX(); int y1 = position.getY();   # Access each dimension individually x = driver.get_window_position().get(\u0026#39;x\u0026#39;) y = driver.get_window_position().get(\u0026#39;y\u0026#39;) # Or store the dimensions and query them later position = driver.get_window_position() x1 = position.get(\u0026#39;x\u0026#39;) y1 = position.get(\u0026#39;y\u0026#39;)   //Access each dimension individually int x = driver.Manage().Window.Position.X; int y = driver.Manage().Window.Position.Y; //Or store the dimensions and query them later Point position = driver.Manage().Window.Position; int x1 = position.X; int y1 = position.Y;   # We don\u0026#39;t have a Ruby code sample yet - Help us out and raise a PR    // Access each dimension individually const { x, y } = await driver.manage().window().getRect(); // Or store the dimensions and query them later const rect = await driver.manage().window().getRect(); const x1 = rect.x; const y1 = rect.y;   // Access each dimension individually val x = driver.manage().window().position.x val y = driver.manage().window().position.y // Or store the dimensions and query them later val position = driver.manage().window().position val x1 = position.x int y1 = position.y     Set window position Moves the window to the chosen position.\nJava Python C# Ruby JavaScript Kotlin // Move the window to the top left of the primary monitor driver.manage().window().setPosition(new Point(0, 0));   # Move the window to the top left of the primary monitor driver.set_window_position(0, 0)   // Move the window to the top left of the primary monitor driver.Manage().Window.Position = new Point(0, 0);   driver.manage.window.move_to(0,0)   // Move the window to the top left of the primary monitor await driver.manage().window().setRect({ x: 0, y: 0 });   // Move the window to the top left of the primary monitor driver.manage().window().position = Point(0,0)     Maximise window Enlarges the window. For most operating systems, the window will fill the screen, without blocking the operating system\u0026rsquo;s own menus and toolbars.\nJava Python C# Ruby JavaScript Kotlin driver.manage().window().maximize();  driver.maximize_window()  driver.Manage().Window.Maximize();   driver.manage.window.maximize  await driver.manage().window().maximize();   driver.manage().window().maximize()    Fullscreen window Fills the entire screen, similar to pressing F11 in most browsers.\nJava Python C# Ruby JavaScript Kotlin driver.manage().window().fullscreen();  driver.fullscreen_window()  driver.Manage().Window.FullScreen();   driver.manage.window.full_screen  await driver.manage().window().fullscreen();   driver.manage().window().fullscreen()    "
},
{
	"uri": "https://selenium.dev/documentation/fr/grid/setting_up_your_own_grid/",
	"title": "Mettre en place votre propre Grid",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n To use Selenium Grid, you need to maintain your own infrastructure for the nodes. As this can be a cumbersome and time intense effort, many organizations use IaaS providers such as Amazon EC2 and Google Compute to provide this infrastructure.\nOther options include using providers such as Sauce Labs or Testing Bot who provide a Selenium Grid as a service in the cloud. It is certainly possible to also run nodes on your own hardware. This chapter will go into detail about the option of running your own grid, complete with its own node infrastructure.\nQuick start This example will show you how to start the Selenium 2 Grid Hub, and register both a WebDriver node and a Selenium 1 RC legacy node. We will also show you how to call the grid from Java. The hub and nodes are shown here running on the same machine, but of course you can copy the selenium-server-standalone to multiple machines.\nThe selenium-server-standalone package includes the hub, WebDriver, and legacy RC needed to run the Grid, ant is not required anymore. You can download the selenium-server-standalone-.jar from https://selenium.dev/downloads/.\nStep 1: Start the Hub The Hub is the central point that will receive test requests and distribute them to the right nodes. The distribution is done on a capabilities basis, meaning a test requiring a set of capabilities will only be distributed to nodes offering that set or subset of capabilities.\nBecause a test\u0026rsquo;s desired capabilities are just what the name implies, desired, the hub cannot guarantee that it will locate a node fully matching the requested desired capabilities set.\nOpen a command prompt and navigate to the directory where you copied the selenium-server-standalone.jar file. You start the hub by passing the -role hub flag to the standalone server:\njava -jar selenium-server-standalone.jar -role hub The Hub will listen to port 4444 by default. You can view the status of the hub by opening a browser window and navigating to http://localhost:4444/grid/console.\nTo change the default port, you can add the optional -port flag with an integer representing the port to listen to when you run the command. Also, all of the other options you see in the JSON config file (seen below) are possible command-line flags.\nYou certainly can get by with only the simple command shown above, but if you need more advanced configuration, you can also specify a JSON format config file, for convenience, to configure the hub when you start it. You can do it like so:\njava -jar selenium-server-standalone.jar -role hub -hubConfig hubConfig.json -debug Below you will see an example of a hubConfig.json file. We will go into more detail on how to provide node configuration files in step 2.\n{ \u0026#34;_comment\u0026#34; : \u0026#34;Configuration for Hub - hubConfig.json\u0026#34;, \u0026#34;host\u0026#34;: ip, \u0026#34;maxSession\u0026#34;: 5, \u0026#34;port\u0026#34;: 4444, \u0026#34;cleanupCycle\u0026#34;: 5000, \u0026#34;timeout\u0026#34;: 300000, \u0026#34;newSessionWaitTimeout\u0026#34;: -1, \u0026#34;servlets\u0026#34;: [], \u0026#34;prioritizer\u0026#34;: null, \u0026#34;capabilityMatcher\u0026#34;: \u0026#34;org.openqa.grid.internal.utils.DefaultCapabilityMatcher\u0026#34;, \u0026#34;throwOnCapabilityNotPresent\u0026#34;: true, \u0026#34;nodePolling\u0026#34;: 180000, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;} Step 2: Start the Nodes Regardless of whether you want to run a grid with new WebDriver functionality, or a grid with Selenium 1 RC functionality, or both at the same time, you use the same selenium-server-standalone.jar file to start the nodes:\njava -jar selenium-server-standalone.jar -role node -hub http://localhost:4444 If a port is not specified through the -port flag, a free port will be chosen. You can run multiple nodes on one machine but if you do so, you need to be aware of your systems memory resources and problems with screenshots if your tests take them.\nConfiguration of Node with options As mentioned, for backwards compatibility “wd” and “rc” roles are still a valid subset of the “node” role. But those roles limit the types of remote connections to their corresponding API, while “node” allows both RC and WebDriver remote connections.\nPassing JVM properties (using the -D flag before the -jar argument) on the command line as well, and these will be picked up and propagated to the nodes:\n-Dwebdriver.chrome.driver=chromedriver.exe\nConfiguration of Node with JSON You can also start grid nodes that are configured with a JSON configuration file\njava -Dwebdriver.chrome.driver=chromedriver.exe -jar selenium-server-standalone.jar -role node -nodeConfig node1Config.json And here is an example of a nodeConfig.json file:\n{ \u0026#34;capabilities\u0026#34;: [ { \u0026#34;browserName\u0026#34;: \u0026#34;firefox\u0026#34;, \u0026#34;acceptSslCerts\u0026#34;: true, \u0026#34;javascriptEnabled\u0026#34;: true, \u0026#34;takesScreenshot\u0026#34;: false, \u0026#34;firefox_profile\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;browser-version\u0026#34;: \u0026#34;27\u0026#34;, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;maxInstances\u0026#34;: 5, \u0026#34;firefox_binary\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;cleanSession\u0026#34;: true }, { \u0026#34;browserName\u0026#34;: \u0026#34;chrome\u0026#34;, \u0026#34;maxInstances\u0026#34;: 5, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;webdriver.chrome.driver\u0026#34;: \u0026#34;C:/Program Files (x86)/Google/Chrome/Application/chrome.exe\u0026#34; }, { \u0026#34;browserName\u0026#34;: \u0026#34;internet explorer\u0026#34;, \u0026#34;maxInstances\u0026#34;: 1, \u0026#34;platform\u0026#34;: \u0026#34;WINDOWS\u0026#34;, \u0026#34;webdriver.ie.driver\u0026#34;: \u0026#34;C:/Program Files (x86)/Internet Explorer/iexplore.exe\u0026#34; } ], \u0026#34;configuration\u0026#34;: { \u0026#34;_comment\u0026#34; : \u0026#34;Configuration for Node\u0026#34;, \u0026#34;cleanUpCycle\u0026#34;: 2000, \u0026#34;timeout\u0026#34;: 30000, \u0026#34;proxy\u0026#34;: \u0026#34;org.openqa.grid.selenium.proxy.WebDriverRemoteProxy\u0026#34;, \u0026#34;port\u0026#34;: 5555, \u0026#34;host\u0026#34;: ip, \u0026#34;register\u0026#34;: true, \u0026#34;hubPort\u0026#34;: 4444, \u0026#34;maxSession\u0026#34;: 5 } } A note about the -host flag\nFor both hub and node, if the -host flag is not specified, 0.0.0.0 will be used by default. This will bind to all the public (non-loopback) IPv4 interfaces of the machine. If you have a special network configuration or any component that creates extra network interfaces, it is advised to set the -host flag with a value that allows the hub/node to be reachable from a different machine.\nSpecifying the port The default TCP/IP port used by the hub is 4444. If you need to change the port please use above mentioned configurations.\nTroubleshooting Using Log file For advanced troubleshooting you can specify a log file to log system messages. Start Selenium GRID hub or node with -log argument. Please see the below example:\njava -jar selenium-server-standalone.jar -role hub -log log.txt Use your favorite text editor to open log file (log.txt in the example above) to find \u0026ldquo;ERROR\u0026rdquo; logs if you get issues.\nUsing -debug argument Also you can use -debug argument to print debug logs to console. Start Selenium Grid Hub or Node with -debug argument. Please see the below example:\njava -jar selenium-server-standalone.jar -role hub -debug Warning The Selenium Grid must be protected from external access using appropriate firewall permissions.\nFailure to protect your Grid could result in one or more of the following occurring:\n You provide open access to your Grid infrastructure You allow third parties to access internal web applications and files You allow third parties to run custom binaries  See this blog post on Detectify, which gives a good overview of how a publicly exposed Grid could be misused: Don\u0026rsquo;t Leave your Grid Wide Open.\nDocker Selenium Docker provides a convenient way to provision and scale Selenium Grid infrastructure in a unit known as a container. Containers are standardised units of software that contain everything required to run the desired application, including all dependencies, in a reliable and repeatable way on different machines.\nThe Selenium project maintains a set of Docker images which you can download and run to get a working grid up and running quickly. Nodes are available for both Firefox and Chrome. Full details of how to provision a grid can be found within the Docker Selenium repository.\nPrerequisite The only requirement to run a Grid is to have Docker installed and working. Install Docker.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/legacy_docs/html-runner/",
	"title": "Runner HTML",
	"tags": [],
	"description": "",
	"content": " Selenium HTML-runner permet d\u0026rsquo;exécuter des Test Suites depuis la ligne de commande. Les Tests Suites sont des exports HTML depuis Selenium IDE ou autre outil compatible.\nInformations générales  Les combinaisons de version de geckodriver / firefox / selenium-html-runner sont importantes. Il doit y avoir une matrice de compatibilité quelque part. selenium-html-runner exécute seulement des Test Suites (et non pas des Test Case, comme un export de Monitis Transaction Monitor). Assurez-vous de vous y conformer. Pour les utilisateurs Linux sans affichage - vous devez exécuter html-runner avec un affichage virtuel (cherchez xvfb)  Exemple sur environnement Linux Installer / télécharger les packages suivants:\n[user@localhost ~]$ cat /etc/redhat-release CentOS Linux release 7.4.1708 (Core) [user@localhost ~]$ rpm -qa | egrep -i \u0026#34;xvfb|java-1.8|firefox\u0026#34; xorg-x11-server-Xvfb-1.19.3-11.el7.x86_64 firefox-52.4.0-1.el7.centos.x86_64 java-1.8.0-openjdk-1.8.0.151-1.b12.el7_4.x86_64 java-1.8.0-openjdk-headless-1.8.0.151-1.b12.el7_4.x86_64 Example de Test Suite:\n[user@localhost ~]$ cat testsuite.html \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE html PUBLIC \u0026#34;-//W3C//DTD XHTML 1.0 Strict//EN\u0026#34; \u0026#34;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\u0026#34;\u0026gt; \u0026lt;html xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34; xml:lang=\u0026#34;en\u0026#34; lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta content=\u0026#34;text/html; charset=UTF-8\u0026#34; http-equiv=\u0026#34;content-type\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Test Suite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table id=\u0026#34;suiteTable\u0026#34; cellpadding=\u0026#34;1\u0026#34; cellspacing=\u0026#34;1\u0026#34; border=\u0026#34;1\u0026#34; class=\u0026#34;selenium\u0026#34;\u0026gt;\u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;b\u0026gt;Test Suite\u0026lt;/b\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;YOUR-TEST-SCENARIO.html\u0026#34;\u0026gt;YOUR-TEST-SCENARIO\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt;\u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Comment exécuter selenium-html-runner en mode headless Pour la partie la plus importante, voici un exemple d\u0026rsquo;exécution de selenium-html-runner ! Votre expérience peut varier selon les combinaisons logicielles - versions de geckodriver/FF/html-runner.\nxvfb-run java -Dwebdriver.gecko.driver=/home/mmasek/geckodriver.0.18.0 -jar selenium-html-runner-3.7.1.jar -htmlSuite \u0026#34;firefox\u0026#34; \u0026#34;https://YOUR-BASE-URL\u0026#34; \u0026#34;$(pwd)/testsuite.html\u0026#34; \u0026#34;results.html\u0026#34; ; grep result: -A1 results.html/firefox.results.html[user@localhost ~]$ xvfb-run java -Dwebdriver.gecko.driver=/home/mmasek/geckodriver.0.18.0 -jar selenium-html-runner-3.7.1.jar -htmlSuite \u0026#34;*firefox\u0026#34; \u0026#34;https://YOUR-BASE-URL\u0026#34; \u0026#34;$(pwd)/testsuite.html\u0026#34; \u0026#34;results.html\u0026#34; ; grep result: -A1 results.html/firefox.results.html Multi-window mode is longer used as an option and will be ignored. 1510061109691 geckodriver INFO geckodriver 0.18.0 1510061109708 geckodriver INFO Listening on 127.0.0.1:2885 1510061110162 geckodriver::marionette INFO Starting browser /usr/bin/firefox with args [\u0026#34;-marionette\u0026#34;] 1510061111084 Marionette INFO Listening on port 43229 1510061111187 Marionette WARN TLS certificate errors will be ignored for this session Nov 07, 2017 1:25:12 PM org.openqa.selenium.remote.ProtocolHandshake createSession INFO: Detected dialect: W3C 2017-11-07 13:25:12.714:INFO::main: Logging initialized @3915ms to org.seleniumhq.jetty9.util.log.StdErrLog 2017-11-07 13:25:12.804:INFO:osjs.Server:main: jetty-9.4.z-SNAPSHOT 2017-11-07 13:25:12.822:INFO:osjsh.ContextHandler:main: Started o.s.j.s.h.ContextHandler@87a85e1{/tests,null,AVAILABLE} 2017-11-07 13:25:12.843:INFO:osjs.AbstractConnector:main: Started ServerConnector@52102734{HTTP/1.1,[http/1.1]}{0.0.0.0:31892} 2017-11-07 13:25:12.843:INFO:osjs.Server:main: Started @4045ms Nov 07, 2017 1:25:13 PM org.openqa.selenium.server.htmlrunner.CoreTestCase run INFO: |open | /auth_mellon.php | | Nov 07, 2017 1:25:14 PM org.openqa.selenium.server.htmlrunner.CoreTestCase run INFO: |waitForPageToLoad | 3000 | | . . .etc \u0026lt;td\u0026gt;result:\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;PASS\u0026lt;/td\u0026gt;"
},
{
	"uri": "https://selenium.dev/documentation/fr/support_packages/working_with_select_elements/",
	"title": "Travailler avec les éléments select",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Select elements can require quite a bit of boiler plate code to automate. To reduce this and make your tests cleaner, there is a Select class in the Selenium support package. To use it, you will need the following import statement:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.support.ui.Select;   from selenium.webdriver.support.select import Select   using OpenQA.Selenium.Support.UI   include Selenium::WebDriver::Support   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    import org.openqa.selenium.support.ui.Select     You are then able to create a Select object using a WebElement that references a \u0026lt;select\u0026gt; element.\nJava Python C# Ruby JavaScript Kotlin WebElement selectElement = driver.findElement(By.id(\u0026#34;selectElementID\u0026#34;)); Select selectObject = new Select(selectElement);   select_element = driver.find_element_by_id(\u0026#39;selectElementID\u0026#39;) select_object = Select(select_element)   IWebElement selectElement = driver.FindElement(By.Id(\u0026#34;selectElementID\u0026#34;)); var selectObject = new SelectElement(selectElement);   select_element = driver.find_element(id: \u0026#39;selectElementID\u0026#39;) select_object = Select(select_element)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    val selectElement = driver.findElement(By.id(\u0026#34;selectElementID\u0026#34;)) val selectObject = new Select(selectElement)     The Select object will now give you a series of commands that allow you to interact with a \u0026lt;select\u0026gt; element. First of all, there are different ways of selecting an option from the \u0026lt;select\u0026gt; element.\n\u0026lt;select\u0026gt; \u0026lt;option value=value1\u0026gt;Bread\u0026lt;/option\u0026gt; \u0026lt;option value=value2 selected\u0026gt;Milk\u0026lt;/option\u0026gt; \u0026lt;option value=value3\u0026gt;Cheese\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; There are three ways to select the first option from the above element:\nJava Python C# Ruby JavaScript Kotlin // Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.selectByIndex(1); // Select an \u0026lt;option\u0026gt; based upon its value attribute selectObject.selectByValue(\u0026#34;value1\u0026#34;); // Select an \u0026lt;option\u0026gt; based upon its text selectObject.selectByVisibleText(\u0026#34;Bread\u0026#34;);   # Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.select_by_index(1) # Select an \u0026lt;option\u0026gt; based upon its value attribute select_object.select_by_value(\u0026#39;value1\u0026#39;) # Select an \u0026lt;option\u0026gt; based upon its text select_object.select_by_visible_text(\u0026#39;Bread\u0026#39;)   // Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.SelectByIndex(1); // Select an \u0026lt;option\u0026gt; based upon its value attribute selectObject.SelectByValue(\u0026#34;value1\u0026#34;); // Select an \u0026lt;option\u0026gt; based upon its text  selectObject.SelectByText(\u0026#34;Bread\u0026#34;);   # Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.select_by(:index, 1) # Select an \u0026lt;option\u0026gt; based upon its value attribute select_object.select_by(:value, \u0026#39;value1\u0026#39;) # Select an \u0026lt;option\u0026gt; based upon its text select_object.select_by(:text, \u0026#39;Bread\u0026#39;)   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    // Select an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.selectByIndex(1) // Select an \u0026lt;option\u0026gt; based upon its value attribute selectObject.selectByValue(\u0026#34;value1\u0026#34;) // Select an \u0026lt;option\u0026gt; based upon its text selectObject.selectByVisibleText(\u0026#34;Bread\u0026#34;)     You can then check which options are selected by using:\nJava Python C# Ruby JavaScript Kotlin // Return a List\u0026lt;WebElement\u0026gt; of options that have been selected List\u0026lt;WebElement\u0026gt; allSelectedOptions = selectObject.getAllSelectedOptions(); // Return a WebElement referencing the first selection option found by walking down the DOM WebElement firstSelectedOption = selectObject.getFirstSelectedOption();   # Return a list[WebElement] of options that have been selected all_selected_options = select_object.all_selected_options # Return a WebElement referencing the first selection option found by walking down the DOM first_selected_option = select_object.first_selected_option   // We don\u0026#39;t have a C# code sample yet - Help us out and raise a PR    # Return an Array[Element] of options that have been selected all_selected_options = select_object.selected_options # Return a WebElement referencing the first selection option found by walking down the DOM first_selected_option = select_object.first_selected_option   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    // Return a List\u0026lt;WebElement\u0026gt; of options that have been selected val allSelectedOptions = selectObject.allSelectedOptions // Return a WebElement referencing the first selection option found by walking down the DOM val firstSelectedOption = selectObject.firstSelectedOption     Or you may just be interested in what \u0026lt;option\u0026gt; elements the \u0026lt;select\u0026gt; element contains:\nJava Python C# Ruby JavaScript Kotlin // Return a List\u0026lt;WebElement\u0026gt; of options that the \u0026lt;select\u0026gt; element contains List\u0026lt;WebElement\u0026gt; allAvailableOptions = selectObject.getOptions();   # Return a list[WebElement] of options that the \u0026amp;lt;select\u0026amp;gt; element contains all_available_options = select_object.options   // Return a IList\u0026lt;IWebElement\u0026gt; of options that the \u0026lt;select\u0026gt; element contains IList\u0026lt;IWebElement\u0026gt; allAvailableOptions = selectObject.Options;   # Return an Array[Element] of options that the \u0026amp;lt;select\u0026amp;gt; element contains all_available_options = select_object.options   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    // Return a List\u0026lt;WebElement\u0026gt; of options that the \u0026lt;select\u0026gt; element contains val allAvailableOptions = selectObject.options     If you want to deselect any elements, you now have four options:\nJava Python C# Ruby JavaScript Kotlin // Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.deselectByIndex(1); // Deselect an \u0026lt;option\u0026gt; based upon its value attribute selectObject.deselectByValue(\u0026#34;value1\u0026#34;); // Deselect an \u0026lt;option\u0026gt; based upon its text selectObject.deselectByVisibleText(\u0026#34;Bread\u0026#34;); // Deselect all selected \u0026lt;option\u0026gt; elements selectObject.deselectAll();   # Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.deselect_by_index(1) # Deselect an \u0026lt;option\u0026gt; based upon its value attribute select_object.deselect_by_value(\u0026#39;value1\u0026#39;) # Deselect an \u0026lt;option\u0026gt; based upon its text select_object.deselect_by_visible_text(\u0026#39;Bread\u0026#39;) # Deselect all selected \u0026lt;option\u0026gt; elements select_object.deselect_all()   // Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.DeselectByIndex(1); // Deselect an \u0026lt;option\u0026gt; based upon its value attribute selectObject.DeselectByValue(\u0026#34;value1\u0026#34;); // Deselect an \u0026lt;option\u0026gt; based upon its text selectObject.DeselectByText(\u0026#34;Bread\u0026#34;); // Deselect all selected \u0026lt;option\u0026gt; elements selectObject.DeselectAll();   # Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index select_object.deselect_by(:index, 1) # Deselect an \u0026lt;option\u0026gt; based upon its value attribute select_object.deselect_by(:value, \u0026#39;value1\u0026#39;) # Deselect an \u0026lt;option\u0026gt; based upon its text select_object.deselect_by(:text, \u0026#39;Bread\u0026#39;) # Deselect all selected \u0026lt;option\u0026gt; elements select_object.deselect_all   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    // Deselect an \u0026lt;option\u0026gt; based upon the \u0026lt;select\u0026gt; element\u0026#39;s internal index selectObject.deselectByIndex(1) // Deselect an \u0026lt;option\u0026gt; based upon its value attribute selectObject.deselectByValue(\u0026#34;value1\u0026#34;) // Deselect an \u0026lt;option\u0026gt; based upon its text selectObject.deselectByVisibleText(\u0026#34;Bread\u0026#34;) // Deselect all selected \u0026lt;option\u0026gt; elements selectObject.deselectAll()     Finally, some \u0026lt;select\u0026gt; elements allow you to select more than one option. You can find out if your \u0026lt;select\u0026gt; element is one of these by using:\nJava Python C# Ruby JavaScript Kotlin Boolean doesThisAllowMultipleSelections = selectObject.isMultiple();   does_this_allow_multiple_selections = select_object.is_multiple   bool doesThisAllowMultipleSelections = selectObject.IsMultiple;   does_this_allow_multiple_selections = select_object.multiple?   // We don\u0026#39;t have a JavaScript code sample yet - Help us out and raise a PR    val doesThisAllowMultipleSelections = selectObject.isMultiple     "
},
{
	"uri": "https://selenium.dev/documentation/fr/introduction/types_of_testing/",
	"title": "Types  de test",
	"tags": [],
	"description": "",
	"content": " Test d\u0026rsquo;acceptation Ce type de test est effectué pour déterminer si un produit fonction correspond à ses besoins. Cela implique généralement les commentaires ou les spécifications du client.\nPour les applications web, l\u0026rsquo;automatisation de ces tests peut se faire directement avec Selenium en simulant le comportement attendu de l\u0026rsquo;utilisateur. Cette simulation peut être effectuée par enregistrement / lecture ou par différentes langues prises en charge comme expliqué dans cette documentation. Remarque: les tests d\u0026rsquo;acceptation sont un sous-type de tests fonctionnels, auquel certaines personnes pourraient également se référer.\nTest fonctionel Ce type de test est effectué pour déterminer si un produit est la fonctionnalité fonctionne bien, sans problèmes.\nCela comprend généralement: les tests fonctionnent sans erreur (404, exceptions \u0026hellip;), de manière utilisable (redirection droite), de manière accessible et correspondant à ses spécifications (voir test d\u0026rsquo;acceptation ci-dessus).\nPour les applications Web, l\u0026rsquo;automatisation de ces tests peut être fait directement avec Selenium en simulant les rendements attendus. Cette simulation peut être effectuée par enregistrement / lecture ou par les différentes langues prises en charge comme expliqué dans cette documentation.\nTest de performance Comme son nom l\u0026rsquo;indique, des tests de performances sont effectués pour mesurer la performance d\u0026rsquo;une application.\nIl existe deux sous-types principaux pour les tests de performances:\nLoad testing Des tests de charge sont effectués pour vérifier la l\u0026rsquo;application fonctionne sous différentes charges définies (généralement un nombre particulier d\u0026rsquo;utilisateurs connectés en même temps)\nTests de résistance Des tests de résistance sont effectués pour vérifier la l\u0026rsquo;application fonctionne sous contrainte (ou au-dessus de la charge maximale supportée).\nEn règle générale, les tests de performances sont effectués en exécutant certains Test écrit de sélénium simulant différents utilisateurs frapper une fonction particulière sur l\u0026rsquo;application Web et récupérer des mesures significatives.\nCela se fait généralement par d\u0026rsquo;autres outils qui récupèrent les métriques. Un tel outil est JMeter.\nPour une application Web, les détails à mesurer incluent débit, latence, perte de données, temps de chargement des composants individuels \u0026hellip;\nRemarque 1: tous les navigateurs ont un onglet de performances dans leur section des outils des développeurs (accessible en appuyant sur F12)\nRemarque 2: est un sous-type de tests non fonctionnels car cela est généralement mesuré par système et non par fonction / caractéristique.\nLes tests de régression Ce test est généralement effectué après un changement, un correctif ou un ajout de fonctionnalité.\nPour s\u0026rsquo;assurer que le changement n\u0026rsquo;a rompu aucun des fonctionnalité, certains tests déjà exécutés sont exécutés à nouveau.\nL\u0026rsquo;ensemble des tests réexécutés peut être complet ou partiel et peut inclure plusieurs types différents, selon sur l\u0026rsquo;équipe d\u0026rsquo;application et de développement.\nDéveloppement piloté par les tests (TDD) Plutôt qu\u0026rsquo;un type de test en soi, le TDD est un itératif méthodologie de développement dans laquelle les tests pilotent la conception d\u0026rsquo;une fonctionnalité.\nChaque cycle commence par la création d\u0026rsquo;un ensemble de tests unitaires qui la fonctionnalité doit réussir (ce qui devrait échouer lors de sa première exécution).\nAprès cela, le développement a lieu pour faire passer les tests. Les tests sont exécutés à nouveau en commençant un autre cycle et ce processus se poursuit jusqu\u0026rsquo;à ce que tous les tests soient réussis.\nCela vise à accélérer le développement d\u0026rsquo;une application basé sur le fait que les défauts sont moins coûteux plus tôt ils sont trouvés.\nDéveloppement axé sur le comportement (BDD) BDD est également une méthodologie de développement itérative basé sur ci-dessus (TDD) dans lequel le but est d\u0026rsquo;impliquer toutes les parties dans le développement d\u0026rsquo;une application.\nChaque cycle commence par la création de quelques spécifications (qui devrait échouer). Créez ensuite l\u0026rsquo;unité défaillante tests (qui devraient également échouer), puis créer le développement.\nCe cycle est répété jusqu\u0026rsquo;à ce que tous les types de tests réussissent.\nPour ce faire, un langage de spécification est utilisé. Il doit être compréhensible par toutes les parties et simple, standard et explicite. La plupart des outils utilisent Gherkin comme langue.\nL\u0026rsquo;objectif est de pouvoir détecter encore plus d\u0026rsquo;erreurs que TDD en ciblant les erreurs d\u0026rsquo;acceptation potentielles aussi et rendre la communication entre les parties plus fluide.\nUn ensemble d\u0026rsquo;outils est actuellement disponible écrire les spécifications et les associer aux fonctions de code, tels que Concombre ou SpecFlow.\nUn ensemble d\u0026rsquo;outils est construit sur Selenium pour rendre ce processus encore plus rapide en transformant directement les spécifications BDD en code exécutable. Certains d\u0026rsquo;entre eux sont JBehave, Capybara et Robot Framework.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/introduction/about_this_documentation/",
	"title": "A propos de cette documentation",
	"tags": [],
	"description": "",
	"content": "Cette documentation, tout comme le code lui-même, est maintenue à 100% par des volontaires de la communauté Selenium. Beaucoup font partie des utilisateurs de la première heure, mais encore plus sont des utilisateurs récents, et ont donné de leur temps pour améliorer l\u0026rsquo;accueil des nouveaux utilisateurs.\nSi vous rencontrez un problème avec la documentation, nous souhaitons le savoir ! La meilleure façon de communiquer un problème est de visiter https://github.com/seleniumhq/seleniumhq.github.io/issues et de vérifier si ce problème a déjà été remonté. Si ce n\u0026rsquo;est pas le cas, n\u0026rsquo;hésitez pas à ouvrir une nouvel issue !\nDe nombreux membre de la communauté fréquentent le canal IRC irc.freenode.net. N\u0026rsquo;hésitez pas à passer et poser vos questions. Si vous recevez de l\u0026rsquo;aide et pensez que cela devrait faire partie de la documentation, votre contribution sera plus que bienvenue ! Nous pouvons mettre à jour cette documentation, mais c\u0026rsquo;est beaucoup plus facile pour tout le monde lorsque nous recevons des contributions venant de nouvelles personnes.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/support_packages/mouse_and_keyboard_actions_in_detail/",
	"title": "Actions de la souris en détail",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Mouse represents a mouse event. Mouse actions are performed by using low-level interface which allows us to provide virtualized device input action to the web browser.\nclickAndHold It will move to the element and clicks (without releasing) in the middle of the given element.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class clickAndHold { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  WebElement searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform click-and-hold action on the element  actionProvider.clickAndHold(searchBtn).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element searchBtn = driver.find_element_by_link_text(\u0026#34;Sign in\u0026#34;) # Perform click-and-hold action on the element webdriver.ActionChains(driver).click_and_hold(searchBtn).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class ClickAndHold { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement searchBtn = driver.FindElement(By.LinkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform click-and-hold action on the element  actionProvider.ClickAndHold(searchBtn).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Sign In\u0026#39; button web element sign_in = driver.find_element(link_text: \u0026#39;Sign in\u0026#39;) # Perform click-and-hold action on the element driver.action.click_and_hold(sign_in).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function clickAndHold() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;google search\u0026#39; button web element  let searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); const actions = driver.actions({async: true}); // Perform mouseMove to element and mouseDown (press) action on the element  await actions.move({origin:searchBtn}).press().perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;google search\u0026#39; button web element  val searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)) val actionProvider = Actions(driver) // Perform click-and-hold action on the element  actionProvider.clickAndHold(searchBtn).build().perform() } finally { driver.quit() } }     contextClick This method firstly performs a mouse-move to the location of the element and performs the context-click (right click) on the given element.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class contextClick { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  WebElement searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform context-click action on the element  actionProvider.contextClick(searchBtn).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element searchBtn = driver.find_element_by_link_text(\u0026#34;Sign in\u0026#34;) # Perform context-click action on the element webdriver.ActionChains(driver).context_click(searchBtn).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class ContextClick { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement searchBtn = driver.FindElement(By.LinkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform context-click action on the element  actionProvider.ContextClick(searchBtn).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Sign In\u0026#39; button web element sign_in = driver.find_element(link_text: \u0026#39;Sign in\u0026#39;) # Perform context-click action on the element driver.action.context_click(sign_in).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function contextClick() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;google search\u0026#39; button web element  let searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); const actions = driver.actions({async: true}); // Perform context-click action on the element  await actions.contextClick(searchBtn).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;google search\u0026#39; button web element  val searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)) val actionProvider = Actions(driver) // Perform context-click action on the element  actionProvider.contextClick(searchBtn).build().perform() } finally { driver.quit() } }     doubleClick It will move to the element and performs a double-click in the middle of the given element.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class doubleClick { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  WebElement searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform double-click action on the element  actionProvider.doubleClick(searchBtn).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element searchBtn = driver.find_element_by_link_text(\u0026#34;Sign in\u0026#34;) # Perform double-click action on the element webdriver.ActionChains(driver).double_click(searchBtn).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class DoubleClick { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement searchBtn = driver.FindElement(By.LinkText(\u0026#34;Sign in\u0026#34;)); Actions actionProvider = new Actions(driver); // Perform double-click action on the element  actionProvider.DoubleClick(searchBtn).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Sign In\u0026#39; button web element sign_in = driver.find_element(link_text: \u0026#39;Sign in\u0026#39;) # Perform double-click action on the element driver.action.double_click(sign_in).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function doubleClick() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;google search\u0026#39; button web element  let searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)); const actions = driver.actions({async: true}); // Perform double-click action on the element  await actions.doubleClick(searchBtn).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;google search\u0026#39; button web element  val searchBtn = driver.findElement(By.linkText(\u0026#34;Sign in\u0026#34;)) val actionProvider = Actions(driver) // Perform double-click action on the element  actionProvider.doubleClick(searchBtn).build().perform() } finally { driver.quit() } }     moveToElement This method moves the mouse to the middle of the element. The element is also scrolled into the view on performing this action.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class moveToElement { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;Gmail\u0026#39; anchor web element  WebElement gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); Actions actionProvider = new Actions(driver); // Performs mouse move action onto the element  actionProvider.moveToElement(gmailLink).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element gmailLink = driver.find_element_by_link_text(\u0026#34;Gmail\u0026#34;) # Performs mouse move action onto the element webdriver.ActionChains(driver).move_to_element(gmailLink).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class MoveToElement { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement gmailLink = driver.FindElement(By.LinkText(\u0026#34;Gmail\u0026#34;)); Actions actionProvider = new Actions(driver); // Performs mouse move action onto the element  actionProvider.MoveToElement(gmailLink).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Gmail\u0026#39; anchor web element gmail_link = driver.find_element(link_text: \u0026#39;Gmail\u0026#39;) # Performs mouse move action onto the element driver.action.move_to(gmail_link).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function moveToElement() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;Gmail\u0026#39; anchor web element  let gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); const actions = driver.actions({async: true}); // Performs mouse move action onto the element  await actions.move({origin:gmailLink}).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;Gmail\u0026#39; anchor web element  val gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)) val actionProvider = Actions(driver) // Performs mouse move action onto the element  actionProvider.moveToElement(gmailLink).build().perform() } finally { driver.quit() } }     moveByOffset: This method moves the mouse from its current position (or 0,0) by the given offset. If the coordinates are outside the view window, then the mouse will end up outside the browser window.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class moveByOffset { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;Gmail\u0026#39; anchor web element  WebElement gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); // Capture x and y offset positions of element  int xOffset = gmailLink.getRect().getX(); int yOffset = gmailLink.getRect().getY(); Actions actionProvider = new Actions(driver); // Performs mouse move action onto the offset position  actionProvider.moveByOffset(xOffset, yOffset).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.google.com\u0026#34;) # Store \u0026#39;google search\u0026#39; button web element gmailLink = driver.find_element_by_link_text(\u0026#34;Gmail\u0026#34;) #Set x and y offset positions of element xOffset = 100 yOffset = 100 # Performs mouse move action onto the element webdriver.ActionChains(driver).move_by_offset(xOffset,yOffset).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class MoveByOffset { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;); // Store \u0026#39;google search\u0026#39; button web element  IWebElement gmailLink = driver.FindElement(By.LinkText(\u0026#34;Gmail\u0026#34;)); // Set x and y offset positions of element  int xOffset = 100; int yOffset = 100; Actions actionProvider = new Actions(driver); // Performs mouse move action onto the offset position  actionProvider.MoveByOffset(xOffset, yOffset).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://www.google.com\u0026#39; # Store \u0026#39;Gmail\u0026#39; anchor web element gmail_link = driver.find_element(link_text: \u0026#39;Gmail\u0026#39;) # Capture x and y offset positions of element x_offset = gmail_link.rect.x y_offset = gmail_link.rect.y # Performs mouse move action onto the offset position driver.action.move_to_location(x_offset, y_offset).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function moveByOffset() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Store \u0026#39;Gmail\u0026#39; anchor web element  let gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)); // Capture offset positions of element  let offset = await gmailLink.getRect(); let x = await offset.x; let y = await offset.y; const actions = driver.actions({async: true}); // Performs mouse move action onto the element  await actions.move({x:parseInt(x),y:parseInt(y)}).pause(3000).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;) // Store \u0026#39;Gmail\u0026#39; anchor web element  val gmailLink = driver.findElement(By.linkText(\u0026#34;Gmail\u0026#34;)) // Capture x and y offset positions of element  val xOffset = gmailLink.rect.getX() val yOffset = gmailLink.rect.getY() val actionProvider = Actions(driver) // Performs mouse move action onto the element  actionProvider.moveByOffset(xOffset, yOffset).build().perform() } finally { driver.quit() } }     dragAndDrop This method firstly performs a click-and-hold on the source element, moves to the location of the target element and then releases the mouse.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class dragAndDrop { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  WebElement sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  WebElement targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); // Performs drag and drop action of sourceEle onto the targetEle  actionProvider.dragAndDrop(sourceEle, targetEle).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) # Store \u0026#39;box A\u0026#39; as source element sourceEle = driver.find_element_by_id(\u0026#34;draggable\u0026#34;) # Store \u0026#39;box B\u0026#39; as source element targetEle = driver.find_element_by_id(\u0026#34;droppable\u0026#34;) # Performs drag and drop action of sourceEle onto the targetEle webdriver.ActionChains(driver).drag_and_drop(sourceEle,targetEle).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class DragAndDrop { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  IWebElement sourceEle = driver.FindElement(By.Id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  IWebElement targetEle = driver.FindElement(By.Id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); // Performs drag and drop action of sourceEle onto the targetEle  actionProvider.DragAndDrop(sourceEle, targetEle).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39; # Store \u0026#39;box A\u0026#39; as source element source_ele = driver.find_element(id: \u0026#39;draggable\u0026#39;) # Store \u0026#39;box B\u0026#39; as source element target_ele = driver.find_element(id: \u0026#39;droppable\u0026#39;) # Performs drag and drop action of sourceEle onto the targetEle driver.action.drag_and_drop(source_ele, target_ele).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function dragAndDrop() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39;); // Store \u0026#39;box A\u0026#39; as source element  let sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  let targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); const actions = driver.actions({async: true}); // Performs drag and drop action of sourceEle onto the targetEle  await actions.dragAndDrop(sourceEle, targetEle).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) // Store \u0026#39;box A\u0026#39; as source element  val sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)) // Store \u0026#39;box B\u0026#39; as source element  val targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)) val actionProvider = Actions(driver) // Performs drag and drop action of sourceEle onto the targetEle  actionProvider.dragAndDrop(sourceEle, targetEle).build().perform() } finally { driver.quit() } }     dragAndDropBy This method firstly performs a click-and-hold on the source element, moves to the given offset and then releases the mouse.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class dragAndDropBy { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  WebElement sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  WebElement targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); int targetEleXOffset = targetEle.getLocation().getX(); int targetEleYOffset = targetEle.getLocation().getY(); Actions actionProvider = new Actions(driver); // Performs dragAndDropBy onto the target element offset position  actionProvider.dragAndDropBy(sourceEle, targetEleXOffset, targetEleYOffset).build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) # Store \u0026#39;box A\u0026#39; as source element sourceEle = driver.find_element_by_id(\u0026#34;draggable\u0026#34;) # Store \u0026#39;box B\u0026#39; as source element targetEle = driver.find_element_by_id(\u0026#34;droppable\u0026#34;) targetEleXOffset = targetEle.location.get(\u0026#34;x\u0026#34;) targetEleYOffset = targetEle.location.get(\u0026#34;y\u0026#34;) # Performs dragAndDropBy onto the target element offset position webdriver.ActionChains(driver).drag_and_drop_by_offset(sourceEle, targetEleXOffset, targetEleYOffset).perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class DragAndDropToOffset { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  IWebElement sourceEle = driver.FindElement(By.Id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  IWebElement targetEle = driver.FindElement(By.Id(\u0026#34;droppable\u0026#34;)); int targetEleXOffset = targetEle.Location.X; int targetEleYOffset = targetEle.Location.Y; Actions actionProvider = new Actions(driver); // Performs drag and drop action of sourceEle onto the targetEle  actionProvider.DragAndDropToOffset(sourceEle, targetEleXOffset, targetEleYOffset).Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39; # Store \u0026#39;box A\u0026#39; as source element source_ele = driver.find_element(id: \u0026#39;draggable\u0026#39;) target_ele = driver.find_element(id: \u0026#39;droppable\u0026#39;) # Capture x and y offset positions of element x_offset = target_ele.rect.x y_offset = target_ele.rect.y # Performs dragAndDropBy onto the target element offset position driver.action.drag_and_drop_by(source_ele, x_offset, y_offset).perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function dragAndDropBy() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39;); // Store \u0026#39;box A\u0026#39; as source element  let sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  let targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); let offset = await targetEle.getRect(); let x = await offset.x; let y = await offset.y; const actions = driver.actions({async: true}); // Performs dragAndDropBy onto the target element offset position  await actions.dragAndDrop(sourceEle, {x:parseInt(x), y:parseInt(y)}).perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) // Store \u0026#39;box A\u0026#39; as source element  val sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)) // Store \u0026#39;box B\u0026#39; as source element  val targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)) val targetEleXOffset = targetEle.location.getX() val targetEleYOffset = targetEle.location.getY() val actionProvider = Actions(driver) // Performs dragAndDropBy onto the target element offset position  actionProvider.dragAndDropBy(sourceEle, targetEleXOffset, targetEleYOffset).build().perform() } finally { driver.quit() } }     release This action releases the depressed left mouse button. If WebElement is passed, it will release depressed left mouse button on the given WebElement\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.openqa.selenium.interactions.Actions; public class release { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  WebElement sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  WebElement targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); actionProvider.clickAndHold(sourceEle).moveToElement(targetEle).build().perform(); // Performs release event  actionProvider.release().build().perform(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) # Store \u0026#39;box A\u0026#39; as source element sourceEle = driver.find_element_by_id(\u0026#34;draggable\u0026#34;) # Store \u0026#39;box B\u0026#39; as source element targetEle = driver.find_element_by_id(\u0026#34;droppable\u0026#34;) # Performs dragAndDropBy onto the target element offset position webdriver.ActionChains(driver).click_and_hold(sourceEle).move_to_element(targetEle).perform() #Performs release event webdriver.ActionChains(driver).release().perform()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using OpenQA.Selenium.Interactions; namespace SeleniumApp { public class Release { public static void Main(string[] agrs) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;); // Store \u0026#39;box A\u0026#39; as source element  IWebElement sourceEle = driver.FindElement(By.Id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  IWebElement targetEle = driver.FindElement(By.Id(\u0026#34;droppable\u0026#34;)); Actions actionProvider = new Actions(driver); actionProvider.ClickAndHold(sourceEle).MoveToElement(targetEle).Build().Perform(); // Performs release event  actionProvider.Release().Build().Perform(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to Url driver.get \u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39; source_ele = driver.find_element(id: \u0026#39;draggable\u0026#39;) target_ele = driver.find_element(id: \u0026#39;droppable\u0026#39;) driver.action.click_and_hold(source_ele).move_to(target_ele).perform # Performs release event driver.action.release.perform ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function release() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://crossbrowsertesting.github.io/drag-and-drop\u0026#39;); // Store \u0026#39;box A\u0026#39; as source element  let sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)); // Store \u0026#39;box B\u0026#39; as source element  let targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)); const actions = driver.actions({async: true}); await actions.move({origin:sourceEle}).press().perform(); // Performs release event on target element  await actions.move({origin:targetEle}).release().perform(); } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.interactions.Actions fun main() { val driver = ChromeDriver() try { // Navigate to Url  driver.get(\u0026#34;https://crossbrowsertesting.github.io/drag-and-drop\u0026#34;) // Store \u0026#39;box A\u0026#39; as source element  val sourceEle = driver.findElement(By.id(\u0026#34;draggable\u0026#34;)) // Store \u0026#39;box B\u0026#39; as source element  val targetEle = driver.findElement(By.id(\u0026#34;droppable\u0026#34;)) val actionProvider = Actions(driver) actionProvider.clickAndHold(sourceEle).moveToElement(targetEle).build().perform() // Performs release event  actionProvider.release().build().perform() } finally { driver.quit() } }     "
},
{
	"uri": "https://selenium.dev/documentation/fr/guidelines_and_recommendations/mock_external_services/",
	"title": "Bouchonner les appels externes",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Eliminating the dependencies on external services will greatly improve the speed and stability of your tests.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/getting_started_with_webdriver/",
	"title": "Débuter avec WebDriver",
	"tags": [],
	"description": "",
	"content": " Débuter avec WebDriver Selenium permet l\u0026rsquo;automatisation des navigateurs les plus courants du marché à travers l\u0026rsquo;utilisation de WebDriver. WebDriver est une API et un protocole définissant une interface agnostique (non orientée vers un langage spécifique) permettant de controller le comportement des navigateurs web. Chaque navigateur est appuyé par une implémentation spécifique de WebDriver, appelée un driver. Ce driver est le composant responsable de la délégation vers le navigateur, et gère la communication entre Selenium et le navigateur.\nCette séparation fait partie d\u0026rsquo;un effor conscient afin de responsabiliser les fournisseurs de navigateurs quant à l\u0026rsquo;implémentation de ceux-ci. Selenium tire parti de drivers tierces lorsque c\u0026rsquo;est possible, mais fournit également ces propres drivers, maintenus par le projet, lorsque nécessaire.\nLe framework Selenium relie toutes ces pièces ensemnle via une interface user-friendly qui permet d\u0026rsquo;utiliser différents navigateurs de manière transparente, permettant ainsi l\u0026rsquo;automatisation cross-platform et cross-browser.\nPlus de détail à propos des driver peut être trouvé au chapitre Singularités du Driver.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/worst_practices/gmail_email_and_facebook_logins/",
	"title": "Gmail, email and logins Facebook",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n For multiple reasons, logging into sites like Gmail and Facebook using WebDriver is not recommended. Aside from being against the usage terms for these sites (where you risk having the account shut down), it is slow and unreliable.\nThe ideal practice is to use the APIs that email providers offer, or in the case of Facebook the developer tools service which exposes an API for creating test accounts, friends and so forth. Although using an API might seem like a bit of extra hard work, you will be paid back in speed, reliability, and stability. The API is also unlikely to change whereas webpages and HTML locators change often and require you to update your test framework.\nLogging in to third party sites using WebDriver at any point of your test increases the risk of your test failing because it makes your test longer. A general rule of thumb is that longer tests are more fragile and unreliable.\nWebDriver implementations that are W3C conformant also annotate the navigator object with a webdriver property so that Denial of Service attacks can be mitigated.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/legacy_docs/selenium_ide/",
	"title": "Legacy Selenium IDE",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Introduction The Selenium-IDE (Integrated Development Environment) is the tool you use to develop your Selenium test cases. It’s an easy-to-use Firefox plug-in and is generally the most efficient way to develop test cases. It also contains a context menu that allows you to first select a UI element from the browser’s currently displayed page and then select from a list of Selenium commands with parameters pre-defined according to the context of the selected UI element. This is not only a time-saver, but also an excellent way of learning Selenium script syntax.\nThis chapter is all about the Selenium IDE and how to use it effectively.\nInstalling the IDE Using Firefox, first, download the IDE from the SeleniumHQ downloads page\nFirefox will protect you from installing addons from unfamiliar locations, so you will need to click ‘Allow’ to proceed with the installation, as shown in the following screenshot.\nWhen downloading from Firefox, you’ll be presented with the following window.\nSelect Install Now. The Firefox Add-ons window pops up, first showing a progress bar, and when the download is complete, displays the following.\nRestart Firefox. After Firefox reboots you will find the Selenium-IDE listed under the Firefox Tools menu.\nOpening the IDE To run the Selenium-IDE, simply select it from the Firefox Tools menu. It opens as follows with an empty script-editing window and a menu for loading, or creating new test cases.\nIDE Features Menu Bar The File menu has options for Test Case and Test Suite (suite of Test Cases). Using these you can add a new Test Case, open a Test Case, save a Test Case, export Test Case in a language of your choice. You can also open the recent Test Case. All these options are also available for Test Suite.\nThe Edit menu allows copy, paste, delete, undo, and select all operations for editing the commands in your test case. The Options menu allows the changing of settings. You can set the timeout value for certain commands, add user-defined user extensions to the base set of Selenium commands, and specify the format (language) used when saving your test cases. The Help menu is the standard Firefox Help menu; only one item on this menu–UI-Element Documentation–pertains to Selenium-IDE.\nToolbar The toolbar contains buttons for controlling the execution of your test cases, including a step feature for debugging your test cases. The right-most button, the one with the red-dot, is the record button.\nSpeed Control: controls how fast your test case runs.\nRun All: Runs the entire test suite when a test suite with multiple test cases is loaded.\nRun: Runs the currently selected test. When only a single test is loaded this button and the Run All button have the same effect.\nPause/Resume: Allows stopping and re-starting of a running test case.\nStep: Allows you to “step” through a test case by running it one command at a time. Use for debugging test cases.\nTestRunner Mode: Allows you to run the test case in a browser loaded with the Selenium-Core TestRunner. The TestRunner is not commonly used now and is likely to be deprecated. This button is for evaluating test cases for backwards compatibility with the TestRunner. Most users will probably not need this button.\nApply Rollup Rules: This advanced feature allows repetitive sequences of Selenium commands to be grouped into a single action. Detailed documentation on rollup rules can be found in the UI-Element Documentation on the Help menu.\nTest Case Pane Your script is displayed in the test case pane. It has two tabs, one for displaying the command and their parameters in a readable “table” format.\nThe other tab - Source displays the test case in the native format in which the file will be stored. By default, this is HTML although it can be changed to a programming language such as Java or C#, or a scripting language like Python. See the Options menu for details. The Source view also allows one to edit the test case in its raw form, including copy, cut and paste operations.\nThe Command, Target, and Value entry fields display the currently selected command along with its parameters. These are entry fields where you can modify the currently selected command. The first parameter specified for a command in the Reference tab of the bottom pane always goes in the Target field. If a second parameter is specified by the Reference tab, it always goes in the Value field.\nIf you start typing in the Command field, a drop-down list will be populated based on the first characters you type; you can then select your desired command from the drop-down.\nLog/Reference/UI-Element/Rollup Pane The bottom pane is used for four different functions–Log, Reference, UI-Element, and Rollup–depending on which tab is selected.\nLog When you run your test case, error messages and information messages showing the progress are displayed in this pane automatically, even if you do not first select the Log tab. These messages are often useful for test case debugging. Notice the Clear button for clearing the Log. Also notice the Info button is a drop-down allowing selection of different levels of information to log.\nReference The Reference tab is the default selection whenever you are entering or modifying Selenese commands and parameters in Table mode. In Table mode, the Reference pane will display documentation on the current command. When entering or modifying commands, whether from Table or Source mode, it is critically important to ensure that the parameters specified in the Target and Value fields match those specified in the parameter list in the Reference pane. The number of parameters provided must match the number specified, the order of parameters provided must match the order specified, and the type of parameters provided must match the type specified. If there is a mismatch in any of these three areas, the command will not run correctly.\nWhile the Reference tab is invaluable as a quick reference, it is still often necessary to consult the Selenium Reference document.\nUI-Element and Rollup Detailed information on these two panes (which cover advanced features) can be found in the UI-Element Documentation on the Help menu of Selenium-IDE.\nBuilding Test Cases There are three primary methods for developing test cases. Frequently, a test developer will require all three techniques.\nRecording Many first-time users begin by recording a test case from their interactions with a website. When Selenium-IDE is first opened, the record button is ON by default. If you do not want Selenium-IDE to begin recording automatically you can turn this off by going under Options \u0026gt; Options… and deselecting “Start recording immediately on open.”\nDuring recording, Selenium-IDE will automatically insert commands into your test case based on your actions. Typically, this will include:\n clicking a link - click or clickAndWait commands entering values - type command selecting options from a drop-down listbox - select command clicking checkboxes or radio buttons - click command  Here are some “gotchas” to be aware of:\n The type command may require clicking on some other area of the web page for it to record. Following a link usually records a click command. You will often need to change this to clickAndWait to ensure your test case pauses until the new page is completely loaded. Otherwise, your test case will continue running commands before the page has loaded all its UI elements. This will cause unexpected test case failures.  Adding Verifications and Asserts With the Context Menu Your test cases will also need to check the properties of a web-page. This requires assert and verify commands. We won’t describe the specifics of these commands here; that is in the chapter on Selenium Commands – “Selenese”. Here we’ll simply describe how to add them to your test case.\nWith Selenium-IDE recording, go to the browser displaying your test application and right click anywhere on the page. You will see a context menu showing verify and/or assert commands.\nThe first time you use Selenium, there may only be one Selenium command listed. As you use the IDE however, you will find additional commands will quickly be added to this menu. Selenium-IDE will attempt to predict what command, along with the parameters, you will need for a selected UI element on the current web-page.\nLet’s see how this works. Open a web-page of your choosing and select a block of text on the page. A paragraph or a heading will work fine. Now, right-click the selected text. The context menu should give you a verifyTextPresent command and the suggested parameter should be the text itself.\nAlso, notice the Show All Available Commands menu option. This shows many, many more commands, again, along with suggested parameters, for testing your currently selected UI element.\nTry a few more UI elements. Try right-clicking an image, or a user control like a button or a checkbox. You may need to use Show All Available Commands to see options other than verifyTextPresent. Once you select these other options, the more commonly used ones will show up on the primary context menu. For example, selecting verifyElementPresent for an image should later cause that command to be available on the primary context menu the next time you select an image and right-click.\nAgain, these commands will be explained in detail in the chapter on Selenium commands. For now though, feel free to use the IDE to record and select commands into a test case and then run it. You can learn a lot about the Selenium commands simply by experimenting with the IDE.\nEditing Insert Command Table View Select the point in your test case where you want to insert the command. To do this, in the Test Case Pane, left-click on the line where you want to insert a new command. Right-click and select Insert Command; the IDE will add a blank line just ahead of the line you selected. Now use the command editing text fields to enter your new command and its parameters.\nSource View Select the point in your test case where you want to insert the command. To do this, in the Test Case Pane, left-click between the commands where you want to insert a new command, and enter the HTML tags needed to create a 3-column row containing the Command, first parameter (if one is required by the Command), and second parameter (again, if one is required to locate an element) and third parameter(again, if one is required to have a value). Example:\n\u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Command\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;target (locator)\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Value\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; Insert Comment Comments may be added to make your test case more readable. These comments are ignored when the test case is run.\nComments may also be used to add vertical white space (one or more blank lines) in your tests; just create empty comments. An empty command will cause an error during execution; an empty comment won’t.\nTable View Select the line in your test case where you want to insert the comment. Right-click and select Insert Comment. Now use the Command field to enter the comment. Your comment will appear in purple text.\nSource View Select the point in your test case where you want to insert the comment. Add an HTML-style comment, i.e., \u0026lt;!-- your comment here --\u0026gt;.\nEdit a Command or Comment Table View Simply select the line to be changed and edit it using the Command, Target, and Value fields.\nSource View Since Source view provides the equivalent of a WYSIWYG (What You See is What You Get) editor, simply modify which line you wish–command, parameter, or comment.\nOpening and Saving a Test Case Like most programs, there are Save and Open commands under the File menu. However, Selenium distinguishes between test cases and test suites. To save your Selenium-IDE tests for later use you can either save the individual test cases, or save the test suite. If the test cases of your test suite have not been saved, you’ll be prompted to save them before saving the test suite.\nWhen you open an existing test case or suite, Selenium-IDE displays its Selenium commands in the Test Case Pane.\nRunning Test Cases The IDE allows many options for running your test case. You can run a test case all at once, stop and start it, run it one line at a time, run a single command you are currently developing, and you can do a batch run of an entire test suite. Execution of test cases is very flexible in the IDE.\nRun a Test Case\nClick the Run button to run the currently displayed test case.\nRun a Test Suite\nClick the Run All button to run all the test cases in the currently loaded test suite.\nStop and Start\nThe Pause button can be used to stop the test case while it is running. The icon of this button then changes to indicate the Resume button. To continue click Resume.\nStop in the Middle\nYou can set a breakpoint in the test case to cause it to stop on a particular command. This is useful for debugging your test case. To set a breakpoint, select a command, right-click, and from the context menu select Toggle Breakpoint.\nStart from the Middle\nYou can tell the IDE to begin running from a specific command in the middle of the test case. This also is used for debugging. To set a startpoint, select a command, right-click, and from the context menu select Set/Clear Start Point.\nRun Any Single Command\nDouble-click any single command to run it by itself. This is useful when writing a single command. It lets you immediately test a command you are constructing, when you are not sure if it is correct. You can double-click it to see if it runs correctly. This is also available from the context menu.\nUsing Base URL to Run Test Cases in Different Domains The Base URL field at the top of the Selenium-IDE window is very useful for allowing test cases to be run across different domains. Suppose that a site named http://news.portal.com had an in-house beta site named http://beta.news.portal.com. Any test cases for these sites that begin with an open statement should specify a relative URL as the argument to open rather than an absolute URL (one starting with a protocol such as http: or https:). Selenium-IDE will then create an absolute URL by appending the open command’s argument onto the end of the value of Base URL. For example, the test case below would be run against http://news.portal.com/about.html:\nThis same test case with a modified Base URL setting would be run against http://beta.news.portal.com/about.html:\nSelenium Commands – “Selenese” Selenium commands, often called selenese, are the set of commands that run your tests. A sequence of these commands is a test script. Here we explain those commands in detail, and we present the many choices you have in testing your web application when using Selenium.\nSelenium provides a rich set of commands for fully testing your web-app in virtually any way you can imagine. The command set is often called selenese. These commands essentially create a testing language.\nIn selenese, one can test the existence of UI elements based on their HTML tags, test for specific content, test for broken links, input fields, selection list options, submitting forms, and table data among other things. In addition Selenium commands support testing of window size, mouse position, alerts, Ajax functionality, pop up windows, event handling, and many other web-application features. The Command Reference lists all the available commands.\nA command tells Selenium what to do. Selenium commands come in three “flavors”: Actions, Accessors, and Assertions.\n Actions are commands that generally manipulate the state of the application. They do things like “click this link” and “select that option”. If an Action fails, or has an error, the execution of the current test is stopped.\nMany Actions can be called with the “AndWait” suffix, e.g. “clickAndWait”. This suffix tells Selenium that the action will cause the browser to make a call to the server, and that Selenium should wait for a new page to load.\n Accessors examine the state of the application and store the results in variables, e.g. “storeTitle”. They are also used to automatically generate Assertions.\n Assertions are like Accessors, but they verify that the state of the application conforms to what is expected. Examples include “make sure the page title is X” and “verify that this checkbox is checked”.\n  All Selenium Assertions can be used in 3 modes: “assert”, “verify”, and ” waitFor”. For example, you can “assertText”, “verifyText” and “waitForText”. When an “assert” fails, the test is aborted. When a “verify” fails, the test will continue execution, logging the failure. This allows a single “assert” to ensure that the application is on the correct page, followed by a bunch of “verify” assertions to test form field values, labels, etc.\n“waitFor” commands wait for some condition to become true (which can be useful for testing Ajax applications). They will succeed immediately if the condition is already true. However, they will fail and halt the test if the condition does not become true within the current timeout setting (see the setTimeout action below).\nScript Syntax Selenium commands are simple, they consist of the command and two parameters. For example:\n          verifyText //div//a[2] Login    The parameters are not always required; it depends on the command. In some cases both are required, in others one parameter is required, and in still others the command may take no parameters at all. Here are a couple more examples:\n          goBackAndWait     verifyTextPresent  Welcome to My Home Page   type id=phone (555) 666-7066   type id=address1 ${myVariableAddress}    The command reference describes the parameter requirements for each command.\nParameters vary, however they are typically:\n a locator for identifying a UI element within a page. a text pattern for verifying or asserting expected page content a text pattern or a selenium variable for entering text in an input field or for selecting an option from an option list.  Locators, text patterns, selenium variables, and the commands themselves are described in considerable detail in the section on Selenium Commands.\nSelenium scripts that will be run from Selenium-IDE will be stored in an HTML text file format. This consists of an HTML table with three columns. The first column identifies the Selenium command, the second is a target, and the final column contains a value. The second and third columns may not require values depending on the chosen Selenium command, but they should be present. Each table row represents a new Selenium command. Here is an example of a test that opens a page, asserts the page title and then verifies some content on the page:\n\u0026lt;table\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;/download/\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;assertTitle\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;Downloads\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;verifyText\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;//h2\u0026lt;/td\u0026gt;\u0026lt;td\u0026gt;Downloads\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; Rendered as a table in a browser this would look like the following:\n          open /download/    assertTitle  Downloads   verifyText //h2 Downloads    The Selenese HTML syntax can be used to write and run tests without requiring knowledge of a programming language. With a basic knowledge of selenese and Selenium-IDE you can quickly produce and run testcases.\nTest Suites A test suite is a collection of tests. Often one will run all the tests in a test suite as one continuous batch-job.\nWhen using Selenium-IDE, test suites also can be defined using a simple HTML file. The syntax again is simple. An HTML table defines a list of tests where each row defines the filesystem path to each test. An example tells it all.\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Test Suite Function Tests - Priority 1\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;b\u0026gt;Suite Of Tests\u0026lt;/b\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./Login.html\u0026#34;\u0026gt;Login\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./SearchValues.html\u0026#34;\u0026gt;Test Searching for Values\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./SaveValues.html\u0026#34;\u0026gt;Test Save\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; A file similar to this would allow running the tests all at once, one after another, from the Selenium-IDE.\nTest suites can also be maintained when using Selenium-RC. This is done via programming and can be done a number of ways. Commonly Junit is used to maintain a test suite if one is using Selenium-RC with Java. Additionally, if C# is the chosen language, Nunit could be employed. If using an interpreted language like Python with Selenium-RC then some simple programming would be involved in setting up a test suite. Since the whole reason for using Selenium-RC is to make use of programming logic for your testing this usually isn’t a problem.\nCommonly Used Selenium Commands To conclude our introduction of Selenium, we’ll show you a few typical Selenium commands. These are probably the most commonly used commands for building tests.\nopen\nopens a page using a URL.\nclick/clickAndWait\nperforms a click operation, and optionally waits for a new page to load.\nverifyTitle/assertTitle\nverifies an expected page title.\nverifyTextPresent\nverifies expected text is somewhere on the page.\nverifyElementPresent\nverifies an expected UI element, as defined by its HTML tag, is present on the page.\nverifyText\nverifies expected text and its corresponding HTML tag are present on the page.\nverifyTable\nverifies a table’s expected contents.\nwaitForPageToLoad\npauses execution until an expected new page loads. Called automatically when clickAndWait is used.\nwaitForElementPresent\npauses execution until an expected UI element, as defined by its HTML tag, is present on the page.\nVerifying Page Elements Verifying UI elements on a web page is probably the most common feature of your automated tests. Selenese allows multiple ways of checking for UI elements. It is important that you understand these different methods because these methods define what you are actually testing.\nFor example, will you test that…\n an element is present somewhere on the page? specific text is somewhere on the page? specific text is at a specific location on the page?  For example, if you are testing a text heading, the text and its position at the top of the page are probably relevant for your test. If, however, you are testing for the existence of an image on the home page, and the web designers frequently change the specific image file along with its position on the page, then you only want to test that an image (as opposed to the specific image file) exists somewhere on the page.\nAssertion or Verification? Choosing between “assert” and “verify” comes down to convenience and management of failures. There’s very little point checking that the first paragraph on the page is the correct one if your test has already failed when checking that the browser is displaying the expected page. If you’re not on the correct page, you’ll probably want to abort your test case so that you can investigate the cause and fix the issue(s) promptly. On the other hand, you may want to check many attributes of a page without aborting the test case on the first failure as this will allow you to review all failures on the page and take the appropriate action. Effectively an “assert” will fail the test and abort the current test case, whereas a “verify” will fail the test and continue to run the test case.\nThe best use of this feature is to logically group your test commands, and start each group with an “assert” followed by one or more “verify” test commands. An example follows:\n   Command Target Value     open /download/    assertTitle  Downloads   verifyText //h2 Downloads   assertTable 1.2.1 Selenium IDE   verifyTable 1.2.2 June 3, 2008   verifyTable 1.2.3 1.0 beta 2    The above example first opens a page and then “asserts” that the correct page is loaded by comparing the title with the expected value. Only if this passes will the following command run and “verify” that the text is present in the expected location. The test case then “asserts” the first column in the second row of the first table contains the expected value, and only if this passed will the remaining cells in that row be “verified”.\nverifyTextPresent The command verifyTextPresent is used to verify specific text exists somewhere on the page. It takes a single argument–the text pattern to be verified. For example:\n   Command Target Value     verifyTextPresent Marketing Analysis     This would cause Selenium to search for, and verify, that the text string “Marketing Analysis” appears somewhere on the page currently being tested. Use verifyTextPresent when you are interested in only the text itself being present on the page. Do not use this when you also need to test where the text occurs on the page.\nverifyElementPresent Use this command when you must test for the presence of a specific UI element, rather than its content. This verification does not check the text, only the HTML tag. One common use is to check for the presence of an image.\n   Command Target Value     verifyElementPresent //div/p/img     This command verifies that an image, specified by the existence of an  HTML tag, is present on the page, and that it follows a  tag and a  tag. The first (and only) parameter is a locator for telling the Selenese command how to find the element. Locators are explained in the next section.\nverifyElementPresent can be used to check the existence of any HTML tag within the page. You can check the existence of links, paragraphs, divisions , etc. Here are a few more examples.\n   Command Target Value     verifyElementPresent //div/p    verifyElementPresent //div/a    verifyElementPresent id=Login    verifyElementPresent link=Go to Marketing Research    verifyElementPresent //a[2]    verifyElementPresent //head/title     These examples illustrate the variety of ways a UI element may be tested. Again, locators are explained in the next section.\nverifyText Use verifyText when both the text and its UI element must be tested. verifyText must use a locator. If you choose an XPath or DOM locator, you can verify that specific text appears at a specific location on the page relative to other UI components on the page.\n   Command Target Value     verifyText //table/tr/td/div/p This is my text and it occurs right after the div inside the table.    Locating Elements For many Selenium commands, a target is required. This target identifies an element in the content of the web application, and consists of the location strategy followed by the location in the format locatorType=location. The locator type can be omitted in many cases. The various locator types are explained below with examples for each.\nLocating by Identifier This is probably the most common method of locating elements and is the catch-all default when no recognized locator type is used. With this strategy, the first element with the id attribute value matching the location will be used. If no element has a matching id attribute, then the first element with a name attribute matching the location will be used.\nFor instance, your page source could have id and name attributes as follows:\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt; The following locator strategies would return the elements from the HTML snippet above indicated by line number:\n identifier=loginForm (3) identifier=password (5) identifier=continue (6) continue (6)  Since the identifier type of locator is the default, the identifier= in the first three examples above is not necessary.\nLocating by Id This type of locator is more limited than the identifier locator type, but also more explicit. Use this when you know an element\u0026rsquo;s id attribute.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  id=loginForm (3)  Locating by Name The name locator type will locate the first element with a matching name attribute. If multiple elements have the same value for a name attribute, then you can use filters to further refine your location strategy. The default filter type is value (matching the value attribute).\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  name=username (4) name=continue value=Clear (7) name=continue Clear (7) name=continue type=button (7)  Note: Unlike some types of XPath and DOM locators, the three types of locators above allow Selenium to test a UI element independent of its location on the page. So if the page structure and organization is altered, the test will still pass. You may or may not want to also test whether the page structure changes. In the case where web designers frequently alter the page, but its functionality must be regression tested, testing via id and name attributes, or really via any HTML property, becomes very important.\nLocating by XPath XPath is the language used for locating nodes in an XML document. As HTML can be an implementation of XML (XHTML), Selenium users can leverage this powerful language to target elements in their web applications. XPath extends beyond (as well as supporting) the simple methods of locating by id or name attributes, and opens up all sorts of new possibilities such as locating the third checkbox on the page.\nOne of the main reasons for using XPath is when you don\u0026rsquo;t have a suitable id or name attribute for the element you wish to locate. You can use XPath to either locate the element in absolute terms (not advised), or relative to an element that does have an id or name attribute. XPath locators can also be used to specify elements via attributes other than id and name.\nAbsolute XPaths contain the location of all elements from the root (html) and as a result are likely to fail with only the slightest adjustment to the application. By finding a nearby element with an id or name attribute (ideally a parent element) you can locate your target element based on the relationship. This is much less likely to change and can make your tests more robust.\nSince only xpath locators start with \u0026ldquo;//\u0026rdquo;, it is not necessary to include the xpath= label when specifying an XPath locator.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  xpath=/html/body/form[1] (3) - Absolute path (would break if the HTML was changed only slightly) //form[1] (3) - First form element in the HTML xpath=//form[@id='loginForm'] (3) - The form element with attribute named \u0026lsquo;id\u0026rsquo; and the value \u0026lsquo;loginForm\u0026rsquo; xpath=//form[input/@name='username'] (3) - First form element with an input child element with attribute named \u0026lsquo;name\u0026rsquo; and the value \u0026lsquo;username\u0026rsquo; //input[@name='username'] (4) - First input element with attribute named \u0026lsquo;name\u0026rsquo; and the value \u0026lsquo;username\u0026rsquo; //form[@id='loginForm']/input[1] (4) - First input child element of the form element with attribute named \u0026lsquo;id\u0026rsquo; and the value \u0026lsquo;loginForm\u0026rsquo; //input[@name='continue'][@type='button'] (7) - Input with attribute named \u0026lsquo;name\u0026rsquo; and the value \u0026lsquo;continue\u0026rsquo; and attribute named \u0026lsquo;type\u0026rsquo; and the value \u0026lsquo;button\u0026rsquo; //form[@id='loginForm']/input[4] (7) - Fourth input child element of the form element with attribute named \u0026lsquo;id\u0026rsquo; and value \u0026lsquo;loginForm\u0026rsquo;  These examples cover some basics, but in order to learn more, the following references are recommended:\n W3Schools XPath Tutorial W3C XPath Recommendation  There are also a couple of very useful Firefox Add-ons that can assist in discovering the XPath of an element:\n XPath Checker XPath and can be used to test XPath results. [Firebug](https://addons.mozilla.org/en-US/firefox/addon/1843 - XPath suggestions are just one of the many powerful features of this very useful add-on.  Locating Hyperlinks by Link Text This is a simple method of locating a hyperlink in your web page by using the text of the link. If two links with the same text are present, then the first match will be used.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Are you sure you want to do this?\u0026lt;/p\u0026gt; \u0026lt;a href=\u0026#34;continue.html\u0026#34;\u0026gt;Continue\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;cancel.html\u0026#34;\u0026gt;Cancel\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  link=Continue (4) link=Cancel (5)  Locating by DOM The Document Object Model represents an HTML document and can be accessed using JavaScript. This location strategy takes JavaScript that evaluates to an element on the page, which can be simply the element\u0026rsquo;s location using the hierarchical dotted notation.\nSince only dom locators start with \u0026ldquo;document\u0026rdquo;, it is not necessary to include the dom= label when specifying a DOM locator.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  dom=document.getElementById('loginForm') (3) dom=document.forms['loginForm'] (3) dom=document.forms[0] (3) document.forms[0].username (4) document.forms[0].elements['username'] (4) document.forms[0].elements[0] (4) document.forms[0].elements[3] (7)  You can use Selenium itself as well as other sites and extensions to explore the DOM of your web application. A good reference exists on W3Schools.\nLocating by CSS CSS (Cascading Style Sheets) is a language for describing the rendering of HTML and XML documents. CSS uses Selectors for binding style properties to elements in the document. These Selectors can be used by Selenium as another locating strategy.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input class=\u0026#34;required\u0026#34; name=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;input class=\u0026#34;required passfield\u0026#34; name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;continue\u0026#34; type=\u0026#34;button\u0026#34; value=\u0026#34;Clear\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt;  css=form#loginForm (3) css=input[name=\u0026quot;username\u0026quot;] (4) css=input.required[type=\u0026quot;text\u0026quot;] (4) css=input.passfield (5) css=#loginForm input[type=\u0026quot;button\u0026quot;] (7) css=#loginForm input:nth-child(2) (5)  For more information about CSS Selectors, the best place to go is the W3C publication. You\u0026rsquo;ll find additional references there.\nImplicit Locators You can choose to omit the locator type in the following situations:\n Locators without an explicitly defined locator strategy will default to using the identifier locator strategy. See Locating by Identifier_.\n Locators starting with \u0026ldquo;//\u0026rdquo; will use the XPath locator strategy. See Locating by XPath_.\n Locators starting with \u0026ldquo;document\u0026rdquo; will use the DOM locator strategy. See Locating by DOM_\n  Matching Text Patterns Like locators, patterns are a type of parameter frequently required by Selenese commands. Examples of commands which require patterns are verifyTextPresent, verifyTitle, verifyAlert, assertConfirmation, verifyText, and verifyPrompt. And as has been mentioned above, link locators can utilize a pattern. Patterns allow you to describe, via the use of special characters, what text is expected rather than having to specify that text exactly.\nThere are three types of patterns: globbing, regular expressions, and exact.\nGlobbing Patterns Most people are familiar with globbing as it is utilized in filename expansion at a DOS or Unix/Linux command line such as ls *.c. In this case, globbing is used to display all the files ending with a .c extension that exist in the current directory. Globbing is fairly limited.\nOnly two special characters are supported in the Selenium implementation:\n* which translates to \u0026ldquo;match anything,\u0026rdquo; i.e., nothing, a single character, or many characters.\n[ ] (character class) which translates to \u0026ldquo;match any single character found inside the square brackets.\u0026rdquo; A dash (hyphen) can be used as a shorthand to specify a range of characters (which are contiguous in the ASCII character set). A few examples will make the functionality of a character class clear:\n[aeiou] matches any lowercase vowel\n[0-9] matches any digit\n[a-zA-Z0-9] matches any alphanumeric character\nIn most other contexts, globbing includes a third special character, the ?. However, Selenium globbing patterns only support the asterisk and character class.\nTo specify a globbing pattern parameter for a Selenese command, you can prefix the pattern with a glob: label. However, because globbing patterns are the default, you can also omit the label and specify just the pattern itself.\nBelow is an example of two commands that use globbing patterns. The actual link text on the page being tested was \u0026ldquo;Film/Television Department\u0026rdquo;; by using a pattern rather than the exact text, the click command will work even if the link text is changed to \u0026ldquo;Film \u0026amp; Television Department\u0026rdquo; or \u0026ldquo;Film and Television Department\u0026rdquo;. The glob pattern\u0026rsquo;s asterisk will match \u0026ldquo;anything or nothing\u0026rdquo; between the word \u0026ldquo;Film\u0026rdquo; and the word \u0026ldquo;Television\u0026rdquo;.\n   Command Target Value     click link=glob:Film*Television Department    verifyTitle glob:*Film*Television*     The actual title of the page reached by clicking on the link was \u0026ldquo;De Anza Film And Television Department - Menu\u0026rdquo;. By using a pattern rather than the exact text, the verifyTitle will pass as long as the two words \u0026ldquo;Film\u0026rdquo; and \u0026ldquo;Television\u0026rdquo; appear (in that order) anywhere in the page\u0026rsquo;s title. For example, if the page\u0026rsquo;s owner should shorten the title to just \u0026ldquo;Film \u0026amp; Television Department,\u0026rdquo; the test would still pass. Using a pattern for both a link and a simple test that the link worked (such as the verifyTitle above does) can greatly reduce the maintenance for such test cases.\nRegular Expression Patterns Regular expression patterns are the most powerful of the three types of patterns that Selenese supports. Regular expressions are also supported by most high-level programming languages, many text editors, and a host of tools, including the Linux/Unix command-line utilities grep, sed, and awk. In Selenese, regular expression patterns allow a user to perform many tasks that would be very difficult otherwise. For example, suppose your test needed to ensure that a particular table cell contained nothing but a number. regexp: [0-9]+ is a simple pattern that will match a decimal number of any length.\nWhereas Selenese globbing patterns support only the * and [ ] (character class) features, Selenese regular expression patterns offer the same wide array of special characters that exist in JavaScript. Below are a subset of those special characters:\n   PATTERN MATCH     . any single character   [ ] character class: any single character that appears inside the brackets   * quantifier: 0 or more of the preceding character (or group)   + quantifier: 1 or more of the preceding character (or group)   ? quantifier: 0 or 1 of the preceding character (or group)   {1,5} quantifier: 1 through 5 of the preceding character (or group)   | alternation: the character/group on the left or the character/group on the right   ( ) grouping: often used with alternation and/or quantifier    Regular expression patterns in Selenese need to be prefixed with either regexp: or regexpi:. The former is case-sensitive; the latter is case-insensitive.\nA few examples will help clarify how regular expression patterns can be used with Selenese commands. The first one uses what is probably the most commonly used regular expression pattern\u0026ndash;.* (\u0026ldquo;dot star\u0026rdquo;). This two-character sequence can be translated as \u0026ldquo;0 or more occurrences of any character\u0026rdquo; or more simply, \u0026ldquo;anything or nothing.\u0026rdquo; It is the equivalent of the one-character globbing pattern * (a single asterisk).\n   Command Target Value     click link=glob:Film*Television Department    verifyTitle regexp:.*Film.*Television.*     The example above is functionally equivalent to the earlier example that used globbing patterns for this same test. The only differences are the prefix (regexp: instead of glob:) and the \u0026ldquo;anything or nothing\u0026rdquo; pattern (.* instead of just *).\nThe more complex example below tests that the Yahoo! Weather page for Anchorage, Alaska contains info on the sunrise time:\n   Command Target Value     open http://weather.yahoo.com/forecast/USAK0012.html    verifyTextPresent regexp:Sunrise: *[0-9]{1,2}:[0-9]{2} [ap]m     Let\u0026rsquo;s examine the regular expression above one part at a time:\n         Sunrise: * The string Sunrise: followed by 0 or more spaces   [0-9]{1,2} 1 or 2 digits (for the hour of the day)   : The character : (no special characters involved)   [0-9]{2} 2 digits (for the minutes) followed by a space   [ap]m \u0026ldquo;a\u0026rdquo; or \u0026ldquo;p\u0026rdquo; followed by \u0026ldquo;m\u0026rdquo; (am or pm)    Exact Patterns The exact type of Selenium pattern is of marginal usefulness. It uses no special characters at all. So, if you needed to look for an actual asterisk character (which is special for both globbing and regular expression patterns), the exact pattern would be one way to do that. For example, if you wanted to select an item labeled \u0026ldquo;Real *\u0026rdquo; from a dropdown, the following code might work or it might not. The asterisk in the glob:Real * pattern will match anything or nothing. So, if there was an earlier select option labeled \u0026ldquo;Real Numbers,\u0026rdquo; it would be the option selected rather than the \u0026ldquo;Real *\u0026rdquo; option.\n   Command Target Value     select //select glob:Real *    In order to ensure that the \u0026ldquo;Real *\u0026rdquo; item would be selected, the exact: prefix could be used to create an exact pattern as shown below:\n   Command Target Value     select //select exact:Real *    But the same effect could be achieved via escaping the asterisk in a regular expression pattern:\n   Command Target Value     select //select regexp:Real \\*    It\u0026rsquo;s rather unlikely that most testers will ever need to look for an asterisk or a set of square brackets with characters inside them (the character class for globbing patterns). Thus, globbing patterns and regular expression patterns are sufficient for the vast majority of us.\nThe \u0026ldquo;AndWait\u0026rdquo; Commands The difference between a command and its AndWait alternative is that the regular command (e.g. click) will do the action and continue with the following command as fast as it can, while the AndWait alternative (e.g. clickAndWait) tells Selenium to wait for the page to load after the action has been done.\nThe AndWait alternative is always used when the action causes the browser to navigate to another page or reload the present one.\nBe aware, if you use an AndWait command for an action that does not trigger a navigation/refresh, your test will fail. This happens because Selenium will reach the AndWait\u0026rsquo;s timeout without seeing any navigation or refresh being made, causing Selenium to raise a timeout exception.\nThe waitFor Commands in AJAX applications In AJAX driven web applications, data is retrieved from server without refreshing the page. Using andWait commands will not work as the page is not actually refreshed. Pausing the test execution for a certain period of time is also not a good approach as web element might appear later or earlier than the stipulated period depending on the system\u0026rsquo;s responsiveness, load or other uncontrolled factors of the moment, leading to test failures. The best approach would be to wait for the needed element in a dynamic period and then continue the execution as soon as the element is found.\nThis is done using waitFor commands, as waitForElementPresent or waitForVisible, which wait dynamically, checking for the desired condition every second and continuing to the next command in the script as soon as the condition is met.\nSequence of Evaluation and Flow Control When a script runs, it simply runs in sequence, one command after another.\nSelenese, by itself, does not support condition statements (if-else, etc.) or iteration (for, while, etc.). Many useful tests can be conducted without flow control. However, for a functional test of dynamic content, possibly involving multiple pages, programming logic is often needed.\nWhen flow control is needed, there are three options:\na) Run the script using Selenium-RC and a client library such as Java or PHP to utilize the programming language\u0026rsquo;s flow control features. b) Run a small JavaScript snippet from within the script using the storeEval command. c) Install the goto_sel_ide.js extension.\nMost testers will export the test script into a programming language file that uses the Selenium-RC API (see the Selenium-IDE chapter). However, some organizations prefer to run their scripts from Selenium-IDE whenever possible (for instance, when they have many junior-level people running tests for them, or when programming skills are lacking). If this is your case, consider a JavaScript snippet or the goto_sel_ide.js extension.\nStore Commands and Selenium Variables You can use Selenium variables to store constants at the beginning of a script. Also, when combined with a data-driven test design (discussed in a later section), Selenium variables can be used to store values passed to your test program from the command-line, from another program, or from a file.\nThe plain store command is the most basic of the many store commands and can be used to simply store a constant value in a selenium variable. It takes two parameters, the text value to be stored and a selenium variable. Use the standard variable naming conventions of only alphanumeric characters when choosing a name for your variable.\n   Command Target Value     store paul@mysite.org     Later in your script, you\u0026rsquo;ll want to use the stored value of your variable. To access the value of a variable, enclose the variable in curly brackets ({}) and precede it with a dollar sign like this.\n   Command Target Value     verifyText //div/p \\${userName}    A common use of variables is for storing input for an input field.\n   Command Target Value     type id=login \\${userName}    Selenium variables can be used in either the first or second parameter and are interpreted by Selenium prior to any other operations performed by the command. A Selenium variable may also be used within a locator expression.\nAn equivalent store command exists for each verify and assert command. Here are a couple more commonly used store commands.\nstoreElementPresent This corresponds to verifyElementPresent. It simply stores a boolean value\u0026ndash;\u0026ldquo;true\u0026rdquo; or \u0026ldquo;false\u0026rdquo;\u0026ndash;depending on whether the UI element is found.\nstoreText StoreText corresponds to verifyText. It uses a locator to identify specific page text. The text, if found, is stored in the variable. StoreText can be used to extract text from the page being tested.\nstoreEval This command takes a script as its first parameter. Embedding JavaScript within Selenese is covered in the next section. StoreEval allows the test to store the result of running the script in a variable.\nJavaScript and Selenese Parameters JavaScript can be used with two types of Selenese parameters: script and non-script (usually expressions). In most cases, you\u0026rsquo;ll want to access and/or manipulate a test case variable inside the JavaScript snippet used as a Selenese parameter. All variables created in your test case are stored in a JavaScript associative array. An associative array has string indexes rather than sequential numeric indexes. The associative array containing your test case\u0026rsquo;s variables is named storedVars. Whenever you wish to access or manipulate a variable within a JavaScript snippet, you must refer to it as storedVars[\u0026lsquo;yourVariableName\u0026rsquo;].\nJavaScript Usage with Script Parameters Several Selenese commands specify a script parameter including assertEval, verifyEval, storeEval, and waitForEval. These parameters require no special syntax. A Selenium-IDE user would simply place a snippet of JavaScript code into the appropriate field, normally the Target field (because a script parameter is normally the first or only parameter).\nThe example below illustrates how a JavaScript snippet can be used to perform a simple numerical calculation:\n   Command Target Value     store 10 hits   storeXpathCount //blockquote blockquotes   storeEval storedVars[\u0026lsquo;hits\u0026rsquo;].storedVars[\u0026lsquo;blockquotes\u0026rsquo;] paragraphs    This next example illustrates how a JavaScript snippet can include calls to methods, in this case the JavaScript String object\u0026rsquo;s toUpperCase method and toLowerCase method.\n   Command Target Value     store Edith Wharton name   storeEval storedVars[\u0026lsquo;name\u0026rsquo;].toUpperCase() uc   storeEval storedVars[\u0026lsquo;name\u0026rsquo;].toUpperCase() lc    JavaScript Usage with Non-Script Parameters JavaScript can also be used to help generate values for parameters, even when the parameter is not specified to be of type script.\nHowever, in this case, special syntax is required\u0026ndash;the entire parameter value must be prefixed by javascript{ with a trailing }, which encloses the JavaScript snippet, as in javascript{*yourCodeHere*}. Below is an example in which the type command\u0026rsquo;s second parameter value is generated via JavaScript code using this special syntax:\n   Command Target Value     store league of nations searchString   type q javascript{storedVars[\u0026lsquo;searchString\u0026rsquo;].toUpperCase()}    echo - The Selenese Print Command Selenese has a simple command that allows you to print text to your test\u0026rsquo;s output. This is useful for providing informational progress notes in your test which display on the console as your test is running. These notes also can be used to provide context within your test result reports, which can be useful for finding where a defect exists on a page in the event your test finds a problem. Finally, echo statements can be used to print the contents of Selenium variables.\n   Command Target Value     echo Testing page footer now.    echo Username is \\${userName}     Alerts, Popups, and Multiple Windows Suppose that you are testing a page that looks like this.\n\u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function output(resultText){ document.getElementById(\u0026#39;output\u0026#39;).childNodes[0].nodeValue=resultText; } function show_confirm(){ var confirmation=confirm(\u0026#34;Chose an option.\u0026#34;); if (confirmation==true){ output(\u0026#34;Confirmed.\u0026#34;); } else{ output(\u0026#34;Rejected!\u0026#34;); } } function show_alert(){ alert(\u0026#34;I\u0026#39;m blocking!\u0026#34;); output(\u0026#34;Alert is gone.\u0026#34;); } function show_prompt(){ var response = prompt(\u0026#34;What\u0026#39;s the best web QA tool?\u0026#34;,\u0026#34;Selenium\u0026#34;); output(response); } function open_window(windowName){ window.open(\u0026#34;newWindow.html\u0026#34;,windowName); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnConfirm\u0026#34; onclick=\u0026#34;show_confirm()\u0026#34; value=\u0026#34;Show confirm box\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnAlert\u0026#34; onclick=\u0026#34;show_alert()\u0026#34; value=\u0026#34;Show alert\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnPrompt\u0026#34; onclick=\u0026#34;show_prompt()\u0026#34; value=\u0026#34;Show prompt\u0026#34; /\u0026gt; \u0026lt;a href=\u0026#34;newWindow.html\u0026#34; id=\u0026#34;lnkNewWindow\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;New Window Link\u0026lt;/a\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnNewNamelessWindow\u0026#34; onclick=\u0026#34;open_window()\u0026#34; value=\u0026#34;Open Nameless Window\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btnNewNamedWindow\u0026#34; onclick=\u0026#34;open_window(\u0026#39;Mike\u0026#39;)\u0026#34; value=\u0026#34;Open Named Window\u0026#34; /\u0026gt; \u0026lt;br /\u0026gt; \u0026lt;span id=\u0026#34;output\u0026#34;\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; The user must respond to alert/confirm boxes, as well as moving focus to newly opened popup windows. Fortunately, Selenium can cover JavaScript pop-ups.\nBut before we begin covering alerts/confirms/prompts in individual detail, it is helpful to understand the commonality between them. Alerts, confirmation boxes and prompts all have variations of the following\n   Command Description     assertFoo(pattern) throws error if pattern doesn’t match the text of the pop-up   assertFooPresent throws error if pop-up is not available   assertFooNotPresent throws error if any pop-up is present   storeFoo(variable) stores the text of the pop-up in a variable   storeFooPresent(variable) stores the text of the pop-up in a variable and returns true or false    When running under Selenium, JavaScript pop-ups will not appear. This is because the function calls are actually being overridden at runtime by Selenium\u0026rsquo;s own JavaScript. However, just because you cannot see the pop-up doesn\u0026rsquo;t mean you don\u0026rsquo;t have to deal with it. To handle a pop-up, you must call its assertFoo(pattern) function. If you fail to assert the presence of a pop-up your next command will be blocked and you will get an error similar to the following [error] Error: There was an unexpected Confirmation! [Chose an option.]\nAlerts Let\u0026rsquo;s start with alerts because they are the simplest pop-up to handle. To begin, open the HTML sample above in a browser and click on the \u0026ldquo;Show alert\u0026rdquo; button. You\u0026rsquo;ll notice that after you close the alert the text \u0026ldquo;Alert is gone.\u0026rdquo; is displayed on the page. Now run through the same steps with Selenium IDE recording, and verify the text is added after you close the alert. Your test will look something like this:\n   Command Target Value     open /    click btnAlert    assertAlert I’m blocking!    verifyTextPresent Alert is gone.     You may be thinking \u0026ldquo;That\u0026rsquo;s odd, I never tried to assert that alert.\u0026rdquo; But this is Selenium-IDE handling and closing the alert for you. If you remove that step and replay the test you will get the following error [error] Error: There was an unexpected Alert! [I'm blocking!]. You must include an assertion of the alert to acknowledge its presence.\nIf you just want to assert that an alert is present but either don\u0026rsquo;t know or don\u0026rsquo;t care what text it contains, you can use assertAlertPresent. This will return true or false, with false halting the test.\nConfirmations Confirmations behave in much the same way as alerts, with assertConfirmation and assertConfirmationPresent offering the same characteristics as their alert counterparts. However, by default Selenium will select OK when a confirmation pops up. Try recording clicking on the \u0026ldquo;Show confirm box\u0026rdquo; button in the sample page, but click on the \u0026ldquo;Cancel\u0026rdquo; button in the popup, then assert the output text. Your test may look something like this:\n   Command Target Value     open /    click btnConfirm    chooseCancelOnNextConfirmation     assertConfirmation Choose an option.    verifyTextPresent Rejected     The chooseCancelOnNextConfirmation function tells Selenium that all following confirmation should return false. It can be reset by calling chooseOkOnNextConfirmation.\nYou may notice that you cannot replay this test, because Selenium complains that there is an unhandled confirmation. This is because the order of events Selenium-IDE records causes the click and chooseCancelOnNextConfirmation to be put in the wrong order (it makes sense if you think about it, Selenium can\u0026rsquo;t know that you\u0026rsquo;re cancelling before you open a confirmation) Simply switch these two commands and your test will run fine.\nPrompts Prompts behave in much the same way as alerts, with assertPrompt and assertPromptPresent offering the same characteristics as their alert counterparts. By default, Selenium will wait for you to input data when the prompt pops up. Try recording clicking on the \u0026ldquo;Show prompt\u0026rdquo; button in the sample page and enter \u0026ldquo;Selenium\u0026rdquo; into the prompt. Your test may look something like this:\n   Command Target Value     open /    answerOnNextPrompt Selenium!    click id=btnPrompt    assertPrompt What’s the best web QA tool?    verifyTextPresent Selenium!     If you choose cancel on the prompt, you may notice that answerOnNextPrompt will simply show a target of blank. Selenium treats cancel and a blank entry on the prompt basically as the same thing.\nDebugging Debugging means finding and fixing errors in your test case. This is a normal part of test case development.\nWe won\u0026rsquo;t teach debugging here as most new users to Selenium will already have some basic experience with debugging. If this is new to you, we recommend you ask one of the developers in your organization.\nBreakpoints and Startpoints The Sel-IDE supports the setting of breakpoints and the ability to start and stop the running of a test case, from any point within the test case. That is, one can run up to a specific command in the middle of the test case and inspect how the test case behaves at that point. To do this, set a breakpoint on the command just before the one to be examined.\nTo set a breakpoint, select a command, right-click, and from the context menu select Toggle Breakpoint. Then click the Run button to run your test case from the beginning up to the breakpoint.\nIt is also sometimes useful to run a test case from somewhere in the middle to the end of the test case or up to a breakpoint that follows the starting point.\nFor example, suppose your test case first logs into the website and then performs a series of tests and you are trying to debug one of those tests.\nHowever, you only need to login once, but you need to keep rerunning your tests as you are developing them. You can login once, then run your test case from a startpoint placed after the login portion of your test case. That will prevent you from having to manually logout each time you rerun your test case.\nTo set a startpoint, select a command, right-click, and from the context menu select Set/Clear Start Point. Then click the Run button to execute the test case beginning at that startpoint.\nStepping Through a Testcase To execute a test case one command at a time (\u0026ldquo;step through\u0026rdquo; it), follow these steps:\n Start the test case running with the Run button from the toolbar.\n Immediately pause the executing test case with the Pause button.\n Repeatedly select the Step button.\n  Find Button The Find button is used to see which UI element on the currently displayed webpage (in the browser) is used in the currently selected Selenium command.\nThis is useful when building a locator for a command\u0026rsquo;s first parameter (see the section on :ref:locators \u0026lt;locators-section\u0026gt; in the Selenium Commands chapter). It can be used with any command that identifies a UI element on a webpage, i.e. click, clickAndWait, type, and certain assert and verify commands, among others.\nFrom Table view, select any command that has a locator parameter. Click the Find button.\nNow look on the webpage: There should be a bright green rectangle enclosing the element specified by the locator parameter.\nPage Source for Debugging Often, when debugging a test case, you simply must look at the page source (the HTML for the webpage you\u0026rsquo;re trying to test) to determine a problem. Firefox makes this easy. Simply right-click the webpage and select \u0026lsquo;View-\u0026gt;Page Source.\nThe HTML opens in a separate window. Use its Search feature (Edit=\u0026gt;Find) to search for a keyword to find the HTML for the UI element you\u0026rsquo;re trying to test.\nAlternatively, select just that portion of the webpage for which you want to see the source. Then right-click the webpage and select View Selection Source. In this case, the separate HTML window will contain just a small amount of source, with highlighting on the portion representing your selection.\nLocator Assistance Whenever Selenium-IDE records a locator-type argument, it stores additional information which allows the user to view other possible locator-type arguments that could be used instead. This feature can be very useful for learning more about locators, and is often needed to help one build a different type of locator than the type that was recorded.\nThis locator assistance is presented on the Selenium-IDE window as a drop-down list accessible at the right end of the Target field (only when the Target field contains a recorded locator-type argument).\nBelow is a snapshot showing the contents of this drop-down for one command. Note that the first column of the drop-down provides alternative locators, whereas the second column indicates the type of each alternative.\nWriting a Test Suite A test suite is a collection of test cases which is displayed in the leftmost pane in the IDE.\nThe test suite pane can be manually opened or closed via selecting a small dot halfway down the right edge of the pane (which is the left edge of the entire Selenium-IDE window if the pane is closed).\nThe test suite pane will be automatically opened when an existing test suite is opened or when the user selects the New Test Case item from the File menu. In the latter case, the new test case will appear immediately below the previous test case.\nSelenium-IDE also supports loading pre-existing test cases by using the File -\u0026gt; Add Test Case menu option. This allows you to add existing test cases to a new test suite.\nA test suite file is an HTML file containing a one-column table. Each cell of each row in the  section contains a link to a test case. The example below is of a test suite containing four test cases:\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Sample Selenium Test Suite\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table cellpadding=\u0026#34;1\u0026#34; cellspacing=\u0026#34;1\u0026#34; border=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;Test Cases for De Anza A-Z Directory Links\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./a.html\u0026#34;\u0026gt;A Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./b.html\u0026#34;\u0026gt;B Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./c.html\u0026#34;\u0026gt;C Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;./d.html\u0026#34;\u0026gt;D Links\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Note: Test case files should not have to be co-located with the test suite file that invokes them. And on Mac OS and Linux systems, that is indeed the case. However, at the time of this writing, a bug prevents Windows users from being able to place the test cases elsewhere than with the test suite that invokes them.\nUser Extensions User extensions are JavaScript files that allow one to create his or her own customizations and features to add additional functionality. Often this is in the form of customized commands although this extensibility is not limited to additional commands.\nThere are a number of useful extensions_ created by users.\nIMPORTANT: THIS SECTION IS OUT OF DATE\u0026ndash;WE WILL BE REVISING THIS SOON.\n _extensions: http://wiki.openqa.org/display/SEL/Contributed+User-Extensions  .. _goto_sel_ide.js extension:\nPerhaps the most popular of all Selenium-IDE extensions is one which provides flow control in the form of while loops and primitive conditionals. This extension is the goto_selide.js. For an example of how to use the functionality provided by this extension, look at the page_ created by its author.\nTo install this extension, put the pathname to its location on your computer in the Selenium Core extensions field of Selenium-IDE\u0026rsquo;s Options=\u0026gt;Options=\u0026gt;General tab.\nAfter selecting the OK button, you must close and reopen Selenium-IDE in order for the extensions file to be read. Any change you make to an extension will also require you to close and reopen Selenium-IDE.\nInformation on writing your own extensions can be found near the bottom of the Selenium Reference_ document.\nSometimes it can prove very useful to debug step by step Selenium IDE and your User Extension. The only debugger that appears able to debug XUL/Chrome based extensions is Venkman which is supported in Firefox until version 32 included. The step by step debug has been verified to work with Firefox 32 and Selenium IDE 2.9.0.\nFormat Format, under the Options menu, allows you to select a language for saving and displaying the test case. The default is HTML.\nIf you will be using Selenium-RC to run your test cases, this feature is used to translate your test case into a programming language. Select the language, e.g. Java, PHP, you will be using with Selenium-RC for developing your test programs. Then simply save the test case using File=\u0026gt;Export Test Case As. Your test case will be translated into a series of functions in the language you choose. Essentially, program code supporting your test is generated for you by Selenium-IDE.\nAlso, note that if the generated code does not suit your needs, you can alter it by editing a configuration file which defines the generation process.\nEach supported language has configuration settings which are editable. This is under the Options=\u0026gt;Options=\u0026gt;Formats tab.\nExecuting Selenium-IDE Tests on Different Browsers While Selenium-IDE can only run tests against Firefox, tests developed with Selenium-IDE can be run against other browsers, using a simple command-line interface that invokes the Selenium-RC server. This topic is covered in the :ref:Run Selenese tests \u0026lt;html-suite\u0026gt; section on Selenium-RC chapter. The -htmlSuite command-line option is the particular feature of interest.\nTroubleshooting Below is a list of image/explanation pairs which describe frequent sources of problems with Selenium-IDE:\nTable view is not available with this format.\nThis message can be occasionally displayed in the Table tab when Selenium IDE is launched. The workaround is to close and reopen Selenium IDE. See issue 1008. for more information. If you are able to reproduce this reliably then please provide details so that we can work on a fix.\nerror loading test case: no command found\nYou\u0026rsquo;ve used File=\u0026gt;Open to try to open a test suite file. Use File=\u0026gt;Open Test Suite instead.\nAn enhancement request has been raised to improve this error message. See issue 1010.\nThis type of error may indicate a timing problem, i.e., the element specified by a locator in your command wasn\u0026rsquo;t fully loaded when the command was executed. Try putting a pause 5000 before the command to determine whether the problem is indeed related to timing. If so, investigate using an appropriate waitFor* or *AndWait command before the failing command.\nWhenever your attempt to use variable substitution fails as is the case for the open command above, it indicates that you haven\u0026rsquo;t actually created the variable whose value you\u0026rsquo;re trying to access. This is sometimes due to putting the variable in the Value field when it should be in the Target field or vice versa. In the example above, the two parameters for the store command have been erroneously placed in the reverse order of what is required. For any Selenese command, the first required parameter must go in the Target field, and the second required parameter (if one exists) must go in the Value field.\nerror loading test case: [Exception\u0026hellip; \u0026ldquo;Component returned failure code: 0x80520012 (NS_ERROR_FILE_NOT_FOUND) [nsIFileInputStream.init]\u0026rdquo; nresult: \u0026ldquo;0x80520012 (NS_ERROR_FILE_NOT_FOUND)\u0026rdquo; location: \u0026ldquo;JS frame :: chrome://selenium-ide/content/file-utils.js :: anonymous :: line 48\u0026rdquo; data: no]\nOne of the test cases in your test suite cannot be found. Make sure that the test case is indeed located where the test suite indicates it is located. Also, make sure that your actual test case files have the .html extension both in their filenames, and in the test suite file where they are referenced.\nAn enhancement request has been raised to improve this error message. See issue 1011.\nYour extension file\u0026rsquo;s contents have not been read by Selenium-IDE. Be sure you have specified the proper pathname to the extensions file via Options=\u0026gt;Options=\u0026gt;General in the Selenium Core extensions field. Also, Selenium-IDE must be restarted after any change to either an extensions file or to the contents of the Selenium Core extensions field.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/getting_started_with_webdriver/performing_actions_on_the_aut/",
	"title": "Réaliser des action sur l&#39;AUT*",
	"tags": [],
	"description": "",
	"content": " Il est possible de renseigner le texte d\u0026rsquo;un élément web grâce à la méthode sendKeys, comme suit:\nJava Python C# Ruby JavaScript Kotlin String name = \u0026#34;Charles\u0026#34;; driver.findElement(By.name(\u0026#34;name\u0026#34;)).sendKeys(name);   name = \u0026#34;Charles\u0026#34; driver.find_element_by_name(\u0026#34;name\u0026#34;).send_keys(name)   string name = \u0026#34;Charles\u0026#34;; driver.FindElement(By.Name(\u0026#34;name\u0026#34;)).SendKeys(name);   name = \u0026#34;Charles\u0026#34; driver.find_element(name: \u0026#34;name\u0026#34;).send_keys(name)   const name = \u0026#34;Charles\u0026#34;; await driver.findElement(By.name(\u0026#39;name\u0026#39;)).sendKeys(name);   val name = \u0026#34;Charles\u0026#34; driver.findElement(By.name(\u0026#34;name\u0026#34;)).sendKeys(name)     Certaines applications web utilisent des librairies Javascript pour ajouter des fonctionnalités de drag-and-drop. Suit un exemple basique permettant de dragger un élément sur un autre :\nJava Python C# Ruby JavaScript Kotlin WebElement source = driver.findElement(By.id(\u0026#34;source\u0026#34;)); WebElement target = driver.findElement(By.id(\u0026#34;target\u0026#34;)); new Actions(driver).dragAndDrop(source, target).build().perform();   source = driver.find_element_by_id(\u0026#34;source\u0026#34;) target = driver.find_element_by_id(\u0026#34;target\u0026#34;) ActionChains(driver).drag_and_drop(source, target).perform()   IWebElement source = driver.FindElement(By.Id(\u0026#34;source\u0026#34;)); IWebElement target = driver.FindElement(By.Id(\u0026#34;target\u0026#34;)); new Actions(driver).DragAndDrop(source, target).Build().Perform();   source = driver.find_element(id: \u0026#34;source\u0026#34;) target = driver.find_element(id: \u0026#34;target\u0026#34;) driver.action.drag_and_drop(source, target).perform   const actions = driver.actions({bridge: true}); const source = driver.findElement(By.id(\u0026#39;source\u0026#39;)); const target = driver.findElement(By.id(\u0026#39;target\u0026#39;)); await actions.dragAndDrop(source, target).perform();   val source = driver.findElement(By.id(\u0026#34;source\u0026#34;)) val target = driver.findElement(By.id(\u0026#34;target\u0026#34;)) Actions(driver).dragAndDrop(source, target).build().perform()     Cliquer sur un élément Il est possible de cliquer sur un élément en utilisant la méhode click:\nJava Python C# Ruby JavaScript Kotlin driver.findElement(By.cssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click();   driver.find_element_by_css_selector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;).click()   driver.FindElement(By.CssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).Click();   driver.find_element(css: \u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;).click   await driver.findElement(By.css(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click();   driver.findElement(By.cssSelector(\u0026#34;input[type=\u0026#39;submit\u0026#39;]\u0026#34;)).click()     AUT: Application testée (Application under test en anglais)\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/webdriver/waits/",
	"title": "Waits",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n WebDriver can generally be said to have a blocking API. Because it is an out-of-process library that instructs the browser what to do, and because the web platform has an intrinsically asynchronous nature, WebDriver doesn\u0026rsquo;t track the active, real-time state of the DOM. This comes with some challenges that we will discuss here.\nFrom experience, most intermittents that arise from use of Selenium and WebDriver are connected to race conditions that occur between the browser and the user\u0026rsquo;s instructions. An example could be that the user instructs the browser to navigate to a page, then gets a no such element error when trying to find an element.\nConsider the following document:\n\u0026lt;!doctype html\u0026gt; \u0026lt;meta charset=utf-8\u0026gt; \u0026lt;title\u0026gt;Race Condition Example\u0026lt;/title\u0026gt; \u0026lt;script\u0026gt; var initialised = false; window.addEventListener(\u0026#34;load\u0026#34;, function() { var newElement = document.createElement(\u0026#34;p\u0026#34;); newElement.textContent = \u0026#34;Hello from JavaScript!\u0026#34;; document.body.appendChild(newElement); initialised = true; }); \u0026lt;/script\u0026gt; The WebDriver instructions might look innocent enough:\nJava Python C# Ruby JavaScript Kotlin driver.get(\u0026#34;file:///race_condition.html\u0026#34;); WebElement element = driver.findElement(By.tagName(\u0026#34;p\u0026#34;)); assertEquals(element.getText(), \u0026#34;Hello from JavaScript!\u0026#34;);   driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) el = driver.find_element_by_tag_name(\u0026#34;p\u0026#34;) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   driver.Navigate().GoToUrl(\u0026#34;file:///race_condition.html\u0026#34;); IWebElement element = driver.FindElement(By.TagName(\u0026#34;p\u0026#34;)); assertEquals(element.Text, \u0026#34;Hello from JavaScript!\u0026#34;);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;file:///race_condition.html\u0026#39; # Get and store Paragraph Text search_form = driver.find_element(:css,\u0026#39;p\u0026#39;).text \u0026#34;Hello from JavaScript!\u0026#34;.eql? search_form ensure driver.quit end   await driver.get(\u0026#39;file:///race_condition.html\u0026#39;); const element = driver.findElement(By.css(\u0026#39;p\u0026#39;)); assert.strictEqual(await element.getText(), \u0026#39;Hello from JavaScript!\u0026#39;);   driver.get(\u0026#34;file:///race_condition.html\u0026#34;) val element = driver.findElement(By.tagName(\u0026#34;p\u0026#34;)) assert(element.text == \u0026#34;Hello from JavaScript!\u0026#34;)     The issue here is that the default page load strategy used in WebDriver listens for the document.readyState to change to \u0026quot;complete\u0026quot; before returning from the call to navigate. Because the p element is added after the document has completed loading, this WebDriver script might be intermittent. It “might” be intermittent because no guarantees can be made about elements or events that trigger asynchronously without explicitly waiting—or blocking—on those events.\nFortunately, using the normal instruction set available on the WebElement interface—such as WebElement.click and _WebElement.sendKeys_—are guaranteed to be synchronous, in that the function calls won\u0026rsquo;t return (or the callback won\u0026rsquo;t trigger in callback-style languages) until the command has been completed in the browser. The advanced user interaction APIs, Keyboard and Mouse, are exceptions as they are explicitly intended as “do what I say” asynchronous commands.\nWaiting is having the automated task execution elapse a certain amount of time before continuing with the next step.\nTo overcome the problem of race conditions between the browser and your WebDriver script, most Selenium clients ship with a wait package. When employing a wait, you are using what is commonly referred to as an explicit wait.\nExplicit wait Explicit waits are available to Selenium clients for imperative, procedural languages. They allow your code to halt program execution, or freeze the thread, until the condition you pass it resolves. The condition is called with a certain frequency until the timeout of the wait is elapsed. This means that for as long as the condition returns a falsy value, it will keep trying and waiting.\nSince explicit waits allow you to wait for a condition to occur, they make a good fit for synchronising the state between the browser and its DOM, and your WebDriver script.\nTo remedy our buggy instruction set from earlier, we could employ a wait to have the findElement call wait until the dynamically added element from the script has been added to the DOM:\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new ChromeDriver(); driver.get(\u0026#34;https://google.com/ncr\u0026#34;); driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER); // Initialize and wait till element(link) became clickable - timeout in 10 seconds WebElement firstResult = new WebDriverWait(driver, Duration.ofSeconds(10)) .until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;))); // Print the first result System.out.println(firstResult.getText());   from selenium.webdriver.support.ui import WebDriverWait def document_initialised(driver): return driver.execute_script(\u0026#34;return initialised\u0026#34;) driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) WebDriverWait(driver).until(document_initialised) el = driver.find_element_by_tag_name(\u0026#34;p\u0026#34;) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   driver = new ChromeDriver(); driver.Url = \u0026#34;https://www.google.com/ncr\u0026#34;; driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;cheese\u0026#34; + Keys.Enter); WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10)); IWebElement firstResult = wait.Until(e =\u0026gt; e.FindElement(By.XPath(\u0026#34;//a/h3\u0026#34;))); Console.WriteLine(firstResult.Text);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox wait = Selenium::WebDriver::Wait.new(:timeout =\u0026gt; 10) def document_initialised(driver) driver.execute_script(\u0026#39;return initialised\u0026#39;) end begin driver.get \u0026#39;file:///race_condition.html\u0026#39; wait.until{document_initialised driver} search_form = driver.find_element(:css,\u0026#39;p\u0026#39;).text \u0026#34;Hello from JavaScript!\u0026#34;.eql? search_form ensure driver.quit end   const documentInitialised = () =\u0026gt; driver.executeScript(\u0026#39;return initialised\u0026#39;); await driver.get(\u0026#39;file:///race_condition.html\u0026#39;); await driver.wait(() =\u0026gt; documentInitialised(), 10000); const element = driver.findElement(By.css(\u0026#39;p\u0026#39;)); assert.strictEqual(await element.getText(), \u0026#39;Hello from JavaScript!\u0026#39;);   driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER) // Initialize and wait till element(link) became clickable - timeout in 10 seconds val firstResult = WebDriverWait(driver, Duration.ofSeconds(10)) .until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;))) // Print the first result println(firstResult.text)     We pass in the condition as a function reference that the wait will run repeatedly until its return value is truthy. A “truthful” return value is anything that evaluates to boolean true in the language at hand, such as a string, number, a boolean, an object (including a WebElement), or a populated (non-empty) sequence or list. That means an empty list evaluates to false. When the condition is truthful and the blocking wait is aborted, the return value from the condition becomes the return value of the wait.\nWith this knowledge, and because the wait utility ignores no such element errors by default, we can refactor our instructions to be more concise:\nJava Python C# Ruby JavaScript Kotlin WebElement foo = new WebDriverWait(driver, Duration.ofSeconds(3)) .until(driver -\u0026gt; driver.findElement(By.name(\u0026#34;q\u0026#34;))); assertEquals(foo.getText(), \u0026#34;Hello from JavaScript!\u0026#34;);   from selenium.webdriver.support.ui import WebDriverWait driver.navigate(\u0026#34;file:///race_condition.html\u0026#34;) el = WebDriverWait(driver).until(lambda d: d.find_element_by_tag_name(\u0026#34;p\u0026#34;)) assert el.text == \u0026#34;Hello from JavaScript!\u0026#34;   using (var driver = new FirefoxDriver()) { var foo = new WebDriverWait(driver, TimeSpan.FromSeconds(3)) .Until(drv =\u0026gt; drv.FindElement(By.Name(\u0026#34;q\u0026#34;))); Debug.Assert(foo.Text.Equals(\u0026#34;Hello from JavaScript!\u0026#34;)); }   driver.get \u0026#39;file:///race_condition.html\u0026#39; wait = Selenium::WebDriver::Wait.new(:timeout =\u0026gt; 10) ele = wait.until { driver.find_element(css: \u0026#39;p\u0026#39;)} foo = ele.text assert_match foo, \u0026#39;Hello from JavaScript\u0026#39;   let ele = await driver.wait(until.elementLocated(By.css(\u0026#39;p\u0026#39;)),10000); let foo = await ele.getText(); assert(foo == \u0026#34;Hello from JavaScript\u0026#34;);   driver.get(\u0026#34;file:///race_condition.html\u0026#34;) val ele = WebDriverWait(getWebDriver(), Duration.ofSeconds(10)) .until(ExpectedConditions.presenceOfElementLocated(By.tagName(\u0026#34;p\u0026#34;))) assert(ele.text == \u0026#34;Hello from JavaScript!\u0026#34;)     In that example, we pass in an anonymous function (but we could also define it explicitly as we did earlier so it may be reused). The first and only argument that is passed to our condition is always a reference to our driver object, WebDriver (called d in the example). In a multi-threaded environment, you should be careful to operate on the driver reference passed in to the condition rather than the reference to the driver in the outer scope.\nBecause the wait will swallow no such element errors that are raised when the element isn\u0026rsquo;t found, the condition will retry until the element is found. Then it will take the return value, a WebElement, and pass it back through to our script.\nIf the condition fails, e.g. a truthful return value from the condition is never reached, the wait will throw/raise an error/exception called a timeout error.\nOptions The wait condition can be customised to match your needs. Sometimes it\u0026rsquo;s unnecessary to wait the full extent of the default timeout, as the penalty for not hitting a successful condition can be expensive.\nThe wait lets you pass in an argument to override the timeout:\nJava Python C# Ruby JavaScript Kotlin new WebDriverWait(driver, Duration.ofSeconds(3)).until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;)));   WebDriverWait(driver, timeout=3).until(some_condition)   new WebDriverWait(driver, TimeSpan.FromSeconds(3)).Until(ExpectedConditions.ElementToBeClickable(By.XPath(\u0026#34;//a/h3\u0026#34;)));   wait = Selenium::WebDriver::Wait.new(:timeout =\u0026gt; 10) wait.until { driver.find_element(:id, \u0026#39;message\u0026#39;).displayed? }   await driver.wait(until.elementLocated(By.id(\u0026#39;foo\u0026#39;)), 30000);   WebDriverWait(driver, Duration.ofSeconds(3)).until(ExpectedConditions.elementToBeClickable(By.xpath(\u0026#34;//a/h3\u0026#34;)))     Expected conditions Because it\u0026rsquo;s quite a common occurrence to have to synchronise the DOM and your instructions, most clients also come with a set of predefined expected conditions. As might be obvious by the name, they are conditions that are predefined for frequent wait operations.\nThe conditions available in the different language bindings vary, but this is a non-exhaustive list of a few:\n alert is present element exists element is visible title contains title is element staleness visible text  You can refer to the API documentation for each client binding to find an exhaustive list of expected conditions:\n Java\u0026rsquo;s org.openqa.selenium.support.ui.ExpectedConditions class Python\u0026rsquo;s selenium.webdriver.support.expected_conditions class .NET\u0026rsquo;s OpenQA.Selenium.Support.UI.ExpectedConditions type  Implicit wait There is a second type of wait that is distinct from explicit wait called implicit wait. By implicitly waiting, WebDriver polls the DOM for a certain duration when trying to find any element. This can be useful when certain elements on the webpage are not available immediately and need some time to load.\nImplicit waiting for elements to appear is disabled by default and will need to be manually enabled on a per-session basis. Mixing explicit waits and implicit waits will cause unintended consequences, namely waits sleeping for the maximum time even if the element is available or condition is true.\nWarning: Do not mix implicit and explicit waits. Doing so can cause unpredictable wait times. For example, setting an implicit wait of 10 seconds and an explicit wait of 15 seconds could cause a timeout to occur after 20 seconds.\nAn implicit wait is to tell WebDriver to poll the DOM for a certain amount of time when trying to find an element or elements if they are not immediately available. The default setting is 0, meaning disabled. Once set, the implicit wait is set for the life of the session.\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS); driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;); WebElement myDynamicElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;));   driver = Firefox() driver.implicitly_wait(10) driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) my_dynamic_element = driver.find_element_by_id(\u0026#34;myDynamicElement\u0026#34;)   IWebDriver driver = new ChromeDriver(); driver.Manage().Timeouts().ImplicitWait = TimeSpan.FromSeconds(10); driver.Url = \u0026#34;http://somedomain/url_that_delays_loading\u0026#34;; IWebElement dynamicElement = driver.FindElement(By.Name(\u0026#34;dynamicElement\u0026#34;));   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox driver.manage.timeouts.implicit_wait = 10 begin driver.get \u0026#39;http://somedomain/url_that_delays_loading\u0026#39; search_form = driver.find_element(:id,\u0026#39;dynamic_element\u0026#39;) ensure driver.quit end   (async function(){ // Apply timeout for 10 seconds await driver.manage().setTimeouts( { implicit: 10000 } ); // Navigate to url await driver.get(\u0026#39;http://somedomain/url_that_delays_loading\u0026#39;); let webElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;)); }());   val driver = FirefoxDriver() driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS) driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) val myDynamicElement = driver.findElement(By.id(\u0026#34;myDynamicElement\u0026#34;))     FluentWait FluentWait instance defines the maximum amount of time to wait for a condition, as well as the frequency with which to check the condition.\nUsers may configure the wait to ignore specific types of exceptions whilst waiting, such as NoSuchElementException when searching for an element on the page.\nJava Python C# Ruby JavaScript Kotlin // Waiting 30 seconds for an element to be present on the page, checking // for its presence once every 5 seconds. Wait\u0026lt;WebDriver\u0026gt; wait = new FluentWait\u0026lt;WebDriver\u0026gt;(driver) .withTimeout(Duration.ofSeconds(30)) .pollingEvery(Duration.ofSeconds(5)) .ignoring(NoSuchElementException.class); WebElement foo = wait.until(new Function\u0026lt;WebDriver, WebElement\u0026gt;() { public WebElement apply(WebDriver driver) { return driver.findElement(By.id(\u0026#34;foo\u0026#34;)); } });   driver = Firefox() driver.get(\u0026#34;http://somedomain/url_that_delays_loading\u0026#34;) wait = WebDriverWait(driver, 10, poll_frequency=1, ignored_exceptions=[ElementNotVisibleException, ElementNotSelectableException]) element = wait.until(EC.element_to_be_clickable((By.XPATH, \u0026#34;//div\u0026#34;)))   using (var driver = new FirefoxDriver()) { WebDriverWait wait = new WebDriverWait(driver, timeout: TimeSpan.FromSeconds(30)) { PollingInterval = TimeSpan.FromSeconds(5), }; wait.IgnoreExceptionTypes(typeof(NoSuchElementException)); var foo = wait.Until(drv =\u0026gt; drv.FindElement(By.Id(\u0026#34;foo\u0026#34;))); }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox exception = Selenium::WebDriver::Error::NoSuchElementError begin driver.get \u0026#39;http://somedomain/url_that_delays_loading\u0026#39; wait = Selenium::WebDriver::Wait.new(timeout: 30, interval: 5, message: \u0026#39;Timed out after 30 sec\u0026#39;, ignore: exception) foo = wait.until { driver.find_element(id: \u0026#39;foo\u0026#39;)} ensure driver.quit end   const {Builder, until} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); await driver.get(\u0026#39;http://somedomain/url_that_delays_loading\u0026#39;); // Waiting 30 seconds for an element to be present on the page, checking  // for its presence once every 5 seconds.  let foo = await driver.wait(until.elementLocated(By.id(\u0026#39;foo\u0026#39;)), 30000, \u0026#39;Timed out after 30 seconds\u0026#39;, 5000); })();   val wait = FluentWait\u0026lt;WebDriver\u0026gt;(getWebDriver()) .withTimeout(Duration.ofSeconds(30)) .pollingEvery(Duration.ofSeconds(3)) .ignoring(NoSuchElementException::class.java) val foo = wait.until {it.findElement(By.id(\u0026#34;foo\u0026#34;)) }     "
},
{
	"uri": "https://selenium.dev/documentation/fr/grid/when_to_use_grid/",
	"title": "When to use Grid",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Generally speaking, there’s two reasons why you might want to use Grid.\n To run your tests against multiple browsers, multiple versions of browser, and browsers running on different operating systems. To reduce the time it takes for the test suite to complete a test pass.  Grid is used to speed up the execution of a test pass by using multiple machines to run tests in parallel. For example, if you have a suite of 100 tests, but you set up Grid to support 4 different machines (VMs or separate physical machines) to run those tests, your test suite will complete in (roughly) one-fourth the time as it would if you ran your tests sequentially on a single machine. For large test suites, and long-running test suite such as those performing large amounts of data-validation, this can be a significant time-saver. Some test suites can take hours to run. Another reason to boost the time spent running the suite is to shorten the turnaround time for test results after developers check-in code for the AUT. Increasingly software teams practicing Agile software development want test feedback as immediately as possible as opposed to wait overnight for an overnight test pass.\nGrid is also used to support running tests against multiple runtime environments, specifically, against different browsers at the same time. For example, a ‘grid’ of virtual machines can be setup with each supporting a different browser that the application to be tested must support. So, machine 1 has Internet Explorer 8, machine 2, Internet Explorer 9, machine 3 the latest Chrome, and machine 4 the latest Firefox. When the test suite is run, Selenium-Grid receives each test-browser combination and assigns each test to run against its required browser.\nIn addition, one can have a grid of all the same browser, type and version. For instance, one could have a grid of 4 machines each running 3 instances of Firefox 70, allowing for a ‘server-farm’ (in a sense) of available Firefox instances. When the suite runs, each test is passed to Grid which assigns the test to the next available Firefox instance. In this manner one gets test pass where conceivably 12 tests are all running at the same time in parallel, significantly reducing the time required to complete a test pass.\nGrid is very flexible. These two examples can be combined to allow multiple instances of each browser type and version. A configuration such as this would provide both, parallel execution for fast test pass completion and support for multiple browser types and versions simultaneously.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/webdriver/support_classes/",
	"title": "Classes de support",
	"tags": [],
	"description": "",
	"content": " Les classes de support WebDriver sont fournies pour simplifier la maintenance de votre code.Elles fournissent une belle abstraction pour faciliter la modélisation des éléments HTML en tant qu\u0026rsquo;objets de domaine, ainsi que des méthodes d\u0026rsquo;aide pour rendre l\u0026rsquo;utilisation de ces objets facile à raisonner.\n Stratégies de localisation Événements LoadableComponent ThreadGuard etc.  Commençons:\nThreadGuard  Cette classe est uniquement disponible dans la liaison Java\n ThreadGuard vérifie qu\u0026rsquo;un pilote est appelé uniquement à partir du même thread qui l\u0026rsquo;a créé. Les problèmes de thread, en particulier lors de l\u0026rsquo;exécution de tests en parallèle, peuvent être mystérieux et difficile à diagnostiquer les erreurs. L\u0026rsquo;utilisation de ce wrapper empêche cette catégorie d\u0026rsquo;erreurs et lèvera une exception lorsque cela se produira.\nL\u0026rsquo;exemple suivant simule un choc de threads:\npublic class DriverClash { //thread main (id 1) created this driver  private WebDriver protectedDriver = ThreadGuard.protect(new ChromeDriver()); static { System.setProperty(\u0026#34;webdriver.chrome.driver\u0026#34;, \u0026#34;\u0026lt;Set path to your Chromedriver\u0026gt;\u0026#34;); } //Thread-1 (id 24) is calling the same driver causing the clash to happen  Runnable r1 = () -\u0026gt; {protectedDriver.get(\u0026#34;https://selenium.dev\u0026#34;);}; Thread thr1 = new Thread(r1); void runThreads(){ thr1.start(); } public static void main(String[] args) { new DriverClash().runThreads(); } } Le résultat ci-dessous:\nException in thread \u0026#34;Thread-1\u0026#34; org.openqa.selenium.WebDriverException: Thread safety error; this instance of WebDriver was constructed on thread main (id 1)and is being accessed by thread Thread-1 (id 24) This is not permitted and *will* cause undefined behaviour Comme le montre l\u0026rsquo;exemple:\n protectedDriver sera créé dans le thread principal Nous utilisons Java Runnable pour lancer un nouveau processus et un nouveau Thread pour exécuter le processus Les deux Thread s\u0026rsquo;affrontent car le Thread principal n\u0026rsquo;a pasprotectedDriver dans sa mémoire. ThreadGuard.protect lèvera une exception.  Remarque: Cela ne remplace pas la nécessité d\u0026rsquo;utiliser ThreadLocal pour gérer les pilotes lors de l\u0026rsquo;exécution en parallèle.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/worst_practices/test_dependency/",
	"title": "Dépéndence des tests",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n A common idea and misconception about automated testing is regarding a specific test order. Your tests should be able to run in any order, and not rely on other tests to complete in order to be successful.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/guidelines_and_recommendations/improved_reporting/",
	"title": "Reporting amélioré",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Selenium is not designed to report on the status of test cases run. Taking advantage of the built-in reporting capabilities of unit test frameworks is a good start. Most unit test frameworks have reports that can generate xUnit or HTML formatted reports. xUnit reports are popular for importing results to a Continuous Integration (CI) server like Jenkins, Travis, Bamboo, etc. Here are some links for more information regarding report outputs for several languages. NUnit 3 Console Runner NUnit 3 Console Command Line xUnit getting test results in TeamCity xUnit getting test results in CruiseControl.NET xUnit getting test results in Azure DevOps\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/webdriver/",
	"title": "WebDriver",
	"tags": [],
	"description": "",
	"content": " WebDriver WebDriver pilote un navigateur nativement, comme le ferait un utilisateur, soit localement ou sur une machine distante utilisant le serveur Selenium, marque un bond en avant en termes d\u0026rsquo;automatisation du navigateur.\nSelenium WebDriver fait référence aux deux liaisons de langue et les implémentations du code de contrôle de navigateur individuel. Ceci est communément appelé simplement WebDriver.\nSelenium WebDriver est une recommandation du W3C\n WebDriver est conçu comme un simple et une interface de programmation plus concise.\n WebDriver est une API orientée objet compacte.\n Il pilote efficacement le navigateur.\n  "
},
{
	"uri": "https://selenium.dev/documentation/fr/webdriver/js_alerts_prompts_and_confirmations/",
	"title": "Alerts, prompts et confirmations Javascript",
	"tags": [],
	"description": "",
	"content": " WebDriver fournit une API pour travailler avec les trois types de messages contextuels natifs proposés par JavaScript. Ces popups sont stylisés par le navigateur et offrent une personnalisation limitée.\nAlerts Le plus simple d\u0026rsquo;entre eux est appelé une alerte, qui montre une message personnalisé, et un seul bouton qui rejette l\u0026rsquo;alerte, étiqueté dans la plupart des navigateurs comme OK. Il peut également être ignoré dans la plupart des navigateurs par en appuyant sur le bouton de fermeture, mais cela fera toujours la même chose que le bouton OK. Voir un exemple d\u0026rsquo;alerte.\nWebDriver peut obtenir le texte de la fenêtre contextuelle et les accepter ou les rejeter alertes.\nJava Python C# Ruby JavaScript Kotlin //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See an example alert\u0026#34;)).click(); //Wait for the alert to be displayed and store it in a variable Alert alert = wait.until(ExpectedConditions.alertIsPresent()); //Store the alert text in a variable String text = alert.getText(); //Press the OK button alert.accept();   # Click the link to activate the alert driver.find_element_by_link_text(\u0026#34;See an example alert\u0026#34;).click() # Wait for the alert to be displayed and store it in a variable alert = wait.until(expected_conditions.alert_is_present()) # Store the alert text in a variable text = alert.text # Press the OK button alert.accept()   //Click the link to activate the alert driver.FindElement(By.LinkText(\u0026#34;See an example alert\u0026#34;)).Click(); //Wait for the alert to be displayed and store it in a variable IAlert alert = wait.Until(ExpectedConditions.AlertIsPresent()); //Store the alert text in a variable string text = alert.Text; //Press the OK button alert.Accept();   # Click the link to activate the alert driver.find_element(:link_text, \u0026#39;See an example alert\u0026#39;).click # Store the alert reference in a variable alert = driver.switch_to.alert # Store the alert text in a variable alert_text = alert.text # Press on OK button alert.accept   //Click the link to activate the alert await driver.findElement(By.linkText(\u0026#39;See an example alert\u0026#39;)).click(); // Wait for the alert to be displayed await driver.wait(until.alertIsPresent()); // Store the alert in a variable let alert = await driver.switchTo().alert(); //Store the alert text in a variable let alertText = await alert.getText(); //Press the OK button await alert.accept(); // Note: To use await, the above code should be inside an async function    //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See an example alert\u0026#34;)).click() //Wait for the alert to be displayed and store it in a variable val alert = wait.until(ExpectedConditions.alertIsPresent()) //Store the alert text in a variable val text = alert.getText() //Press the OK button alert.accept()     Confirm Une boîte de confirmation est similaire à une alerte, sauf que l\u0026rsquo;utilisateur peut également choisir pour annuler le message. Voir un échantillon confirme .\nCet exemple montre également une approche différente du stockage d\u0026rsquo;une alerte:\nJava Python C# Ruby JavaScript Kotlin //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample confirm\u0026#34;)).click(); //Wait for the alert to be displayed wait.until(ExpectedConditions.alertIsPresent()); //Store the alert in a variable Alert alert = driver.switchTo().alert(); //Store the alert in a variable for reuse String text = alert.getText(); //Press the Cancel button alert.dismiss();   # Click the link to activate the alert driver.find_element_by_link_text(\u0026#34;See a sample confirm\u0026#34;).click() # Wait for the alert to be displayed wait.until(expected_conditions.alert_is_present()) # Store the alert in a variable for reuse alert = driver.switch_to.alert # Store the alert text in a variable text = alert.text # Press the Cancel button alert.dismiss()   //Click the link to activate the alert driver.FindElement(By.LinkText(\u0026#34;See a sample confirm\u0026#34;)).Click(); //Wait for the alert to be displayed wait.Until(ExpectedConditions.AlertIsPresent()); //Store the alert in a variable IAlert alert = driver.SwitchTo().Alert(); //Store the alert in a variable for reuse string text = alert.Text; //Press the Cancel button alert.Dismiss();   # Click the link to activate the alert driver.find_element(:link_text, \u0026#39;See a sample confirm\u0026#39;).click # Store the alert reference in a variable alert = driver.switch_to.alert # Store the alert text in a variable alert_text = alert.text # Press on Cancel button alert.dismiss   //Click the link to activate the alert await driver.findElement(By.linkText(\u0026#39;See a sample confirm\u0026#39;)).click(); // Wait for the alert to be displayed await driver.wait(until.alertIsPresent()); // Store the alert in a variable let alert = await driver.switchTo().alert(); //Store the alert text in a variable let alertText = await alert.getText(); //Press the Cancel button await alert.dismiss(); // Note: To use await, the above code should be inside an async function    //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample confirm\u0026#34;)).click() //Wait for the alert to be displayed wait.until(ExpectedConditions.alertIsPresent()) //Store the alert in a variable val alert = driver.switchTo().alert() //Store the alert in a variable for reuse val text = alert.text //Press the Cancel button alert.dismiss()     Prompt Les invites sont similaires aux cases de confirmation, sauf qu\u0026rsquo;elles incluent également un texte contribution. Comme pour travailler avec des éléments de formulaire, vous pouvez utiliser WebDriver envoyer des clés pour remplir une réponse. Cela remplacera complètement l\u0026rsquo;espace réservé texte. En appuyant sur le bouton Annuler, aucun texte ne sera envoyé. Voir un exemple d\u0026rsquo;invite .\nJava Python C# Ruby JavaScript Kotlin //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample prompt\u0026#34;)).click(); //Wait for the alert to be displayed and store it in a variable Alert alert = wait.until(ExpectedConditions.alertIsPresent()); //Type your message alert.sendKeys(\u0026#34;Selenium\u0026#34;); //Press the OK button alert.accept();   # Click the link to activate the alert driver.find_element_by_link_text(\u0026#34;See a sample prompt\u0026#34;).click() # Wait for the alert to be displayed wait.until(expected_conditions.alert_is_present()) # Store the alert in a variable for reuse alert = Alert(driver) # Type your message alert.send_keys(\u0026#34;Selenium\u0026#34;) # Press the OK button alert.accept()   //Click the link to activate the alert driver.FindElement(By.LinkText(\u0026#34;See a sample prompt\u0026#34;)).Click(); //Wait for the alert to be displayed and store it in a variable IAlert alert = wait.Until(ExpectedConditions.AlertIsPresent()); //Type your message alert.SendKeys(\u0026#34;Selenium\u0026#34;); //Press the OK button alert.Accept();   # Click the link to activate the alert driver.find_element(:link_text, \u0026#39;See a sample prompt\u0026#39;).click # Store the alert reference in a variable alert = driver.switch_to.alert # Type a message alert.send_keys(\u0026#34;selenium\u0026#34;) # Press on Ok button alert.accept   //Click the link to activate the alert await driver.findElement(By.linkText(\u0026#39;See a sample prompt\u0026#39;)).click(); // Wait for the alert to be displayed await driver.wait(until.alertIsPresent()); // Store the alert in a variable let alert = await driver.switchTo().alert(); //Type your message await alert.sendKeys(\u0026#34;Selenium\u0026#34;); //Press the OK button await alert.accept(); //Note: To use await, the above code should be inside an async function    //Click the link to activate the alert driver.findElement(By.linkText(\u0026#34;See a sample prompt\u0026#34;)).click() //Wait for the alert to be displayed and store it in a variable val alert = wait.until(ExpectedConditions.alertIsPresent()) //Type your message alert.sendKeys(\u0026#34;Selenium\u0026#34;) //Press the OK button alert.accept()     "
},
{
	"uri": "https://selenium.dev/documentation/fr/guidelines_and_recommendations/avoid_sharing_state/",
	"title": "Eviter de partager l&#39;état",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Although mentioned in several places it is worth mentioning again. Ensure tests are isolated from one another.\n Do not share test data. Imagine several tests that each query the database for valid orders before picking one to perform an action on. Should two tests pick up the same order you are likely to get unexpected behaviour.\n Clean up stale data in the application that might be picked up by another test e.g. invalid order records.\n Create a new WebDriver instance per test. This helps ensure test isolation and makes parallelisation simpler.\n  "
},
{
	"uri": "https://selenium.dev/documentation/fr/remote_webdriver/",
	"title": "Remote WebDriver",
	"tags": [],
	"description": "",
	"content": " Remote WebDriver Vous pouvez utiliser WebDriver à distance de la même manière que vous l\u0026rsquo;utiliseriez localement. La principale différence est qu’un WebDriver distant doit être configuré pour qu\u0026rsquo;il puisse exécuter vos tests sur une machine distincte.\nUn WebDriver distant est composé de deux éléments: un client et un serveur. Le client est votre test WebDriver et le serveur est simplement un Servlet Java, qui peut être hébergé sur n\u0026rsquo;importe quel serveur d\u0026rsquo;application JEE moderne.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/worst_practices/performance_testing/",
	"title": "Test de performance",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Performance testing using Selenium and WebDriver is generally not advised. Not because it is incapable but because it is not optimised for the job and you are unlikely to get good results.\nIt may seem ideal to performance test in the context of the user but a suite of WebDriver tests are subjected to many points of external and internal fragility which are beyond your control; for example browser startup speed, speed of HTTP servers, response of third party servers that host JavaScript or CSS, and the instrumentation penalty of the WebDriver implementation itself. Variation at these points will cause variation in your results. It is difficult to separate the difference between the performance of your website and the performance of external resources, and it is also hard to tell what the performance penalty is for using WebDriver in the browser, especially if you are injecting scripts.\nThe other potential attraction is \u0026ldquo;saving time\u0026rdquo; — carrying out functional and performance tests at the same time. However, functional and performance tests have opposing objectives. To test functionality, a tester may need to be patient and wait for loading, but this will cloud the performance testing results and vice versa.\nTo improve the performance of your website, you will need to be able to analyse overall performance independent of environment differences, identify poor code practices, breakdown of performance of individual resources (i.e. CSS or JavaScript) in order to know what to improve. There are performance testing tools available that can do this job already, and which provide reporting and analysis which can even make improvement suggestions.\nExample (open source) packages to use are: JMeter\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/support_packages/working_with_cookies/",
	"title": "Working with cookies",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n A cookie is a small piece of data that is sent from a website and stored in your computer. Cookies are mostly used to recognise the user and load the stored information.\nWebDriver API provides a way to interact with cookies with built-in methods:\nAdd Cookie It is used to add a cookie to the current browsing context. Add Cookie only accepts a set of defined serializable JSON object. Here  is the link to the list of accepted JSON key values\nFirst of all, you need to be on the domain that the cookie will be valid for. If you are trying to preset cookies before you start interacting with a site and your homepage is large / takes a while to load an alternative is to find a smaller page on the site (typically the 404 page is small, e.g. http://example.com/some404page)\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class addCookie { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); // Adds the cookie into current browser context  driver.manage().addCookie(new Cookie(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() driver.get(\u0026#34;http://www.example.com\u0026#34;) # Adds the cookie into current browser context driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;value\u0026#34;})   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace AddCookie { class AddCookie { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); // Adds the cookie into current browser context  driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; # Adds the cookie into current browser context driver.manage.add_cookie(name: \u0026#34;key\u0026#34;, value: \u0026#34;value\u0026#34;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // set a cookie on the current domain  await driver.manage().addCookie({name:\u0026#39;key\u0026#39;, value: \u0026#39;value\u0026#39;}); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) // Adds the cookie into current browser context  driver.manage().addCookie(Cookie(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)); } finally { driver.quit() } }     Get Named Cookie It returns the serialized cookie data matching with the cookie name among all associated cookies.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class getCookieNamed { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); driver.manage().addCookie(new Cookie(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)); // Get cookie details with named cookie \u0026#39;foo\u0026#39;  Cookie cookie1 = driver.manage().getCookieNamed(\u0026#34;foo\u0026#34;); System.out.println(cookie1); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) # Adds the cookie into current browser context driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;bar\u0026#34;}) # Get cookie details with named cookie \u0026#39;foo\u0026#39; print driver.get_cookie(\u0026#34;foo\u0026#34;)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace GetCookieNamed { class GetCookieNamed { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)); // Get cookie details with named cookie \u0026#39;foo\u0026#39;  var cookie = driver.Manage().Cookies.GetCookieNamed(\u0026#34;foo\u0026#34;); System.Console.WriteLine(cookie); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;foo\u0026#34;, value: \u0026#34;bar\u0026#34;) # Get cookie details with named cookie \u0026#39;foo\u0026#39; puts driver.manage.cookie_named(\u0026#39;foo\u0026#39;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // set a cookie on the current domain  await driver.manage().addCookie({name:\u0026#39;foo\u0026#39;, value: \u0026#39;bar\u0026#39;}); // Get cookie details with named cookie \u0026#39;foo\u0026#39;  driver.manage().getCookie(\u0026#39;foo\u0026#39;).then(function (cookie) { console.log(\u0026#39;cookie details =\u0026gt; \u0026#39;, cookie); }); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)); // Get cookie details with named cookie \u0026#39;foo\u0026#39;  val cookie = driver.manage().getCookieNamed(\u0026#34;foo\u0026#34;); println(cookie); } finally { driver.quit() } }     Get All Cookies It returns a ‘successful serialized cookie data’ for current browsing context. If browser is no longer available it returns error.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; import java.util.Set; public class getAllCookies { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); // Add few cookies  driver.manage().addCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Get All available cookies  Set\u0026lt;Cookie\u0026gt; cookies = driver.manage().getCookies(); System.out.println(cookies); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie1\u0026#34;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie2\u0026#34;}) # Get all available cookies print driver.get_cookies()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace GetAllCookies { class GetAllCookies { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Get All available cookies  var cookies = driver.Manage().Cookies.AllCookies; } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;test1\u0026#34;, value: \u0026#34;cookie1\u0026#34;) driver.manage.add_cookie(name: \u0026#34;test2\u0026#34;, value: \u0026#34;cookie2\u0026#34;) # Get all available cookies puts driver.manage.all_cookies ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Add few cookies  await driver.manage().addCookie({name:\u0026#39;test1\u0026#39;, value:\u0026#39;cookie1\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;test2\u0026#39;, value:\u0026#39;cookie2\u0026#39;}); // Get all Available cookies  driver.manage().getCookies().then(function (cookies) { console.log(\u0026#39;cookie details =\u0026gt; \u0026#39;, cookies); }); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // Get All available cookies  val cookies = driver.manage().cookies; println(cookies); } finally { driver.quit() } }     Delete Cookie It deletes the cookie data matching with the provided cookie name.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class deleteCookie { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); driver.manage().addCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); Cookie cookie1 = new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;); driver.manage().addCookie(cookie1); // delete a cookie with name \u0026#39;test1\u0026#39;  driver.manage().deleteCookieNamed(\u0026#34;test1\u0026#34;); /* Selenium Java bindings also provides a way to delete cookie by passing cookie object of current browsing context */ driver.manage().deleteCookie(cookie1); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie1\u0026#34;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie2\u0026#34;}) # Delete a cookie with name \u0026#39;test1\u0026#39; driver.delete_cookie(\u0026#34;test1\u0026#34;)   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace DeleteCookie { class DeleteCookie { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); var cookie = new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;); driver.Manage().Cookies.AddCookie(cookie); // delete a cookie with name \u0026#39;test1\u0026#39;\t driver.Manage().Cookies.DeleteCookieNamed(\u0026#34;test1\u0026#34;); // Selenium .net bindings also provides a way to delete  // cookie by passing cookie object of current browsing context  driver.Manage().Cookies.DeleteCookie(cookie); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;test1\u0026#34;, value: \u0026#34;cookie1\u0026#34;) driver.manage.add_cookie(name: \u0026#34;test2\u0026#34;, value: \u0026#34;cookie2\u0026#34;) # delete a cookie with name \u0026#39;test1\u0026#39; driver.manage.delete_cookie(\u0026#39;test1\u0026#39;) ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Add few cookies  await driver.manage().addCookie({name:\u0026#39;test1\u0026#39;, value:\u0026#39;cookie1\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;test2\u0026#39;, value:\u0026#39;cookie2\u0026#39;}); // Delete a cookie with name \u0026#39;test1\u0026#39;  await driver.manage().deleteCookie(\u0026#39;test1\u0026#39;); // Get all Available cookies  driver.manage().getCookies().then(function (cookies) { console.log(\u0026#39;cookie details =\u0026gt; \u0026#39;, cookies); }); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); val cookie1 = Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;) driver.manage().addCookie(cookie1); // delete a cookie with name \u0026#39;test1\u0026#39;  driver.manage().deleteCookieNamed(\u0026#34;test1\u0026#34;); // delete cookie by passing cookie object of current browsing context.  driver.manage().deleteCookie(cookie1); } finally { driver.quit() } }     Delete All Cookies It deletes all the cookies of the current browsing context.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class deleteAllCookies { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.example.com\u0026#34;); driver.manage().addCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // deletes all cookies  driver.manage().deleteAllCookies(); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() # Navigate to url driver.get(\u0026#34;http://www.example.com\u0026#34;) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie1\u0026#34;}) driver.add_cookie({\u0026#34;name\u0026#34;: \u0026#34;test2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;cookie2\u0026#34;}) # Deletes all cookies driver.delete_all_cookies()   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace DeleteAllCookies { class DeleteAllCookies { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.Manage().Cookies.AddCookie(new Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // deletes all cookies  driver.Manage().Cookies.DeleteAllCookies(); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.example.com\u0026#39; driver.manage.add_cookie(name: \u0026#34;test1\u0026#34;, value: \u0026#34;cookie1\u0026#34;) driver.manage.add_cookie(name: \u0026#34;test2\u0026#34;, value: \u0026#34;cookie2\u0026#34;) # deletes all cookies driver.manage.delete_all_cookies ensure driver.quit end   const {Builder} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Add few cookies  await driver.manage().addCookie({name:\u0026#39;test1\u0026#39;, value:\u0026#39;cookie1\u0026#39;}); await driver.manage().addCookie({name:\u0026#39;test2\u0026#39;, value:\u0026#39;cookie2\u0026#39;}); // Delete all cookies  await driver.manage().deleteAllCookies(); })();   import org.openqa.selenium.Cookie import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) driver.manage().addCookie(Cookie(\u0026#34;test1\u0026#34;, \u0026#34;cookie1\u0026#34;)); driver.manage().addCookie(Cookie(\u0026#34;test2\u0026#34;, \u0026#34;cookie2\u0026#34;)); // deletes all cookies  driver.manage().deleteAllCookies(); } finally { driver.quit() } }     "
},
{
	"uri": "https://selenium.dev/documentation/fr/guidelines_and_recommendations/test_independency/",
	"title": "Indépendence des tests",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Write each test as its own unit. Write the tests in a way that will not be reliant on other tests to complete:\nLet us say there is a content management system with which you can create some custom content which then appears on your website as a module after publishing, and it may take some time to sync between the CMS and the application.\nA wrong way of testing your module is that the content is created and published in one test, and then checking the module in another test. This is not feasible as the content may not be available immediately for the other test after publishing.\nInstead, you can create a stub content which can be turned on and off within the affected test, and use that for validating the module. However, for content creation, you can still have a separate test.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/guidelines_and_recommendations/",
	"title": "Lignes directrices et recommendations",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Guidelines and recommendations A note on \u0026ldquo;Best Practices\u0026rdquo;: We\u0026rsquo;ve intentionally avoided the phrase \u0026ldquo;Best Practices\u0026rdquo; in this documentation. No one approach works for all situations. We prefer the idea of \u0026ldquo;Guidelines and Recommendations\u0026rdquo;. We encourage you to read through these and thoughtfully decide what approaches will work for you in your particular environment.\nFunctional testing is difficult to get right for many reasons. As if application state, complexity, and dependencies do not make testing difficult enough, dealing with browsers (especially with cross-browser incompatibilities) makes writing good tests a challenge.\nSelenium provides tools to make functional user interaction easier, but does not help you write well-architected test suites. In this chapter we offer advice, guidelines, and recommendations. on how to approach functional web page automation.\nThis chapter records software design patterns popular amongst many of the users of Selenium that have proven successful over the years.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/worst_practices/link_spidering/",
	"title": "Link spidering",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Using WebDriver to spider through links is not a recommended practice not because it cannot be done, but because it’s definitely not the most ideal tool. WebDriver needs time to start up, and can take several seconds up to a minute depending on how your test is written, just to get to the page and traverse through the DOM.\nInstead of using WebDriver for this, you could save a ton of time by executing a curl command, or using a library such as BeautifulSoup since these methods don’t rely on creating a browser and navigating to a page. You are saving tonnes of time by not using WebDriver for this task.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/webdriver/http_proxies/",
	"title": "Proxys HTTP",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n "
},
{
	"uri": "https://selenium.dev/documentation/fr/guidelines_and_recommendations/consider_using_a_fluent_api/",
	"title": "Considerer l&#39;utilisation d&#39;une API fluent",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Martin Fowler coined the term \u0026ldquo;Fluent API\u0026rdquo;. Selenium already implements something like this in their FluentWait class, which is meant as an alternative to the standard Wait class. You could enable the Fluent API design pattern in your page object and then query the Google search page with a code snippet like this one:\ndriver.get( \u0026#34;http://www.google.com/webhp?hl=en\u0026amp;amp;tab=ww\u0026#34; ); GoogleSearchPage gsp = new GoogleSearchPage(); gsp.withFluent().setSearchString().clickSearchButton(); The Google page object class with this fluent behavior might look like this:\npublic class GoogleSearchPage extends LoadableComponent\u0026lt;GoogleSearchPage\u0026gt; { private final WebDriver driver; private GSPFluentInterface gspfi; public class GSPFluentInterface { private GoogleSearchPage gsp; public GSPFluentInterface(GoogleSearchPage googleSearchPage) { gsp = googleSearchPage; } public GSPFluentInterface clickSearchButton() { gsp.searchButton.click(); return this; } public GSPFluentInterface setSearchString( String sstr ) { clearAndType( gsp.searchField, sstr ); return this; } } @FindBy(id = \u0026#34;gbqfq\u0026#34;) private WebElement searchField; @FindBy(id = \u0026#34;gbqfb\u0026#34;) private WebElement searchButton; public GoogleSearchPage(WebDriver driver) { gspfi = new GSPFluentInterface( this ); this.get(); // If load() fails, calls isLoaded() until page is finished loading  PageFactory.initElements(driver, this); // Initialize WebElements on page  } public GSPFluentInterface withFluent() { return gspfi; } public void clickSearchButton() { searchButton.click(); } public void setSearchString( String sstr ) { clearAndType( searchField, sstr ); } @Override protected void isLoaded() throws Error { Assert.assertTrue(\u0026#34;Google search page is not yet loaded.\u0026#34;, isSearchFieldVisible() ); } @Override protected void load() { if ( isSFieldPresent ) { Wait\u0026lt;WebDriver\u0026gt; wait = new WebDriverWait( driver, Duration.ofSeconds(3) ); wait.until( visibilityOfElementLocated( By.id(\u0026#34;gbqfq\u0026#34;) ) ).click(); } } }"
},
{
	"uri": "https://selenium.dev/documentation/fr/worst_practices/",
	"title": "Mauvaises pratiques",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Worst practices "
},
{
	"uri": "https://selenium.dev/documentation/fr/webdriver/page_loading_strategy/",
	"title": "Stratégie de chargement de la page",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Defines the current session\u0026rsquo;s page loading strategy. By default, when Selenium WebDriver loads a page, it follows the normal pageLoadStrategy. It is always recommended to stop downloading additional resources (like images, css, js) when the page loading takes lot of time.\nWebDriver pageLoadStrategy supports the following values:\nnormal This will make Selenium WebDriver to wait for the entire page is loaded. When set to normal, Selenium WebDriver waits until the load event fire is returned.\nBy default normal is set to browser if none is provided.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.PageLoadStrategy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeOptions; import org.openqa.selenium.chrome.ChromeDriver; public class pageLoadStrategy { public static void main(String[] args) { ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setPageLoadStrategy(PageLoadStrategy.NORMAL); WebDriver driver = new ChromeDriver(chromeOptions); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); } finally { driver.quit(); } } }   # Please raise a PR   // Please raise a PR    require \u0026#39;selenium-webdriver\u0026#39; caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.page_load_strategy=\u0026#39;normal\u0026#39; driver = Selenium::WebDriver.for :chrome, :desired_capabilities =\u0026gt; caps driver.get(\u0026#39;https://www.google.com\u0026#39;)   const {Builder, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); const caps = new Capabilities(); caps.setPageLoadStrategy(\u0026#34;normal\u0026#34;); (async function example() { let driver = await new Builder(). withCapabilities(caps). forBrowser(\u0026#39;chrome\u0026#39;). build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.PageLoadStrategy import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions fun main() { val chromeOptions = ChromeOptions() chromeOptions.setPageLoadStrategy(PageLoadStrategy.NORMAL) val driver = ChromeDriver(chromeOptions) try { driver.get(\u0026#34;https://www.google.com\u0026#34;) } finally { driver.quit() } }     eager This will make Selenium WebDriver to wait until the initial HTML document has been completely loaded and parsed, and discards loading of stylesheets, images and subframes.\nWhen set to eager, Selenium WebDriver waits until DOMContentLoaded event fire is returned.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.PageLoadStrategy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeOptions; import org.openqa.selenium.chrome.ChromeDriver; public class pageLoadStrategy { public static void main(String[] args) { ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setPageLoadStrategy(PageLoadStrategy.EAGER); WebDriver driver = new ChromeDriver(chromeOptions); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); } finally { driver.quit(); } } }   # Please raise a PR   // Please raise a PR    require \u0026#39;selenium-webdriver\u0026#39; caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.page_load_strategy=\u0026#39;eager\u0026#39; driver = Selenium::WebDriver.for :chrome, :desired_capabilities =\u0026gt; caps driver.get(\u0026#39;https://www.google.com\u0026#39;)   const {Builder, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); const caps = new Capabilities(); caps.setPageLoadStrategy(\u0026#34;eager\u0026#34;); (async function example() { let driver = await new Builder(). withCapabilities(caps). forBrowser(\u0026#39;chrome\u0026#39;). build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.PageLoadStrategy import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions fun main() { val chromeOptions = ChromeOptions() chromeOptions.setPageLoadStrategy(PageLoadStrategy.EAGER) val driver = ChromeDriver(chromeOptions) try { driver.get(\u0026#34;https://www.google.com\u0026#34;) } finally { driver.quit() } }     none When set to none Selenium WebDriver only waits until the initial page is downloaded.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.PageLoadStrategy; import org.openqa.selenium.WebDriver; import org.openqa.selenium.chrome.ChromeOptions; import org.openqa.selenium.chrome.ChromeDriver; public class pageLoadStrategy { public static void main(String[] args) { ChromeOptions chromeOptions = new ChromeOptions(); chromeOptions.setPageLoadStrategy(PageLoadStrategy.NONE); WebDriver driver = new ChromeDriver(chromeOptions); try { // Navigate to Url  driver.get(\u0026#34;https://google.com\u0026#34;); } finally { driver.quit(); } } }   # Please raise a PR   // Please raise a PR    require \u0026#39;selenium-webdriver\u0026#39; caps = Selenium::WebDriver::Remote::Capabilities.chrome caps.page_load_strategy=\u0026#39;none\u0026#39; driver = Selenium::WebDriver.for :chrome, :desired_capabilities =\u0026gt; caps driver.get(\u0026#39;https://www.google.com\u0026#39;)   const {Builder, Capabilities} = require(\u0026#39;selenium-webdriver\u0026#39;); const caps = new Capabilities(); caps.setPageLoadStrategy(\u0026#34;none\u0026#34;); (async function example() { let driver = await new Builder(). withCapabilities(caps). forBrowser(\u0026#39;chrome\u0026#39;). build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); } finally { await driver.quit(); } })();   import org.openqa.selenium.PageLoadStrategy import org.openqa.selenium.chrome.ChromeDriver import org.openqa.selenium.chrome.ChromeOptions fun main() { val chromeOptions = ChromeOptions() chromeOptions.setPageLoadStrategy(PageLoadStrategy.NONE) val driver = ChromeDriver(chromeOptions) try { driver.get(\u0026#34;https://www.google.com\u0026#34;) } finally { driver.quit() } }     "
},
{
	"uri": "https://selenium.dev/documentation/fr/grid/",
	"title": "Grid",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Grid Selenium Grid is a smart proxy server that allows Selenium tests to route commands to remote web browser instances. Its aim is to provide an easy way to run tests in parallel on multiple machines.\nWith Selenium Grid, one server acts as the hub that routes JSON formatted test commands to one or more registered Grid nodes. Tests contact the hub to obtain access to remote browser instances. The hub has a list of registered servers that it provides access to, and allows control of these instances.\nSelenium Grid allows us to run tests in parallel on multiple machines, and to manage different browser versions and browser configurations centrally (instead of in each individual test).\nSelenium Grid is not a silver bullet. It solves a subset of common delegation and distribution problems, but will for example not manage your infrastructure, and might not suit your specific needs.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/guidelines_and_recommendations/fresh_browser_per_test/",
	"title": "Nouveau navigateur par test",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Start each test from a clean known state. Ideally, spin up a new virtual machine for each test. If spinning up a new virtual machine is not practical, at least start a new WebDriver for each test. For Firefox, start a WebDriver with your known profile.\nFirefoxProfile profile = new FirefoxProfile(new File(\u0026#34;pathToFirefoxProfile\u0026#34;)); WebDriver driver = new FirefoxDriver(profile);"
},
{
	"uri": "https://selenium.dev/documentation/fr/webdriver/web_element/",
	"title": "Web element",
	"tags": [],
	"description": "",
	"content": " WebElement représente un élément DOM. Les WebElements peuvent être trouvés en recherchant racine du document à l\u0026rsquo;aide d\u0026rsquo;une instance WebDriver ou en recherchant sous une autre WebElement\nL\u0026rsquo;API WebDriver fournit des méthodes intégrées pour trouver les WebElements qui sont basé sur différentes propriétés comme ID, nom, classe, XPath, sélecteurs CSS, texte de lien, etc.\nFind Element Il est utilisé pour rechercher un élément et renvoie une première référence WebElement unique correspondante, qui peut être utilisé pour de futures actions d\u0026rsquo;élément\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); driver.get(\u0026#34;http://www.google.com\u0026#34;); // Get search box element from webElement \u0026#39;q\u0026#39; using Find Element WebElement searchBox = driver.findElement(By.name(\u0026#34;q\u0026#34;)); searchBox.sendKeys(\u0026#34;webdriver\u0026#34;);   driver = Firefox() driver.get(\u0026#34;http://www.google.com\u0026#34;) # Get search box element from webElement \u0026#39;q\u0026#39; using Find Element search_box = driver.find_element_by_name(\u0026#34;q\u0026#34;) search_box.send_keys(\u0026#34;webdriver\u0026#34;)   IWebDriver driver = new FirefoxDriver(); driver.Url = \u0026#34;http://www.google.com\u0026#34;; // Get search box element from webElement \u0026#39;q\u0026#39; using Find Element IWebElement searchbox = driver.FindElement(By.Name(\u0026#34;q\u0026#34;)); searchbox.SendKeys(\u0026#34;webdriver\u0026#34;);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; # Get search box element from webElement \u0026#39;q\u0026#39; using Find Element search_bar = driver.find_element(name: \u0026#39;q\u0026#39;) # Perform action using WebElement search_bar.send_keys \u0026#39;Webdriver\u0026#39; ensure driver.quit end   let {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); driver = new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); (async function test(){ //Navigate to url await driver.get(\u0026#39;http://www.google.com\u0026#39;); // Get search box element from webElement \u0026#39;q\u0026#39; using Find Element let searchBar = driver.findElement(By.name(\u0026#39;q\u0026#39;)); //Perform action using WebElement await searchBar.sendKeys(\u0026#39;Webdriver\u0026#39;); })();   val driver = FirefoxDriver() driver.get(\u0026#34;http://www.google.com\u0026#34;) // Get search box element from webElement \u0026#39;q\u0026#39; using Find Element val searchBox = driver.findElement(By.name(\u0026#34;q\u0026#34;)) searchBox.sendKeys(\u0026#34;webdriver\u0026#34;)     Find Elements Similaire à \u0026ldquo;Rechercher un élément\u0026rdquo;, mais renvoie une liste de WebElements correspondants. Pour utiliser un WebElement particulier de la liste, vous devez parcourir la liste des éléments pour effectuer une action sur l\u0026rsquo;élément sélectionné.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.firefox.FirefoxDriver; import java.util.List; public class findElementsExample { public static void main(String[] args) { WebDriver driver = new FirefoxDriver(); try { driver.get(\u0026#34;https://example.com\u0026#34;); // Get all the elements available with tag name \u0026#39;p\u0026#39;  List\u0026lt;WebElement\u0026gt; elements = driver.findElements(By.tagName(\u0026#34;p\u0026#34;)); for (WebElement element : elements) { System.out.println(\u0026#34;Paragraph text:\u0026#34; + element.getText()); } } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Firefox() # Navigate to Url driver.get(\u0026#34;https://www.example.com\u0026#34;) # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = driver.find_elements_by_tag_name(\u0026#39;p\u0026#39;) for e in elements: print e.text   using OpenQA.Selenium; using OpenQA.Selenium.Firefox; using System.Collections.Generic; namespace FindElementsExample { class FindElementsExample { public static void Main(string[] args) { IWebDriver driver = new FirefoxDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); // Get all the elements available with tag name \u0026#39;p\u0026#39;  IList \u0026lt; IWebElement \u0026gt; elements = driver.FindElements(By.TagName(\u0026#34;p\u0026#34;)); foreach(IWebElement e in elements) { System.Console.WriteLine(e.Text); } } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;https://www.example.com\u0026#39; # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = driver.find_elements(:tag_name,\u0026#39;p\u0026#39;) elements.each { |e| puts e.text } ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Get all the elements available with tag name \u0026#39;p\u0026#39;  let elements = await driver.findElements(By.tagName(\u0026#39;p\u0026#39;)); for(let e of elements) { console.log(await e.getText()); } } finally { await driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.firefox.FirefoxDriver fun main() { val driver = FirefoxDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) // Get all the elements available with tag name \u0026#39;p\u0026#39;  val elements = driver.findElements(By.tagName(\u0026#34;p\u0026#34;)) for (element in elements) { println(\u0026#34;Paragraph text:\u0026#34; + element.text) } } finally { driver.quit() } }     Find Element From Element Il est utilisé pour rechercher un élément enfant dans le contexte de l\u0026rsquo;élément parent. Pour ce faire, le WebElement parent est chaîné avec \u0026lsquo;findElement\u0026rsquo; pour accéder aux éléments enfants\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new FirefoxDriver(); driver.get(\u0026#34;http://www.google.com\u0026#34;); WebElement searchForm = driver.findElement(By.tagName(\u0026#34;form\u0026#34;)); WebElement searchBox = searchForm.findElement(By.name(\u0026#34;q\u0026#34;)); searchBox.sendKeys(\u0026#34;webdriver\u0026#34;);   driver = Firefox() driver.get(\u0026#34;http://www.google.com\u0026#34;) search_form = driver.find_element_by_tag_name(\u0026#34;form\u0026#34;) search_box = search_form.find_element_by_name(\u0026#34;q\u0026#34;) search_box.send_keys(\u0026#34;webdriver\u0026#34;)   IWebDriver driver = new FirefoxDriver(); driver.Url = \u0026#34;http://www.google.com\u0026#34;; IWebElement searchForm = driver.FindElement(By.TagName(\u0026#34;form\u0026#34;)); IWebElement searchbox = searchForm.FindElement(By.Name(\u0026#34;q\u0026#34;)); searchbox.SendKeys(\u0026#34;webdriver\u0026#34;);   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox begin # Navigate to URL driver.get \u0026#39;https://google.com\u0026#39; # Get and store DOM element \u0026#39;\u0026lt;form\u0026gt;\u0026#39; search_form = driver.find_element(name: \u0026#39;f\u0026#39;) # Get search box element from webElement \u0026#39;form\u0026#39; search_bar = search_form.find_element(name: \u0026#39;q\u0026#39;) # Perform action using WebElement search_bar.send_keys \u0026#39;Webdriver\u0026#39; ensure driver.quit end   let {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); driver = new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); (async function test(){ //Navigate to url await driver.get(\u0026#39;http://www.google.com\u0026#39;); //Get and store DOM element \u0026#39;\u0026lt;form\u0026gt;\u0026#39; let searchForm = driver.findElement(By.name(\u0026#39;f\u0026#39;)); //Get search box element from webElement \u0026#39;form\u0026#39; let searchBar = searchForm.findElement(By.name(\u0026#39;q\u0026#39;)); //Perform action using WebElement await searchBar.sendKeys(\u0026#39;Webdriver\u0026#39;); })();   val driver = FirefoxDriver() driver.get(\u0026#34;http://www.google.com\u0026#34;) val searchForm = driver.findElement(By.tagName(\u0026#34;form\u0026#34;)) val searchBox = searchForm.findElement(By.name(\u0026#34;q\u0026#34;)) searchBox.sendKeys(\u0026#34;webdriver\u0026#34;)     Find Elements From Element Il est utilisé pour rechercher la liste des WebElements enfants correspondants dans le contexte de l\u0026rsquo;élément parent. Pour ce faire, le WebElement parent est chaîné avec \u0026ldquo;findElements\u0026rdquo; pour accéder aux éléments enfants\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import java.util.List; public class findElementsFromElement { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;https://example.com\u0026#34;); // Get element with tag name \u0026#39;div\u0026#39;  WebElement element = driver.findElement(By.tagName(\u0026#34;div\u0026#34;)); // Get all the elements available with tag name \u0026#39;p\u0026#39;  List\u0026lt;WebElement\u0026gt; elements = element.findElements(By.tagName(\u0026#34;p\u0026#34;)); for (WebElement e : elements) { System.out.println(e.getText()); } } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() driver.get(\u0026#34;https://www.example.com\u0026#34;) # Get element with tag name \u0026#39;div\u0026#39; element = driver.find_element_by_tag_name(\u0026#39;div\u0026#39;) # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = element.find_elements_by_tag_name(\u0026#39;p\u0026#39;) for e in elements: print e.text   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; using System.Collections.Generic; namespace FindElementsFromElement { class FindElementsFromElement { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { driver.Navigate().GoToUrl(\u0026#34;https://example.com\u0026#34;); // Get element with tag name \u0026#39;div\u0026#39;  IWebElement element = driver.FindElement(By.TagName(\u0026#34;div\u0026#34;)); // Get all the elements available with tag name \u0026#39;p\u0026#39;  IList \u0026lt; IWebElement \u0026gt; elements = element.FindElements(By.TagName(\u0026#34;p\u0026#34;)); foreach(IWebElement e in elements) { System.Console.WriteLine(e.Text); } } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin # Navigate to URL driver.get \u0026#39;https://www.example.com\u0026#39; # Get element with tag name \u0026#39;div\u0026#39; element = driver.find_element(:tag_name,\u0026#39;div\u0026#39;) # Get all the elements available with tag name \u0026#39;p\u0026#39; elements = element.find_elements(:tag_name,\u0026#39;p\u0026#39;) elements.each { |e| puts e.text } ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = new Builder() .forBrowser(\u0026#39;chrome\u0026#39;) .build(); await driver.get(\u0026#39;https://www.example.com\u0026#39;); // Get element with tag name \u0026#39;div\u0026#39;  let element = driver.findElement(By.tagName(\u0026#34;div\u0026#34;)); // Get all the elements available with tag name \u0026#39;p\u0026#39;  let elements = await element.findElements(By.tagName(\u0026#34;p\u0026#34;)); for(let e of elements) { console.log(await e.getText()); } })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://example.com\u0026#34;) // Get element with tag name \u0026#39;div\u0026#39;  val element = driver.findElement(By.tagName(\u0026#34;div\u0026#34;)) // Get all the elements available with tag name \u0026#39;p\u0026#39;  val elements = element.findElements(By.tagName(\u0026#34;p\u0026#34;)) for (e in elements) { println(e.text) } } finally { driver.quit() } }     Get Active Element Il est utilisé pour suivre (ou) trouver l\u0026rsquo;élément DOM qui a le focus dans le contexte de navigation actuel.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.*; import org.openqa.selenium.chrome.ChromeDriver; public class activeElementTest { public static void main(String[] args) { WebDriver driver = new ChromeDriver(); try { driver.get(\u0026#34;http://www.google.com\u0026#34;); driver.findElement(By.cssSelector(\u0026#34;[name=\u0026#39;q\u0026#39;]\u0026#34;)).sendKeys(\u0026#34;webElement\u0026#34;); // Get attribute of current active element  String attr = driver.switchTo().activeElement().getAttribute(\u0026#34;title\u0026#34;); System.out.println(attr); } finally { driver.quit(); } } }   from selenium import webdriver driver = webdriver.Chrome() driver.get(\u0026#34;https://www.google.com\u0026#34;) driver.find_element_by_css_selector(\u0026#39;[name=\u0026#34;q\u0026#34;]\u0026#39;).send_keys(\u0026#34;webElement\u0026#34;) # Get attribute of current active element attr = driver.switch_to.active_element.get_attribute(\u0026#34;title\u0026#34;) print attr   using OpenQA.Selenium; using OpenQA.Selenium.Chrome; namespace ActiveElement { class ActiveElement { public static void Main(string[] args) { IWebDriver driver = new ChromeDriver(); try { // Navigate to Url  driver.Navigate().GoToUrl(\u0026#34;https://www.google.com\u0026#34;); driver.FindElement(By.CssSelector(\u0026#34;[name=\u0026#39;q\u0026#39;]\u0026#34;)).SendKeys(\u0026#34;webElement\u0026#34;); // Get attribute of current active element  string attr = driver.SwitchTo().ActiveElement().GetAttribute(\u0026#34;title\u0026#34;); System.Console.WriteLine(attr); } finally { driver.Quit(); } } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :chrome begin driver.get \u0026#39;https://www.google.com\u0026#39; driver.find_element(css: \u0026#39;[name=\u0026#34;q\u0026#34;]\u0026#39;).send_keys(\u0026#39;webElement\u0026#39;) # Get attribute of current active element attr = driver.switch_to.active_element.attribute(\u0026#39;title\u0026#39;) puts attr ensure driver.quit end   const {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build(); await driver.get(\u0026#39;https://www.google.com\u0026#39;); await driver.findElement(By.css(\u0026#39;[name=\u0026#34;q\u0026#34;]\u0026#39;)).sendKeys(\u0026#34;webElement\u0026#34;); // Get attribute of current active element  let attr = await driver.switchTo().activeElement().getAttribute(\u0026#34;title\u0026#34;); console.log(`${attr}`) })();   import org.openqa.selenium.By import org.openqa.selenium.chrome.ChromeDriver fun main() { val driver = ChromeDriver() try { driver.get(\u0026#34;https://www.google.com\u0026#34;) driver.findElement(By.cssSelector(\u0026#34;[name=\u0026#39;q\u0026#39;]\u0026#34;)).sendKeys(\u0026#34;webElement\u0026#34;) // Get attribute of current active element  val attr = driver.switchTo().activeElement().getAttribute(\u0026#34;title\u0026#34;); print(attr); } finally { driver.quit() } }     "
},
{
	"uri": "https://selenium.dev/documentation/fr/webdriver/keyboard/",
	"title": "Clavier",
	"tags": [],
	"description": "",
	"content": " Le clavier représente un événement KeyBoard. Les actions du clavier sont effectuées à l\u0026rsquo;aide de bas niveau interface qui nous permet de fournir une entrée d\u0026rsquo;appareil virtualisé au navigateur Web.\nsendKeys SendKeys tape une séquence de touches dans l\u0026rsquo;élément DOM même si une séquence de touches de modification est rencontrée.\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By;\rimport org.openqa.selenium.Keys;\rimport org.openqa.selenium.WebDriver;\rimport org.openqa.selenium.firefox.FirefoxDriver;\rpublic class HelloSelenium {\rpublic static void main(String[] args) {\rWebDriver driver = new FirefoxDriver();\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;);\r// Enter text \u0026#34;q\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;q\u0026#34; + Keys.ENTER);\r} finally {\rdriver.quit();\r}\r}\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.keys import Keys\rdriver = webdriver.Firefox()\r# Navigate to url\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.find_element_by_name(\u0026#34;q\u0026#34;).send_keys(\u0026#34;webdriver\u0026#34;+Keys.ENTER)\r \rusing (var driver = new FirefoxDriver())\r{\r// Navigate to Url\r driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;);\r// Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;webdriver\u0026#34; + Keys.Enter);\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :firefox\rbegin\r# Navigate to URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;webdriver\u0026#39;, :return\rensure\rdriver.quit\rend\r \rconst {Builder, By, Key} = require(\u0026#39;selenium-webdriver\u0026#39;);\r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build();\rtry {\r// Navigate to Url\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Enter text \u0026#34;webdriver\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;\r await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;webdriver\u0026#39;, Key.ENTER);\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.Keys\rimport org.openqa.selenium.firefox.FirefoxDriver\rfun main() {\rval driver = FirefoxDriver()\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;)\r// Enter text \u0026#34;q\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;q\u0026#34; + Keys.ENTER)\r} finally {\rdriver.quit()\r}\r}\r \r  keyDown Le keyDown est utilisé pour simuler l\u0026rsquo;action d\u0026rsquo;appuyer sur une touche de modification (CONTROL, SHIFT, ALT)\nJava Python C# Ruby JavaScript Kotlin WebDriver driver = new ChromeDriver();\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;);\r// Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;webdriver\u0026#34; + Keys.ENTER);\rActions actionProvider = new Actions(driver);\rAction keydown = actionProvider.keyDown(Keys.CONTROL).sendKeys(\u0026#34;a\u0026#34;).build();\rkeydown.perform();\r} finally {\rdriver.quit();\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.keys import Keys\rdriver = webdriver.Chrome()\r# Navigate to url\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.find_element_by_name(\u0026#34;q\u0026#34;).send_keys(\u0026#34;webdriver\u0026#34;+Keys.ENTER)\r# Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r webdriver.ActionChains(driver).key_down(Keys.CONTROL).send_keys(\u0026#34;a\u0026#34;).perform()\r \rIWebDriver driver = new ChromeDriver();\rtry\r{\r// Navigate to Url\r driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;);\r// Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;webdriver\u0026#34; + Keys.Enter);\r// Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r Actions actionProvider = new Actions(driver);\rIAction keydown = actionProvider.KeyDown(Keys.Control).SendKeys(\u0026#34;a\u0026#34;).Build();\rkeydown.Perform();\r}\rfinally\r{\rdriver.Quit();\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :chrome\rbegin\r# Navigate to URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;webdriver\u0026#39;, :return\r# Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r driver.action.key_down(:control).send_keys(\u0026#39;a\u0026#39;).perform\rensure\rdriver.quit\rend\r \r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build();\rtry {\r// Navigate to Url\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Enter text \u0026#34;webdriver\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;\r await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;webdriver\u0026#39;, Key.ENTER);\r// Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r await driver.actions().keyDown(Key.CONTROL).sendKeys(\u0026#39;a\u0026#39;).perform();\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.Keys\rimport org.openqa.selenium.chrome.ChromeDriver\rimport org.openqa.selenium.interactions.Actions\rfun main() {\rval driver = ChromeDriver()\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;)\r// Enter \u0026#34;webdriver\u0026#34; text and perform \u0026#34;ENTER\u0026#34; keyboard action\r driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;webdriver\u0026#34; + Keys.ENTER)\rval action = Actions(driver)\r// Perform action ctrl + A (modifier CONTROL + Alphabet A) to select the page\r action.keyDown(Keys.CONTROL).sendKeys(\u0026#34;a\u0026#34;).build().perform();\r} finally {\rdriver.quit()\r}\r}\r \r  keyUp Le keyUp est utilisé pour simuler l\u0026rsquo;action de relâchement (ou) de relâchement de touche d\u0026rsquo;une touche de modification (CONTROL, SHIFT, ALT)\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By;\rimport org.openqa.selenium.Keys;\rimport org.openqa.selenium.WebDriver;\rimport org.openqa.selenium.WebElement;\rimport org.openqa.selenium.firefox.FirefoxDriver;\rimport org.openqa.selenium.interactions.Actions;\rpublic class HelloSelenium {\rpublic static void main(String[] args) {\rWebDriver driver = new FirefoxDriver();\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;);\rActions action = new Actions(driver);\r// Store google search box WebElement\r WebElement search = driver.findElement(By.name(\u0026#34;q\u0026#34;));\r// Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r action.keyDown(Keys.SHIFT).sendKeys(search,\u0026#34;qwerty\u0026#34;).keyUp(Keys.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).perform();\r} finally {\rdriver.quit();\r}\r}\r}\r \rfrom selenium import webdriver\rfrom selenium.webdriver.common.keys import Keys\rdriver = webdriver.Chrome()\r# Navigate to url\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Store google search box WebElement\r search = driver.find_element_by_name(\u0026#34;q\u0026#34;)\raction = webdriver.ActionChains(driver)\r# Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r action.key_down(Keys.SHIFT).send_keys_to_element(search, \u0026#34;qwerty\u0026#34;).key_up(Keys.SHIFT).send_keys(\u0026#34;qwerty\u0026#34;).perform()\r \rusing OpenQA.Selenium;\rusing OpenQA.Selenium.Chrome;\rusing OpenQA.Selenium.Interactions;\rnamespace HelloSelenium\r{\rclass HelloSelenium\r{\rpublic static void Main(string[] args)\r{\rIWebDriver driver = new ChromeDriver();\rtry\r{\r// Navigate to Url\r driver.Navigate().GoToUrl(\u0026#34;https://google.com\u0026#34;);\rActions action = new Actions(driver);\r// Store google search box WebElement\r IWebElement search = driver.FindElement(By.Name(\u0026#34;q\u0026#34;));\r// Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r action.KeyDown(Keys.Shift).SendKeys(search, \u0026#34;qwerty\u0026#34;).KeyUp(Keys.Shift).SendKeys(\u0026#34;qwerty\u0026#34;).Perform();\r}\rfinally {\rdriver.Quit();\r}\r}\r}\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :chrome\rbegin\r# Navigate to URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# Store google search box WebElement\r search = driver.find_element(name: \u0026#39;q\u0026#39;)\r# Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r driver.action.key_down(:shift).send_keys(search,\u0026#39;qwerty\u0026#39;).key_up(:shift).send_keys(\u0026#34;qwerty\u0026#34;).perform\rensure\rdriver.quit\rend\r \rconst {Builder, By, Key} = require(\u0026#39;selenium-webdriver\u0026#39;);\r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build();\rtry {\r// Navigate to Url\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Store google search box WebElement\r let search = driver.findElement(By.name(\u0026#39;q\u0026#39;));\r// Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r await driver.actions().click(search).keyDown(Key.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).keyUp(Key.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).perform();\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.Keys\rimport org.openqa.selenium.chrome.ChromeDriver\rimport org.openqa.selenium.interactions.Actions\rfun main() {\rval driver = ChromeDriver()\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://google.com\u0026#34;)\r// Store google search box WebElement\r val search = driver.findElement(By.name(\u0026#34;q\u0026#34;))\rval action = Actions(driver)\r// Enters text \u0026#34;qwerty\u0026#34; with keyDown SHIFT key and after keyUp SHIFT key (QWERTYqwerty)\r action.keyDown(Keys.SHIFT).sendKeys(search, \u0026#34;qwerty\u0026#34;).keyUp(Keys.SHIFT).sendKeys(\u0026#34;qwerty\u0026#34;).build().perform();\r} finally {\rdriver.quit()\r}\r}\r \r  clear Efface le contenu d\u0026rsquo;un élément modifiable. Ceci n\u0026rsquo;est appliqué qu\u0026rsquo;aux éléments modifiables et interactifs, sinon le sélénium renvoie l\u0026rsquo;erreur (état d\u0026rsquo;élément invalide (ou) élément non interactif)\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By;\rimport org.openqa.selenium.WebDriver;\rimport org.openqa.selenium.WebElement;\rimport org.openqa.selenium.chrome.ChromeDriver;\rpublic class clear {\rpublic static void main(String[] args) {\rWebDriver driver = new ChromeDriver();\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://www.google.com\u0026#34;);\r// Store \u0026#39;SearchInput\u0026#39; element\r WebElement searchInput = driver.findElement(By.name(\u0026#34;q\u0026#34;));\rsearchInput.sendKeys(\u0026#34;selenium\u0026#34;);\r// Clears the entered text\r searchInput.clear();\r} finally {\rdriver.quit();\r}\r}\r}\r \rfrom selenium import webdriver\rdriver = webdriver.Chrome()\r# Navigate to url\r driver.get(\u0026#34;http://www.google.com\u0026#34;)\r# Store \u0026#39;SearchInput\u0026#39; element\r SearchInput = driver.find_element_by_name(\u0026#34;q\u0026#34;)\rSearchInput.send_keys(\u0026#34;selenium\u0026#34;)\r# Clears the entered text\r SearchInput.clear()\r \rusing OpenQA.Selenium;\rusing OpenQA.Selenium.Chrome;\rusing System;\rnamespace SnipetProjectDelete\r{\rclass Program\r{\rstatic void Main(string[] args)\r{\rIWebDriver driver = new ChromeDriver();\rtry\r{\r// Navigate to Url\r driver.Navigate().GoToUrl(@\u0026#34;https://www.google.com\u0026#34;);\r// Store \u0026#39;SearchInput\u0026#39; element\r IWebElement searchInput = driver.FindElement(By.Name(\u0026#34;q\u0026#34;));\rsearchInput.SendKeys(\u0026#34;selenium\u0026#34;);\r// Clears the entered text\r searchInput.Clear();\r}\rfinally\r{\rdriver.Quit();\r}\r}\r}\r}\r \rrequire \u0026#39;selenium-webdriver\u0026#39;\rdriver = Selenium::WebDriver.for :chrome\rbegin\r# Navigate to URL\r driver.get \u0026#39;https://google.com\u0026#39;\r# store \u0026#39;search_input\u0026#39; element\r search_input = driver.find_element(name: \u0026#39;q\u0026#39;)\rsearch_input.send_keys(\u0026#39;selenium\u0026#39;)\r# Clears the entered text\r search_input.clear\rensure\rdriver.quit\rend\r \rconst {Builder, By} = require(\u0026#39;selenium-webdriver\u0026#39;);\r(async function example() {\rlet driver = await new Builder().forBrowser(\u0026#39;chrome\u0026#39;).build();\rtry {\r// Navigate to Url\r await driver.get(\u0026#39;https://www.google.com\u0026#39;);\r// Store \u0026#39;SearchInput\u0026#39; element\r let searchInput = driver.findElement(By.name(\u0026#39;q\u0026#39;));\rawait searchInput.sendKeys(\u0026#34;selenium\u0026#34;);\r// Clears the entered text\r await searchInput.clear();\r}\rfinally {\rawait driver.quit();\r}\r})();\r \rimport org.openqa.selenium.By\rimport org.openqa.selenium.chrome.ChromeDriver\rfun main() {\rval driver = ChromeDriver()\rtry {\r// Navigate to Url\r driver.get(\u0026#34;https://www.google.com\u0026#34;)\r// Store \u0026#39;searchInput\u0026#39; element\r val searchInput = driver.findElement(By.name(\u0026#34;q\u0026#34;))\rsearchInput.sendKeys(\u0026#34;selenium\u0026#34;)\r// Clears the entered text\r searchInput.clear()\r} finally {\rdriver.quit()\r}\r}\r \r  "
},
{
	"uri": "https://selenium.dev/documentation/fr/driver_idiosyncrasies/",
	"title": "Singularités du Driver",
	"tags": [],
	"description": "",
	"content": " Singularités du Driver  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n "
},
{
	"uri": "https://selenium.dev/documentation/fr/support_packages/",
	"title": "Packages de support",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Packages de support "
},
{
	"uri": "https://selenium.dev/documentation/fr/legacy_docs/",
	"title": "Legacy",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Legacy Under this section you can find all the documentation related to the legacy components of Selenium. This is meant to be kept purely for historical reasons and not as a incentive to use deprecated components.\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/front_matter/",
	"title": "Front matter",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Front matter "
},
{
	"uri": "https://selenium.dev/documentation/fr/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://selenium.dev/documentation/fr/contributing/",
	"title": "Contributing to the Selenium Site &amp; Documentation",
	"tags": [],
	"description": "",
	"content": "  Page being translated from English to French. Do you speak French? Help us to translate it by sending us pull requests!\n Selenium is a big software project, its site and documentation are key to understanding how things work and learning effective ways to exploit its potential.\nThis project contains both Selenium\u0026rsquo;s site and documentation. This is an ongoing effort (not targeted at any specific release) to provide updated information on how to use Selenium effectively, how to get involved and how to contribute to Selenium.\nContributions toward the site and docs follow the process described in the below section about contributions. You should spend some time familiarising yourself with the documentation by reading more about it.\nThe Selenium project welcomes contributions from everyone. There are a number of ways you can help:\nReport an issue When reporting a new issues or commenting on existing issues please make sure discussions are related to concrete technical issues with the Selenium software, its site and/or documentation.\nAll of the Selenium components change quite fast over time, so this might cause the documentation to be out of date. If you find this to be the case, as mentioned, don\u0026rsquo;t doubt to create an issue for that. It also might be possible that you know how to bring up to date the documentation, so please send us a pull request with the related changes.\nIf you are not sure about what you have found is an issue or not, If you are not sure about what you have found is an issue or not, please ask through the communication channels described at https://selenium.dev/support.\nContributions The Selenium project welcomes new contributors. Individuals making significant and valuable contributions over time are made Committers and given commit-access to the project.\nThis guide will guide you through the contribution process.\nStep 1: Fork Fork the project on Github and check out your copy locally.\n% git clone git@github.com:seleniumhq/seleniumhq.github.io.git % cd seleniumhq.github.io Dependencies: Hugo We use Hugo to build and render the site and docs. To verify everything locally before even committing any changes, please install Hugo, get familiar with it and run the local server to render the site locally (detailed instructions can be found in the next steps).\nStep 2: Branch Create a feature branch and start hacking:\n% git checkout -b my-feature-branch We practice HEAD-based development, which means all changes are applied directly on top of master.\nStep 3: Make changes The repository contains the site and docs, which are two separate Hugo projects. If you want to make changes to the site, work on the site_source_files directory. To see a live preview of your changes, run hugo server on the site\u0026rsquo;s root directory.\n% cd site_source_files % hugo server To make changes to the docs, switch to the docs_source_files directory.\n% cd docs_source_files % hugo server The docs are translated into several languages, and translations are based on the English content. When you are changing a file, be sure to make your changes in all the other translated files as well. This might differ depending on the change, for example:\n If you add a code example to the browser_manipulation.en.md file, also add it to browser_manipulation.es.md, browser_manipulation.ef.md, browser_manipulation.ja.md, and all other translated files. If you find a translation that can be improved, only change the translated file. If you are adding a new language translation, add the new files with the appropriate suffix. There is no need to have everything translated to submit a PR, it can be done iteratively. Don\u0026rsquo;t forget to check some needed configuration values in the config.toml file. If you make text changes in the English version, replace the same section in the translated files with your change (yes, in English), and add the following notice at the top of the file.\n{{% notice info %}} \u0026lt;i class=\u0026#34;fas fa-language\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; Page being translated from English to {LANGUAGE}. Do you speak {LANGUAGE}? Help us to translate it by sending us pull requests! {{% /notice %}}  Step 4: Commit First make sure git knows your name and email address:\n% git config --global user.name \u0026#39;Santa Claus\u0026#39; % git config --global user.email \u0026#39;santa@example.com\u0026#39; Writing good commit messages is important. A commit message should describe what changed, why, and reference issues fixed (if any). Follow these guidelines when writing one:\n The first line should be around 50 characters or less and contain a short description of the change. Keep the second line blank. Wrap all other lines at 72 columns. Include Fixes #N, where N is the issue number the commit fixes, if any.  A good commit message can look like this:\nexplain commit normatively in one line Body of commit message is a few lines of text, explaining things in more detail, possibly giving some background about the issue being fixed, etc. The body of the commit message can be several paragraphs, and please do proper word-wrap and keep columns shorter than about 72 characters or so. That way `git log` will show things nicely even when it is indented. Fixes #141 The first line must be meaningful as it\u0026rsquo;s what people see when they run git shortlog or git log --oneline.\nStep 5: Rebase Use git rebase (not git merge) to sync your work from time to time.\n% git fetch upstream % git rebase upstream/master Step 6: Test Always remember to run the local server, with this you can be safe that your changes have not broken anything.\nStep 7: Push % git push origin my-feature-branch Go to https://github.com/yourusername/seleniumhq.github.io.git and press the Pull Request and fill out the form. Please indicate that you\u0026rsquo;ve signed the CLA (see Step 7).\nPull requests are usually reviewed within a few days. If there are comments to address, apply your changes in new commits (preferably fixups) and push to the same branch.\nStep 8: Integration When code review is complete, a committer will take your PR and integrate it on the repository\u0026rsquo;s master branch. Because we like to keep a linear history on the master branch, we will normally squash and rebase your branch history.\nCommunication All details on how to communicate with the project contributors and the community overall can be found at https://selenium.dev/support\n"
},
{
	"uri": "https://selenium.dev/documentation/fr/",
	"title": "Le Projet d&#39;Automatisation de Navigateur Selenium",
	"tags": [],
	"description": "",
	"content": " Le Projet d\u0026rsquo;Automatisation de Navigateur Selenium Selenium est projet englobant un éventail d\u0026rsquo;outils et de librairies permettant l\u0026rsquo;automtisation des navigateurs internet.\nIl fournit des extensions afin d\u0026rsquo;émuler des interactions utilisateur avec les navigateurs, un serveur de distribution permettant la mise à l\u0026rsquo;échelle de l\u0026rsquo;allocation de navigateur ainsi que l\u0026rsquo;infrastructure pour l\u0026rsquo;implémentation de la spécification W3C WebDriver permettant l\u0026rsquo;écriture de code interchangeable pour tous les principaux navigateurs.\nCe projet est rendu possible grâce au contributeurs volontaires ayant investi des milliers d\u0026rsquo;heures de leur temps et rendu le code source disponible librement à quiconque souhaitant l\u0026rsquo;utiliser et l\u0026rsquo;améliorer ou simplement s\u0026rsquo;amuser.\nSelenium rassemble distributeurs de navigateur, ingénieurs et entousiastes pour favoriser une discussion ouverte autour de l\u0026rsquo;automatisation de la platerforme web. Le projet organise une conférence annuelle afin d\u0026rsquo;entretenir cette communauté.\nAu coeur de Selenium se trouve WebDriver, une interface permettant d\u0026rsquo;écrire des instructions pouvant être exécutées indifférement par de nombreux navigateurs. Voici par exemple une des plus simples instructions disponibles:\nJava Python C# Ruby JavaScript Kotlin import org.openqa.selenium.By; import org.openqa.selenium.Keys; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.firefox.FirefoxDriver; import org.openqa.selenium.support.ui.WebDriverWait; import static org.openqa.selenium.support.ui.ExpectedConditions.presenceOfElementLocated; import java.time.Duration; public class HelloSelenium { public static void main(String[] args) { WebDriver driver = new FirefoxDriver(); WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10)); try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;); driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER); WebElement firstResult = wait.until(presenceOfElementLocated(By.cssSelector(\u0026#34;h3\u0026gt;div\u0026#34;))); System.out.println(firstResult.getAttribute(\u0026#34;textContent\u0026#34;)); } finally { driver.quit(); } } }   from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.common.keys import Keys from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support.expected_conditions import presence_of_element_located #Cet exemple requiert Selenium WebDriver 3.13 ou plus récent with webdriver.Firefox() as driver: wait = WebDriverWait(driver, 10) driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.find_element_by_name(\u0026#34;q\u0026#34;).send_keys(\u0026#34;cheese\u0026#34; + Keys.RETURN) first_result = wait.until(presence_of_element_located((By.CSS_SELECTOR, \u0026#34;h3\u0026gt;div\u0026#34;))) print(first_result.get_attribute(\u0026#34;textContent\u0026#34;))   using System; using OpenQA.Selenium; using OpenQA.Selenium.Firefox; using OpenQA.Selenium.Support.UI; using SeleniumExtras.WaitHelpers; class HelloSelenium { static void Main() { using (IWebDriver driver = new FirefoxDriver()) { WebDriverWait wait = new WebDriverWait(driver, TimeSpan.FromSeconds(10)); driver.Navigate().GoToUrl(\u0026#34;https://www.google.com/ncr\u0026#34;); driver.FindElement(By.Name(\u0026#34;q\u0026#34;)).SendKeys(\u0026#34;cheese\u0026#34; + Keys.Enter); IWebElement firstResult = wait.Until(ExpectedConditions.ElementExists(By.CssSelector(\u0026#34;h3\u0026gt;div\u0026#34;))); Console.WriteLine(firstResult.GetAttribute(\u0026#34;textContent\u0026#34;)); } } }   require \u0026#39;selenium-webdriver\u0026#39; driver = Selenium::WebDriver.for :firefox wait = Selenium::WebDriver::Wait.new(timeout: 10) begin driver.get \u0026#39;https://google.com/ncr\u0026#39; driver.find_element(name: \u0026#39;q\u0026#39;).send_keys \u0026#39;cheese\u0026#39;, :return first_result = wait.until { driver.find_element(css: \u0026#39;h3\u0026gt;div\u0026#39;) } puts first_result.attribute(\u0026#39;textContent\u0026#39;) ensure driver.quit end   const {Builder, By, Key, until} = require(\u0026#39;selenium-webdriver\u0026#39;); (async function example() { let driver = await new Builder().forBrowser(\u0026#39;firefox\u0026#39;).build(); try { // Navigate to Url  await driver.get(\u0026#39;https://www.google.com\u0026#39;); // Enter text \u0026#34;cheese\u0026#34; and perform keyboard action \u0026#34;Enter\u0026#34;  await driver.findElement(By.name(\u0026#39;q\u0026#39;)).sendKeys(\u0026#39;cheese\u0026#39;, Key.ENTER); let firstResult = await driver.wait(until.elementLocated(By.css(\u0026#39;h3\u0026gt;div\u0026#39;)), 10000); console.log(await firstResult.getAttribute(\u0026#39;textContent\u0026#39;)); } finally{ driver.quit(); } })();   import org.openqa.selenium.By import org.openqa.selenium.Keys import org.openqa.selenium.firefox.FirefoxDriver import org.openqa.selenium.support.ui.ExpectedConditions.presenceOfElementLocated import org.openqa.selenium.support.ui.WebDriverWait import java.time.Duration fun main() { val driver = FirefoxDriver() val wait = WebDriverWait(driver, Duration.ofSeconds(10)) try { driver.get(\u0026#34;https://google.com/ncr\u0026#34;) driver.findElement(By.name(\u0026#34;q\u0026#34;)).sendKeys(\u0026#34;cheese\u0026#34; + Keys.ENTER) val firstResult = wait.until(presenceOfElementLocated(By.cssSelector(\u0026#34;h3\u0026gt;div\u0026#34;))) println(firstResult.getAttribute(\u0026#34;textContent\u0026#34;)) } finally { driver.quit() } }     Suivez le Quick Tour pour une explication complète de ce qu\u0026rsquo;il se passe derrière ces exemples de code. Il est conseillé de poursuivre cette documentation narrative afin de voir comment installer et utiliser Selenium en tant qu\u0026rsquo;outil d\u0026rsquo;automatisation de test, ainsi que pour mettre à l\u0026rsquo;echelle l\u0026rsquo;exécution de tels tests sur de larges environnements distribués, avec de multiples navigateurs et des systèmes d\u0026rsquo;exploitation différents.\nGetting started Si Selenium est nouveau pour vous, nous vous proposons quelques ressources qui pourront vous aider à vous mettre à niveau très rapidement.\n Tour rapide  WebDriver IDE Grid   "
},
{
	"uri": "https://selenium.dev/documentation/fr/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]